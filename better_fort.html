<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capybara Survivor</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="crosshair" class="crosshair"></div>
    <div id="mats" class="mats">ü™µ 30</div>
    <div id="coin-display" style="position:absolute;bottom:215px;right:25px;color:#f1c40f;font-size:24px;text-shadow:2px 2px 6px rgba(0,0,0,0.8);">ü™ô 0</div>

    <!-- Biome + Weather badge -->
    <div id="biome-badge" style="position:absolute;top:20px;right:20px;background:rgba(0,0,0,0.6);border-radius:10px;padding:8px 14px;color:#fff;font-size:13px;font-weight:700;text-align:right;border:1px solid rgba(255,255,255,0.15);line-height:1.6;">
        <div id="biome-label" style="font-size:16px;">üå≤ Forest</div>
        <div id="weather-label" style="color:rgba(255,255,255,0.65);font-size:12px;">‚òÄÔ∏è Clear</div>
    </div>

    <!-- Weather screen overlay (storm darkness, rain tint) -->
    <div id="weather-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;opacity:0;transition:opacity 1.5s;"></div>
    <div id="kill-counter" class="stat-bar stat-bar--kills">ELIMINATIONS: 0</div>
    <div id="wave-counter" class="stat-bar stat-bar--wave">WAVE: 1</div>
    <div id="enemies-remaining" class="stat-bar stat-bar--enemies">ENEMIES: 5</div>

    <!-- Active power-up indicator -->
    <div id="powerup-display" style="position:absolute;top:160px;left:20px;display:none;background:rgba(0,0,0,0.65);border-radius:8px;padding:8px 14px;border-left:3px solid #f1c40f;color:#fff;font-size:14px;min-width:160px;">
        <div style="font-size:10px;letter-spacing:2px;color:#f1c40f;text-transform:uppercase;font-weight:700;margin-bottom:4px;">‚ö° Active Power-Up</div>
        <div id="powerup-name" style="font-size:15px;font-weight:700;"></div>
        <div style="height:4px;background:#333;border-radius:2px;margin-top:6px;overflow:hidden;">
            <div id="powerup-bar" style="height:100%;background:linear-gradient(90deg,#f1c40f,#e67e22);width:100%;transition:width 0.1s;border-radius:2px;"></div>
        </div>
    </div>
    <div id="inventory" class="inventory">
        <div id="slot1" class="slot slot--active">1<br>KNIFE</div>
        <div id="slot2" class="slot">2<br>BOW</div>
        <div id="slot3" class="slot">3<br>SPEAR</div>
        <div id="slot4" class="slot">4<br>AXE</div>
    </div>
    <div id="hud" class="hud">
        <div class="bar"><div id="health-bar" class="bar__fill bar__fill--health"></div></div>
        <div id="ammo-display" class="hud__stat hud__stat--ammo">KNIFE: 30/90</div>
        <div id="bow-charge-bar" class="bar bar--charge u-hidden">
            <div id="bow-charge-fill" class="bar__fill bar__fill--charge"></div>
        </div>
        <div id="reload-prompt" class="hud__stat hud__stat--reload u-hidden">Press R to Reload</div>
        <div id="sprint-indicator" class="hud__stat hud__stat--sprint u-hidden">SPRINTING</div>
    </div>

    <!-- Upgrade Tracker HUD -->
    <div id="upgrade-tracker" class="upgrade-tracker">
        <div class="upgrade-tracker__title">‚ö° Upgrades</div>
        <div id="upgrade-tracker-items"></div>
    </div>
    
    <div id="start-screen" class="modal modal--start">
        <h1 class="modal__title modal__title--lg">CAPYBARA SURVIVOR</h1>
        <p class="modal__subtitle">Survive waves of capybaras ‚Äî collect wood to reroll upgrades!</p>
        <div id="start-skill-preview" style="display:none;margin-bottom:20px;background:rgba(0,0,0,0.4);border-radius:10px;padding:12px 24px;color:#f1c40f;font-size:15px;font-weight:700;text-align:center;"></div>
        <button id="start-button" class="btn">START GAME</button>
    </div>

    <!-- Game Over + Skill Tree Screen -->
    <div id="game-over-screen" class="modal modal--game-over" style="overflow-y:auto;padding:30px 0;align-items:flex-start;justify-content:flex-start;">
        <div style="width:100%;max-width:900px;margin:0 auto;padding:0 20px;">
            <h1 class="modal__title modal__title--xl" style="text-align:center;margin-bottom:6px;">GAME OVER</h1>
            <p id="wave-stats" class="modal__stat" style="text-align:center;"></p>
            <p id="kill-stats" class="modal__stat modal__stat--secondary" style="text-align:center;"></p>
            <!-- Skill point award banner -->
            <div id="sp-award-banner" style="text-align:center;margin:10px 0 20px;padding:10px 20px;background:rgba(241,196,15,0.15);border:2px solid #f1c40f;border-radius:12px;">
                <span style="color:#f1c40f;font-size:22px;font-weight:900;">‚≠ê <span id="sp-awarded">0</span> SKILL POINTS EARNED</span>
                <span style="color:rgba(255,255,255,0.55);font-size:13px;display:block;margin-top:2px;">1 point per wave survived ¬∑ bonus for boss waves</span>
            </div>
            <!-- Skill tree header -->
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;">
                <h3 style="color:#fff;font-size:20px;font-family:'Arial Black',sans-serif;margin:0;">üå≥ SKILL TREE</h3>
                <span style="color:#f1c40f;font-size:18px;font-weight:700;">‚≠ê <span id="sp-remaining">0</span> points remaining</span>
            </div>
            <div id="skill-tree-grid" style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:24px;"></div>
            <div style="text-align:center;">
                <p id="skill-save-note" style="color:rgba(255,255,255,0.4);font-size:13px;margin-bottom:14px;">Upgrades persist across all future runs</p>
                <button id="play-again-btn" style="padding:16px 60px;font-size:26px;font-family:'Arial Black',sans-serif;background:#2196f3;border:none;border-radius:10px;cursor:pointer;color:#fff;box-shadow:0 6px 20px rgba(33,150,243,0.4);transition:transform 0.15s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">‚ñ∂ PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <!-- Upgrade Selection Screen -->
    <div id="upgrade-screen" class="upgrade-screen">
        <div class="upgrade-screen__header">
            <div id="upgrade-wave-badge" class="upgrade-screen__wave-badge">Wave 1 Complete</div>
            <h2 class="upgrade-screen__title">CHOOSE UPGRADE</h2>
            <p class="upgrade-screen__subtitle">Select one upgrade to power up your arsenal</p>
            <div style="display:flex;align-items:center;gap:14px;justify-content:center;margin-top:10px;">
                <span id="upgrade-wood-display" style="color:#8bc34a;font-size:16px;font-weight:700;text-shadow:1px 1px 4px rgba(0,0,0,0.8);">ü™µ 0 wood</span>
                <button id="reroll-btn" style="padding:8px 22px;font-size:14px;font-family:'Arial Black',sans-serif;background:rgba(139,195,74,0.25);border:2px solid #8bc34a;border-radius:8px;cursor:pointer;color:#8bc34a;font-weight:700;transition:all 0.15s;" onmouseover="this.style.background='rgba(139,195,74,0.45)'" onmouseout="this.style.background='rgba(139,195,74,0.25)'">
                    üîÑ Reroll <span id="reroll-cost-display">(15 ü™µ)</span>
                </button>
            </div>
        </div>
        <div id="upgrade-cards" class="upgrade-cards"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // =====================================================================
        // COIN SYSTEM
        // =====================================================================
        let coins = 0;

        function addCoins(amount) {
            coins += amount;
            document.getElementById('coin-display').innerText = `ü™ô ${coins}`;
            // Floating coin indicator
            const el = document.createElement('div');
            el.style.cssText = `position:absolute;bottom:260px;right:30px;color:#f1c40f;font-size:18px;font-weight:700;text-shadow:1px 1px 4px rgba(0,0,0,0.9);pointer-events:none;z-index:200;transition:opacity 0.5s,transform 0.5s;`;
            el.innerText = `+${amount} ü™ô`;
            document.body.appendChild(el);
            setTimeout(() => { el.style.opacity='0'; el.style.transform='translateY(-30px)'; setTimeout(()=>el.remove(),500); }, 600);
        }

        // =====================================================================
        // POWER-UP DROP SYSTEM
        // =====================================================================
        const activePowerUp = { type: null, endTime: 0, timer: null };
        const powerUpPickups = []; // 3D orbs in the world

        const POWER_UP_TYPES = [
            { id: 'speed',       label: '‚ö° Speed Boost',    color: 0x00eeff, duration: 6000,  dropChance: 0.18 },
            { id: 'damage',      label: 'üî• Damage Boost',   color: 0xff6600, duration: 8000,  dropChance: 0.15 },
            { id: 'invincible',  label: 'üõ°Ô∏è Invincibility',  color: 0xffdd00, duration: 5000,  dropChance: 0.10 },
            { id: 'ammo',        label: 'üéØ Ammo Refill',    color: 0x44ff88, duration: 0,     dropChance: 0.20 },
        ];

        function tryDropPowerUp(position) {
            const roll = Math.random();
            let cumulative = 0;
            let chosen = null;
            for(const p of POWER_UP_TYPES) {
                cumulative += p.dropChance + skillTree.powerDropBonus;
                if(roll < cumulative) { chosen = p; break; }
            }
            if(!chosen) return; // ~37% chance nothing drops

            const orb = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 10, 10),
                new THREE.MeshStandardMaterial({ color: chosen.color, emissive: chosen.color, emissiveIntensity: 0.6, roughness: 0.3 })
            );
            orb.position.copy(position);
            orb.position.y = 0.6;
            orb.userData.powerUpType = chosen;
            orb.userData.spawnTime = Date.now();
            scene.add(orb);
            powerUpPickups.push(orb);
        }

        function applyPowerUp(type) {
            // Clear existing
            if(activePowerUp.timer) clearTimeout(activePowerUp.timer);
            activePowerUp.type = type.id;
            activePowerUp.endTime = Date.now() + type.duration;

            const display = document.getElementById('powerup-display');
            document.getElementById('powerup-name').innerText = type.label;
            display.style.display = 'block';

            playSound(700, 0.2, 'sine', 0.12);
            setTimeout(() => playSound(900, 0.15, 'sine', 0.1), 100);

            if(type.id === 'ammo') {
                // Instant refill
                currentAmmo = maxMagSize;
                reserveAmmo = Math.min(reserveAmmo + 60, 300);
                currentArrows = maxArrows;
                currentSpears = maxSpears;
                updateAmmoDisplay();
                activePowerUp.type = null;
                display.style.display = 'none';
                return;
            }

            activePowerUp.timer = setTimeout(() => {
                activePowerUp.type = null;
                display.style.display = 'none';
            }, type.duration);
        }

        function updatePowerUps() {
            // Animate orbs and check pickup
            for(let i = powerUpPickups.length - 1; i >= 0; i--) {
                const orb = powerUpPickups[i];
                orb.position.y = 0.6 + Math.sin((Date.now() - orb.userData.spawnTime) * 0.003) * 0.2;
                orb.rotation.y += 0.04;
                // Expire after 12 seconds
                if(Date.now() - orb.userData.spawnTime > 12000) {
                    scene.remove(orb); powerUpPickups.splice(i, 1); continue;
                }
                // Pickup range
                if(player.position.distanceTo(orb.position) < 1.4) {
                    applyPowerUp(orb.userData.powerUpType);
                    scene.remove(orb); powerUpPickups.splice(i, 1);
                }
            }
            // Update power-up timer bar
            if(activePowerUp.type && activePowerUp.endTime > 0) {
                const pType = POWER_UP_TYPES.find(p => p.id === activePowerUp.type);
                if(pType && pType.duration > 0) {
                    const remaining = Math.max(0, activePowerUp.endTime - Date.now());
                    document.getElementById('powerup-bar').style.width = (remaining / pType.duration * 100) + '%';
                }
            }
        }

        function isPowerUpActive(id) { return activePowerUp.type === id; }

        // =====================================================================
        // PERSISTENT SKILL TREE (survives page reloads via localStorage)
        // =====================================================================
        const SKILL_NODES = [
            { id: 'maxhp',     icon: '‚ù§Ô∏è',  name: 'Iron Constitution', desc: '+25 Max HP per rank',        color:'#e74c3c', maxRank: 8,  cost: 1,
              apply(rank) { maxPlayerHealth = 100 + rank * 25; } },
            { id: 'startammo', icon: 'üî™',  name: 'Loaded Pockets',    desc: '+15 starting knives/rank',   color:'#c0c0c0', maxRank: 6,  cost: 1,
              apply(rank) { /* applied at game start */ } },
            { id: 'movespd',   icon: 'üëü',  name: 'Fleet Foot',        desc: '+8% move speed per rank',    color:'#3498db', maxRank: 5,  cost: 1,
              apply(rank) { skillTree.moveSpeedBonus = rank * 0.08; } },
            { id: 'reloadspd', icon: 'üîÑ',  name: 'Quick Hands',       desc: '15% faster reload per rank', color:'#2ecc71', maxRank: 5,  cost: 1,
              apply(rank) { skillTree.reloadSpeedBonus = rank * 0.15; } },
            { id: 'dmgall',    icon: '‚öîÔ∏è',  name: 'Battle Hardened',   desc: '+4 all damage per rank',     color:'#e67e22', maxRank: 10, cost: 1,
              apply(rank) { playerUpgrades.allDamageBonus = rank * 4; } },
            { id: 'healregen', icon: 'üíä',  name: 'Bloodthirsty',      desc: '+3 HP on kill per rank',     color:'#ff6b9d', maxRank: 6,  cost: 1,
              apply(rank) { skillTree.healPerKill = 5 + rank * 3; } },
            { id: 'woodperk',  icon: 'ü™µ',  name: 'Lumberjack',        desc: '+8 wood per kill per rank',  color:'#8b4513', maxRank: 5,  cost: 1,
              apply(rank) { skillTree.woodPerKill = 20 + rank * 8; } },
            { id: 'arrowcap',  icon: 'üèπ',  name: 'Fletching Master',  desc: '+8 max arrows per rank',     color:'#9b59b6', maxRank: 5,  cost: 1,
              apply(rank) { /* applied at game start */ } },
            { id: 'invdur',    icon: 'üõ°Ô∏è',  name: 'Shielded Soul',     desc: '+1s invincibility per rank', color:'#f1c40f', maxRank: 5,  cost: 2,
              apply(rank) { skillTree.invincibilityBonus = rank * 1000; } },
            { id: 'powerdrop', icon: 'üåü',  name: 'Lucky Drops',       desc: '+8% power-up drop chance/rank', color:'#00eeff', maxRank: 4, cost: 2,
              apply(rank) { skillTree.powerDropBonus = rank * 0.08; } },
            { id: 'coinbonus', icon: 'ü™ô',  name: 'Treasure Hunter',   desc: '+2 coins per kill per rank', color:'#f1c40f', maxRank: 6,  cost: 1,
              apply(rank) { skillTree.coinsPerKill = rank * 2; } },
            { id: 'startwood', icon: 'üå≤',  name: 'Prepared',          desc: '+30 starting wood per rank', color:'#4caf50', maxRank: 5,  cost: 1,
              apply(rank) { /* applied at game start */ } },
        ];

        // Load saved skill ranks from localStorage
        function loadSkillRanks() {
            try { return JSON.parse(localStorage.getItem('capybara_skills') || '{}'); } catch(e) { return {}; }
        }
        function saveSkillRanks(ranks) {
            try { localStorage.setItem('capybara_skills', JSON.stringify(ranks)); } catch(e) {}
        }
        function loadSkillPoints() {
            try { return parseInt(localStorage.getItem('capybara_sp') || '0'); } catch(e) { return 0; }
        }
        function saveSkillPoints(sp) {
            try { localStorage.setItem('capybara_sp', String(sp)); } catch(e) {}
        }

        let savedRanks = loadSkillRanks();
        let availableSkillPoints = loadSkillPoints();

        // Apply all saved skill tree bonuses at startup
        function applyAllSkillBonuses() {
            SKILL_NODES.forEach(node => {
                const rank = savedRanks[node.id] || 0;
                if(rank > 0) node.apply(rank);
            });
            // Start-of-game stat overrides from skill tree
            const ammoRank = savedRanks['startammo'] || 0;
            currentAmmo = Math.min(maxMagSize + ammoRank * 15, maxMagSize);
            reserveAmmo = 90 + ammoRank * 15;
            const arrowRank = savedRanks['arrowcap'] || 0;
            maxArrows = 50 + arrowRank * 8;
            currentArrows = maxArrows;
            const woodRank = savedRanks['startwood'] || 0;
            wood = 30 + woodRank * 30;
            document.getElementById('mats').innerText = `ü™µ ${wood}`;
            document.getElementById('health-bar').style.width = '100%';
        }

        // Render the skill tree grid in the game over screen
        function renderSkillTree() {
            document.getElementById('sp-remaining').innerText = availableSkillPoints;
            const grid = document.getElementById('skill-tree-grid');
            grid.innerHTML = '';
            SKILL_NODES.forEach(node => {
                const rank = savedRanks[node.id] || 0;
                const maxed = rank >= node.maxRank;
                const canAfford = availableSkillPoints >= node.cost;
                const card = document.createElement('div');
                card.style.cssText = `
                    background:rgba(255,255,255,0.06);border-radius:10px;padding:14px 12px 12px;
                    border:2px solid ${maxed ? 'rgba(255,255,255,0.15)' : canAfford ? node.color+'99' : 'rgba(255,255,255,0.1)'};
                    opacity:${maxed ? 0.5 : 1};cursor:${!maxed && canAfford ? 'pointer' : 'default'};
                    transition:transform 0.12s,box-shadow 0.12s;position:relative;
                `;
                // Rank pips
                let pips = '';
                for(let i = 0; i < node.maxRank; i++) {
                    pips += `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:3px;background:${i < rank ? node.color : 'rgba(255,255,255,0.15)'};"></span>`;
                }
                card.innerHTML = `
                    <div style="font-size:26px;margin-bottom:6px;">${node.icon}</div>
                    <div style="color:#fff;font-size:13px;font-weight:800;margin-bottom:4px;">${node.name}</div>
                    <div style="color:rgba(255,255,255,0.5);font-size:11px;line-height:1.4;margin-bottom:8px;">${node.desc}</div>
                    <div style="margin-bottom:8px;">${pips}</div>
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <span style="color:${node.color};font-size:12px;font-weight:700;">${maxed ? 'MAX' : `Rank ${rank}/${node.maxRank}`}</span>
                        <span style="color:#f1c40f;font-size:12px;font-weight:700;">${maxed ? '' : `‚≠ê ${node.cost}`}</span>
                    </div>
                `;
                if(!maxed && canAfford) {
                    card.addEventListener('mouseenter', () => { card.style.transform='translateY(-3px)'; card.style.boxShadow=`0 6px 20px ${node.color}44`; });
                    card.addEventListener('mouseleave', () => { card.style.transform=''; card.style.boxShadow=''; });
                    card.addEventListener('click', () => {
                        availableSkillPoints -= node.cost;
                        savedRanks[node.id] = (savedRanks[node.id] || 0) + 1;
                        saveSkillRanks(savedRanks);
                        saveSkillPoints(availableSkillPoints);
                        playSound(600, 0.15, 'sine', 0.12);
                        setTimeout(() => playSound(900, 0.12, 'sine', 0.08), 100);
                        renderSkillTree();
                    });
                }
                grid.appendChild(card);
            });
        }

        // Show the game over + skill tree screen
        function showGameOver(wavesCompleted, totalKills) {
            gameStarted = false;
            document.exitPointerLock();
            // Award skill points: 1 per wave, +1 bonus per boss wave survived
            const bossWaveBonus = Math.floor(wavesCompleted / 5);
            const earned = wavesCompleted + bossWaveBonus;
            availableSkillPoints += earned;
            saveSkillPoints(availableSkillPoints);

            document.getElementById('wave-stats').innerText = `Waves Completed: ${wavesCompleted}`;
            document.getElementById('kill-stats').innerText = `Total Eliminations: ${totalKills}`;
            document.getElementById('sp-awarded').innerText = earned;
            renderSkillTree();
            document.getElementById('game-over-screen').classList.add('is-visible');
        }

        document.getElementById('play-again-btn').addEventListener('click', () => {
            location.reload();
        });

        // Show skill preview on start screen if player has existing skills
        function updateStartScreenPreview() {
            const totalRanks = Object.values(savedRanks).reduce((s, v) => s + v, 0);
            const preview = document.getElementById('start-skill-preview');
            if(totalRanks > 0) {
                preview.style.display = 'block';
                preview.innerText = `‚≠ê ${availableSkillPoints} skill points available ¬∑ ${totalRanks} skill ranks active`;
            }
        }
        updateStartScreenPreview();

        // =====================================================================
        // SHOP SYSTEM (removed - replaced by post-death skill tree)
        // =====================================================================
        let shopScreenOpen = false; // kept for mousedown guard compatibility

        function getEffectiveReloadTime() { return 2000 * (1 - skillTree.reloadSpeedBonus); }
        function getEffectiveMoveSpeed() { return 0.15 * (1 + skillTree.moveSpeedBonus); }

        // =====================================================================
        // RUNTIME STATE (overridden by skill tree on start)
        // =====================================================================
        let maxPlayerHealth = 100;
        const skillTree = {
            reloadSpeedBonus: 0,
            moveSpeedBonus: 0,
            woodPerKill: 20,
            healPerKill: 5,
            coinsPerKill: 0,
            invincibilityBonus: 0,
            powerDropBonus: 0,
        };

        // Current player upgrade stats (multipliers/bonuses on top of base values)
        const playerUpgrades = {
            knifeDamageBonus: 0,
            bowDamageBonus: 0,
            spearDamageBonus: 0,
            axeDamageBonus: 0,
            allDamageBonus: 0,
            fireRateBonus: 0,
            bowChargeSpeedBonus: 0,
            rangeBonus: 0,
        };

        // Track upgrade history for the tracker HUD
        const upgradeHistory = [];

        // Rarity definitions: { weight, color class, label }
        const RARITIES = {
            common:    { weight: 50, cssClass: 'upgrade-card--common',    label: 'Common',    starColor: '#aaaaaa' },
            uncommon:  { weight: 28, cssClass: 'upgrade-card--uncommon',  label: 'Uncommon',  starColor: '#1ec850' },
            rare:      { weight: 14, cssClass: 'upgrade-card--rare',      label: 'Rare',      starColor: '#3c82ff' },
            epic:      { weight: 6,  cssClass: 'upgrade-card--epic',      label: 'Epic',      starColor: '#b43cff' },
            legendary: { weight: 2,  cssClass: 'upgrade-card--legendary', label: 'Legendary', starColor: '#ffa500' },
        };

        // Upgrade template definitions
        // Each entry: { type, icon, name, desc, getRarity, apply }
        // getRarity returns one key of RARITIES; apply mutates playerUpgrades and returns display string
        const UPGRADE_POOL = [
            // ---- DAMAGE UPGRADES ----
            {
                type: 'damage',
                icon: 'üó°Ô∏è',
                name: 'Knife Edge',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 2, uncommon: 4, rare: 6, epic: 10, legendary: 16 }[r];
                    return { rarity: r, bonus, desc: `Your thrown knives hit harder.`, bonusText: `+${bonus} Knife Damage` };
                },
                apply(variant) { playerUpgrades.knifeDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'üèπ',
                name: 'Eagle Eye',
                applies: 'Bow',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 3, uncommon: 6, rare: 10, epic: 16, legendary: 25 }[r];
                    return { rarity: r, bonus, desc: `Arrows pierce deeper on impact.`, bonusText: `+${bonus} Arrow Damage` };
                },
                apply(variant) { playerUpgrades.bowDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'üî±',
                name: 'Iron Tip',
                applies: 'Spear',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 4, uncommon: 8, rare: 14, epic: 22, legendary: 35 }[r];
                    return { rarity: r, bonus, desc: `Forged tip tears through thick fur.`, bonusText: `+${bonus} Spear Damage` };
                },
                apply(variant) { playerUpgrades.spearDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'ü™ì',
                name: 'Whetstone',
                applies: 'Axe',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 5, uncommon: 10, rare: 18, epic: 28, legendary: 45 }[r];
                    return { rarity: r, bonus, desc: `A finely honed axe leaves no survivors.`, bonusText: `+${bonus} Axe Damage` };
                },
                apply(variant) { playerUpgrades.axeDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'üí•',
                name: 'Bloodlust',
                applies: 'All Weapons',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 2, uncommon: 4, rare: 7, epic: 11, legendary: 18 }[r];
                    return { rarity: r, bonus, desc: `Raw power surges through every strike.`, bonusText: `+${bonus} All Damage` };
                },
                apply(variant) { playerUpgrades.allDamageBonus += variant.bonus; }
            },
            // ---- FIRE RATE UPGRADES ----
            {
                type: 'firerate',
                icon: '‚ö°',
                name: 'Quick Draw',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const pct = { common: 5, uncommon: 10, rare: 16, epic: 22, legendary: 32 }[r];
                    return { rarity: r, bonus: pct, desc: `Muscle memory speeds up your throw cycle.`, bonusText: `-${pct}% Knife Cooldown` };
                },
                apply(variant) { playerUpgrades.fireRateBonus = Math.min(0.85, playerUpgrades.fireRateBonus + variant.bonus / 100); }
            },
            {
                type: 'firerate',
                icon: 'üåÄ',
                name: 'Rapid Nock',
                applies: 'Bow',
                getVariant() {
                    const r = rollRarity();
                    const pct = { common: 5, uncommon: 10, rare: 16, epic: 22, legendary: 32 }[r];
                    return { rarity: r, bonus: pct, desc: `Train yourself to draw the bow with practiced speed.`, bonusText: `-${pct}% Bow Charge Time` };
                },
                apply(variant) { playerUpgrades.bowChargeSpeedBonus = Math.min(0.85, playerUpgrades.bowChargeSpeedBonus + variant.bonus / 100); }
            },
            {
                type: 'firerate',
                icon: 'üî•',
                name: 'Berserker',
                applies: 'All Weapons',
                getVariant() {
                    const r = rollRarity();
                    const pct = { common: 4, uncommon: 8, rare: 13, epic: 20, legendary: 30 }[r];
                    return { rarity: r, bonus: pct, desc: `Fury takes over ‚Äî every weapon feels lighter.`, bonusText: `-${pct}% All Cooldowns` };
                },
                apply(variant) {
                    playerUpgrades.fireRateBonus = Math.min(0.85, playerUpgrades.fireRateBonus + variant.bonus / 100);
                    playerUpgrades.bowChargeSpeedBonus = Math.min(0.85, playerUpgrades.bowChargeSpeedBonus + variant.bonus / 100);
                }
            },
            // ---- RANGE UPGRADES ----
            {
                type: 'range',
                icon: 'üéØ',
                name: 'Far Reach',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 15, uncommon: 25, rare: 40, epic: 60, legendary: 90 }[r];
                    return { rarity: r, bonus, desc: `Honed aerodynamics let the blade fly further.`, bonusText: `+${bonus} Knife Range` };
                },
                apply(variant) { playerUpgrades.rangeBonus += variant.bonus; }
            },
            {
                type: 'range',
                icon: 'üèîÔ∏è',
                name: 'Long Shot',
                applies: 'Bow',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 15, uncommon: 30, rare: 50, epic: 75, legendary: 110 }[r];
                    return { rarity: r, bonus, desc: `Limb tension launches arrows into the distance.`, bonusText: `+${bonus} Arrow Range` };
                },
                apply(variant) { playerUpgrades.rangeBonus += variant.bonus; }
            },
            {
                type: 'range',
                icon: 'üåä',
                name: 'Javelin',
                applies: 'Spear',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 15, uncommon: 28, rare: 45, epic: 68, legendary: 100 }[r];
                    return { rarity: r, bonus, desc: `A rebalanced shaft carries the spear farther.`, bonusText: `+${bonus} Spear Range` };
                },
                apply(variant) { playerUpgrades.rangeBonus += variant.bonus; }
            },
            {
                type: 'capacity',
                icon: 'üî™',
                name: 'Knife Pouch',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 3, uncommon: 6, rare: 10, epic: 16, legendary: 25 }[r];
                    return { rarity: r, bonus, desc: `A larger pouch lets you carry more throwing knives before reloading.`, bonusText: `+${bonus} Knife Capacity` };
                },
                apply(variant) {
                    maxMagSize += variant.bonus;
                    currentAmmo = Math.min(currentAmmo + variant.bonus, maxMagSize);
                    updateAmmoDisplay();
                }
            },
        ];

        function rollRarity() {
            const total = Object.values(RARITIES).reduce((s, r) => s + r.weight, 0);
            let rand = Math.random() * total;
            for (const [key, r] of Object.entries(RARITIES)) {
                rand -= r.weight;
                if (rand <= 0) return key;
            }
            return 'common';
        }

        function pickThreeUpgrades() {
            // Shuffle pool and pick 3 different upgrade templates, generate their variants
            const shuffled = [...UPGRADE_POOL].sort(() => Math.random() - 0.5);
            const picks = [];
            const usedTypes = new Set();
            for (const template of shuffled) {
                if (picks.length >= 3) break;
                // Allow duplicates of same type only if pool is thin
                if (!usedTypes.has(template.name)) {
                    usedTypes.add(template.name);
                    const variant = template.getVariant();
                    picks.push({ template, variant });
                }
            }
            // Pad if needed
            while (picks.length < 3) {
                const t = UPGRADE_POOL[Math.floor(Math.random() * UPGRADE_POOL.length)];
                const variant = t.getVariant();
                picks.push({ template: t, variant });
            }
            return picks;
        }

        let upgradeScreenOpen = false;
        let rerollCount = 0; // resets each wave, cost escalates

        function getRerollCost() {
            return 15 + rerollCount * 10; // 15, 25, 35, 45...
        }

        function showUpgradeScreen(waveCompleted) {
            upgradeScreenOpen = true;
            rerollCount = 0; // reset reroll count for this wave
            const screen = document.getElementById('upgrade-screen');
            document.getElementById('upgrade-wave-badge').textContent = `Wave ${waveCompleted} Complete`;

            // Wire reroll button (add listener once, replace each call via renderCards)
            const rerollBtn = document.getElementById('reroll-btn');
            rerollBtn.onclick = () => {
                const cost = getRerollCost();
                if(wood < cost) {
                    // Flash red briefly
                    rerollBtn.style.borderColor = '#e74c3c';
                    rerollBtn.style.color = '#e74c3c';
                    setTimeout(() => { rerollBtn.style.borderColor='#8bc34a'; rerollBtn.style.color='#8bc34a'; }, 400);
                    return;
                }
                wood -= cost;
                rerollCount++;
                document.getElementById('mats').innerText = `ü™µ ${wood}`;
                playSound(300, 0.08, 'sine', 0.08);
                renderUpgradeCards();
            };

            screen.classList.add('is-visible');
            if(document.pointerLockElement) document.exitPointerLock();
            renderUpgradeCards();
        }

        function renderUpgradeCards() {
            const cost = getRerollCost();
            const canAfford = wood >= cost;
            const rerollBtn = document.getElementById('reroll-btn');
            document.getElementById('upgrade-wood-display').innerText = `ü™µ ${wood} wood`;
            document.getElementById('reroll-cost-display').innerText = `(${cost} ü™µ)`;
            rerollBtn.style.opacity = canAfford ? '1' : '0.45';
            rerollBtn.style.cursor = canAfford ? 'pointer' : 'default';

            const cards = document.getElementById('upgrade-cards');
            cards.innerHTML = '';
            const options = pickThreeUpgrades();
            options.forEach(({ template, variant }) => {
                const rarity = RARITIES[variant.rarity];
                const card = document.createElement('div');
                card.className = `upgrade-card ${rarity.cssClass}`;
                card.innerHTML = `
                    <div class="upgrade-card__rarity-bar"></div>
                    <span class="upgrade-card__icon">${template.icon}</span>
                    <div class="upgrade-card__rarity-label">${rarity.label}</div>
                    <div class="upgrade-card__name">${template.name}</div>
                    <p class="upgrade-card__desc">${variant.desc}</p>
                    <div class="upgrade-card__bonus">
                        <span class="upgrade-card__bonus-icon">‚ú¶</span>
                        <span>${variant.bonusText}</span>
                    </div>
                    <div class="upgrade-card__applies">${template.applies}</div>
                `;
                card.addEventListener('click', () => {
                    template.apply(variant);
                    upgradeHistory.push({ icon: template.icon, name: template.name, bonus: variant.bonusText, rarity: variant.rarity });
                    updateUpgradeTracker();
                    playSound(600, 0.15, 'sine', 0.12);
                    setTimeout(() => playSound(900, 0.2, 'sine', 0.1), 120);
                    closeUpgradeScreen();
                });
                cards.appendChild(card);
            });
        }

        function closeUpgradeScreen() {
            upgradeScreenOpen = false;
            const screen = document.getElementById('upgrade-screen');
            screen.style.animation = 'upgradeScreenOut 0.25s ease forwards';
            setTimeout(() => {
                screen.classList.remove('is-visible');
                screen.style.animation = '';
                spawnNextWave();
                document.body.requestPointerLock();
            }, 250);
        }

        function updateUpgradeTracker() {
            if (upgradeHistory.length === 0) return;
            const tracker = document.getElementById('upgrade-tracker');
            tracker.classList.add('is-visible');
            const itemsEl = document.getElementById('upgrade-tracker-items');
            itemsEl.innerHTML = '';
            // Show last 4 upgrades
            const recent = upgradeHistory.slice(-4);
            recent.forEach(u => {
                const item = document.createElement('div');
                item.className = 'upgrade-tracker__item';
                item.innerHTML = `<span>${u.icon} ${u.name}</span><span>${u.bonus}</span>`;
                itemsEl.appendChild(item);
            });
        }

        // This will be called after upgrade is selected to spawn enemies
        let pendingWaveSpawn = false;
        let pendingWaveSize = 0;
        function spawnNextWave() {
            for(let i = 0; i < pendingWaveSize; i++) spawnEnemy();
            pendingWaveSpawn = false;
        }

        // Helper to get effective fire rate (lower = faster)
        function getEffectiveFireRate() {
            return fireRate * (1 - playerUpgrades.fireRateBonus);
        }

        // Helper to get effective bow charge max
        function getEffectiveBowChargeMax() {
            return BOW_CHARGE_MAX_MS * (1 - playerUpgrades.bowChargeSpeedBonus);
        }

        // Helper: damage with upgrades applied
        function getDamage(base, type) {
            let bonus = playerUpgrades.allDamageBonus;
            if (type === 'knife')  bonus += playerUpgrades.knifeDamageBonus;
            if (type === 'bow')    bonus += playerUpgrades.bowDamageBonus;
            if (type === 'spear')  bonus += playerUpgrades.spearDamageBonus;
            if (type === 'axe')    bonus += playerUpgrades.axeDamageBonus;
            const powerMult = isPowerUpActive('damage') ? 2.0 : 1.0;
            return (base + bonus) * powerMult;
        }

        // Helper: range bonus in bullet life frames
        function getRangeBonus() {
            return playerUpgrades.rangeBonus;
        }

        // =====================================================================
        // Sound System
        // =====================================================================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }
        
        function shootSound() {
            playSound(300, 0.1, 'square', 0.08);
            setTimeout(() => playSound(150, 0.05, 'square', 0.06), 50);
        }
        function hitSound() { playSound(100, 0.1, 'triangle', 0.12); }
        function damageSound() { playSound(80, 0.2, 'sawtooth', 0.12); }
        function reloadSound() {
            playSound(400, 0.1, 'sine', 0.08);
            setTimeout(() => playSound(600, 0.15, 'sine', 0.08), 150);
        }
        
        let lastFootstepTime = 0;
        function footstepSound(isSprinting) {
            const now = Date.now();
            const footstepInterval = isSprinting ? 300 : 450;
            if(now - lastFootstepTime > footstepInterval) {
                playSound(isSprinting ? 180 : 150, 0.08, 'sine', 0.05);
                lastFootstepTime = now;
            }
        }
        
        // =====================================================================
        // Scene Setup
        // =====================================================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        let dayNightTime = 180;
        const dayNightCycleSpeed = 360 / (180 * 60);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.far = 200;
        sun.shadow.camera.left = -100;
        sun.shadow.camera.right = 100;
        sun.shadow.camera.top = 100;
        sun.shadow.camera.bottom = -100;
        scene.add(sun);
        
        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x4a7c59, 0.3);
        scene.add(hemiLight);
        
        const sunMesh = new THREE.Mesh(
            new THREE.SphereGeometry(15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        sunMesh.visible = false;
        scene.add(sunMesh);
        
        const moonMesh = new THREE.Mesh(
            new THREE.SphereGeometry(18, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xdddddd })
        );
        moonMesh.visible = true;
        scene.add(moonMesh);
        
        const stars = [];
        for(let i = 0; i < 200; i++) {
            const star = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1.0 })
            );
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI / 2.5;
            const radius = 180;
            star.position.x = radius * Math.sin(phi) * Math.cos(theta);
            star.position.y = Math.abs(radius * Math.cos(phi)) + 30;
            star.position.z = radius * Math.sin(phi) * Math.sin(theta);
            star.visible = true;
            scene.add(star);
            stars.push(star);
        }
        
        const clouds = [];
        for(let i = 0; i < 15; i++) {
            const cloud = new THREE.Mesh(
                new THREE.BoxGeometry(Math.random()*8+4, Math.random()*2+1, Math.random()*8+4),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 })
            );
            cloud.position.set(Math.random()*150-75, Math.random()*30+40, Math.random()*150-75);
            scene.add(cloud);
            clouds.push(cloud);
        }
        
        function updateDayNightCycle() {
            if(!gameStarted) return;
            dayNightTime += dayNightCycleSpeed;
            if(dayNightTime > 360) dayNightTime -= 360;
            const timeRadians = (dayNightTime * Math.PI) / 180;
            const sunHeight = Math.sin(timeRadians);
            const sunAngle = timeRadians;
            const sunDistance = 150;
            sunMesh.position.x = sunDistance * Math.cos(sunAngle);
            sunMesh.position.y = Math.abs(sunHeight * sunDistance);
            sunMesh.position.z = sunDistance * Math.sin(sunAngle) * 0.5;
            moonMesh.position.x = -sunMesh.position.x;
            moonMesh.position.y = -sunMesh.position.y;
            moonMesh.position.z = -sunMesh.position.z;
            sun.position.copy(sunMesh.position);
            const b = BIOME_DEFS[currentBiome];
            const wDef = WEATHER_DEFS[currentWeather];
            // Fog range modified by weather
            const effectiveFogFar = b.fogFar * wDef.fogMult;
            scene.fog.near = b.fogNear * wDef.fogMult;
            scene.fog.far  = effectiveFogFar;
            const isDaytime = sunHeight > 0;
            const dayProgress = Math.max(0, sunHeight);
            const nightProgress = Math.max(0, -sunHeight);
            if(isDaytime) {
                const skyDay   = new THREE.Color(b.skyDay);
                const skyDawn  = new THREE.Color(b.dawnTint);
                const skyColor = skyDay.clone().lerp(skyDawn, (1 - dayProgress) * 0.5);
                scene.background = skyColor; scene.fog.color.copy(skyColor);
                ambientLight.intensity = 0.4 + dayProgress * 0.3;
                sun.intensity = 0.8 + dayProgress * 0.4;
                hemiLight.intensity = 0.2 + dayProgress * 0.2;
                stars.forEach(s => s.visible = false);
                moonMesh.visible = false; sunMesh.visible = true;
                const co = wDef.cloudOpacity;
                clouds.forEach(c => c.material.opacity = Math.min(co, 0.5 + dayProgress * 0.3));
            } else {
                const skyNight = new THREE.Color(b.skyNight);
                const skyDay2  = new THREE.Color(b.skyDay);
                const nightSky = skyNight.clone().lerp(skyDay2, (1 - nightProgress));
                scene.background = nightSky; scene.fog.color.copy(nightSky);
                ambientLight.intensity = 0.15 + (1 - nightProgress) * 0.3;
                sun.intensity = 0.3 + (1 - nightProgress) * 0.5;
                hemiLight.intensity = 0.05 + (1 - nightProgress) * 0.2;
                stars.forEach(s => { s.visible = true; s.material.opacity = 0.5 + Math.random() * 0.5; });
                moonMesh.visible = true; sunMesh.visible = false;
                clouds.forEach(c => c.material.opacity = 0.1 + (1 - nightProgress) * 0.3);
            }
        }
        
        function animateClouds() {
            clouds.forEach((cloud, i) => {
                cloud.position.x += Math.sin(Date.now() * 0.0001 + i) * 0.01;
                cloud.position.z += Math.cos(Date.now() * 0.0001 + i) * 0.01;
                if(cloud.position.x > 100) cloud.position.x = -100;
                if(cloud.position.x < -100) cloud.position.x = 100;
                if(cloud.position.z > 100) cloud.position.z = -100;
                if(cloud.position.z < -100) cloud.position.z = 100;
            });
        }

        // =====================================================================
        // BIOME SYSTEM
        // =====================================================================
        const BIOME_DEFS = {
            forest:  { name:'Forest',    icon:'üå≤', floorColor:0x4caf50, floorRough:0.85, skyDay:0x87CEEB, skyNight:0x0a0a1a, dawnTint:0xff9966, fogNear:50,  fogFar:150, hemiGround:0x4a7c59, rockChance:0.30, waterChance:0.15, waterColor:0x2255cc, waterLabel:'Puddles',  iceSlide:false },
            desert:  { name:'Desert',    icon:'üèúÔ∏è', floorColor:0xd4a843, floorRough:0.95, skyDay:0xecc97a, skyNight:0x0d0a06, dawnTint:0xff7700, fogNear:70,  fogFar:200, hemiGround:0xc4982d, rockChance:0.55, waterChance:0.00, waterColor:0x0,        waterLabel:'',         iceSlide:false },
            snow:    { name:'Snowfield', icon:'‚ùÑÔ∏è', floorColor:0xe8eff5, floorRough:0.55, skyDay:0xb8d4e8, skyNight:0x08101a, dawnTint:0xffccaa, fogNear:22,  fogFar:85,  hemiGround:0x8aaabb, rockChance:0.25, waterChance:0.22, waterColor:0xaaccdd, waterLabel:'Ice',      iceSlide:true  }
        };
        const BIOME_SEQUENCE = ['forest','desert','snow'];
        let currentBiome = 'forest';
        const waterZonesList = []; // { x, z, r, ice }

        function getBiomeForWave(wave) {
            return BIOME_SEQUENCE[Math.floor((wave - 1) / 10) % 3];
        }

        function applyBiome(name) {
            const b = BIOME_DEFS[name];
            currentBiome = name;
            scene.fog.near = b.fogNear;
            scene.fog.far  = b.fogFar;
            hemiLight.groundColor.set(b.hemiGround);
            // Update existing chunk floors
            terrainChunks.forEach(chunk => {
                if(chunk.floor) { chunk.floor.material.color.set(b.floorColor); chunk.floor.material.roughness = b.floorRough; }
            });
            document.getElementById('biome-label').innerText = `${b.icon} ${b.name}`;
        }

        // =====================================================================
        // WEATHER SYSTEM
        // =====================================================================
        const WEATHER_DEFS = {
            clear:  { label:'‚òÄÔ∏è Clear',   fogMult:1.0, overlayColor:'',                       overlayOpacity:0,    cloudOpacity:0.6, darkens:false },
            fog:    { label:'üå´Ô∏è Fog',     fogMult:0.3, overlayColor:'rgba(180,180,200,0.12)', overlayOpacity:0.7,  cloudOpacity:0.9, darkens:false },
            rain:   { label:'üåßÔ∏è Rain',    fogMult:0.55, overlayColor:'rgba(30,50,80,0.18)',    overlayOpacity:0.55, cloudOpacity:0.95, darkens:false },
            storm:  { label:'‚õàÔ∏è Storm',   fogMult:0.4, overlayColor:'rgba(10,10,30,0.35)',     overlayOpacity:0.85, cloudOpacity:1.0,  darkens:true  }
        };
        const WEATHER_POOL = ['clear','clear','clear','fog','rain','rain','storm'];
        let currentWeather = 'clear';
        let lastLightningTime = 0;
        let onIce = false;

        function pickWeather() {
            return WEATHER_POOL[Math.floor(Math.random() * WEATHER_POOL.length)];
        }

        function applyWeather(name) {
            currentWeather = name;
            const w = WEATHER_DEFS[name];
            const overlay = document.getElementById('weather-overlay');
            overlay.style.background = w.overlayColor;
            overlay.style.opacity = w.overlayOpacity;
            document.getElementById('weather-label').innerText = w.label;
            rainMesh.visible = (name === 'rain' || name === 'storm');
        }

        // Rain particle system (InstancedMesh for performance)
        const RAIN_COUNT = 400;
        const rainGeom = new THREE.BoxGeometry(0.03, 0.55, 0.03);
        const rainMat  = new THREE.MeshBasicMaterial({ color: 0x88aacc, transparent: true, opacity: 0.38 });
        const rainMesh = new THREE.InstancedMesh(rainGeom, rainMat, RAIN_COUNT);
        rainMesh.visible = false;
        scene.add(rainMesh);
        const _rainPos = [];
        for(let i = 0; i < RAIN_COUNT; i++) _rainPos.push({ x:(Math.random()-0.5)*80, y:Math.random()*32, z:(Math.random()-0.5)*80 });
        const _rainMat4 = new THREE.Matrix4();

        function updateRain() {
            if(!rainMesh.visible) return;
            const px = player.position.x, pz = player.position.z;
            const isStorm = currentWeather === 'storm';
            const fallSpeed = isStorm ? 1.1 : 0.65;
            const windX = isStorm ? 0.04 : 0;
            for(let i = 0; i < RAIN_COUNT; i++) {
                const p = _rainPos[i];
                p.y -= fallSpeed;
                p.x += windX;
                if(p.y < -2 || Math.abs(p.x - px) > 45 || Math.abs(p.z - pz) > 45) {
                    p.y = 28 + Math.random() * 6;
                    p.x = px + (Math.random()-0.5) * 78;
                    p.z = pz + (Math.random()-0.5) * 78;
                }
                _rainMat4.makeTranslation(p.x, p.y, p.z);
                rainMesh.setMatrixAt(i, _rainMat4);
            }
            rainMesh.instanceMatrix.needsUpdate = true;
        }

        function updateStormLightning() {
            if(currentWeather !== 'storm') return;
            const now = Date.now();
            if(now - lastLightningTime > 3500 + Math.random() * 5000) {
                lastLightningTime = now;
                const savedIntensity = ambientLight.intensity;
                ambientLight.intensity = 3.5;
                playSound(55, 0.6, 'sawtooth', 0.28);
                setTimeout(() => { ambientLight.intensity = savedIntensity; }, 80);
                setTimeout(() => { ambientLight.intensity = 3.0; }, 140);
                setTimeout(() => { ambientLight.intensity = savedIntensity; }, 220);
            }
        }

        function showBiomeWeatherBanner(biomeChanged, oldBiome, newBiome, weather) {
            const el = document.createElement('div');
            el.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:300;text-align:center;pointer-events:none;`;
            let html = '';
            if(biomeChanged) {
                const b = BIOME_DEFS[newBiome];
                html += `<div style="color:#fff;font-size:42px;font-family:'Arial Black',sans-serif;text-shadow:2px 2px 12px rgba(0,0,0,0.9);">${b.icon} ${b.name.toUpperCase()}</div>`;
            }
            const w = WEATHER_DEFS[weather];
            html += `<div style="color:rgba(255,255,255,0.8);font-size:22px;margin-top:6px;text-shadow:1px 1px 6px rgba(0,0,0,0.8);">${w.label}</div>`;
            el.innerHTML = html;
            document.body.appendChild(el);
            setTimeout(() => { el.style.transition='opacity 0.6s'; el.style.opacity='0'; setTimeout(()=>el.remove(), 700); }, 2200);
        }

        let collidables = [];
        const enemies = [];
        const bullets = [];
        const trees = [];
        
        const chunkSize = 50;
        const renderDistance = 150;
        const updateThreshold = renderDistance * 0.15;
        const terrainChunks = new Map();
        let lastPlayerChunkPos = { x: 0, z: 0 };
        const SPAWN_CLEAR_RADIUS = 6;
        const TREE_COLLISION_RADIUS = 0.9;
        
        function getChunkKey(x, z) { return `${x},${z}`; }
        function getChunkCoords(wx, wz) { return { x: Math.floor(wx / chunkSize), z: Math.floor(wz / chunkSize) }; }
        
        function createTerrainChunk(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            if(terrainChunks.has(chunkKey)) return;
            const b = BIOME_DEFS[currentBiome];
            const chunk = { key: chunkKey, x: chunkX, z: chunkZ, trees: [], obstacles: [], waterZones: [], floor: null };

            // Floor
            const floorSegment = new THREE.Mesh(
                new THREE.PlaneGeometry(chunkSize, chunkSize),
                new THREE.MeshStandardMaterial({ color: b.floorColor, roughness: b.floorRough, metalness: 0.1 })
            );
            floorSegment.rotation.x = -Math.PI / 2;
            floorSegment.position.set(chunkX * chunkSize + chunkSize/2, 0, chunkZ * chunkSize + chunkSize/2);
            floorSegment.receiveShadow = true;
            scene.add(floorSegment);
            chunk.floor = floorSegment;

            const seed = chunkX * 1000 + chunkZ;
            const pr = (n) => Math.abs(Math.sin(seed * 127.1 + n * 311.7) * 43758.5453) % 1;

            // Trees / cacti / snow-trees
            const treeCount = 3 + (Math.abs(seed) % 4);
            for(let i = 0; i < treeCount; i++) {
                const tx = chunkX * chunkSize + pr(i * 2) * chunkSize;
                const tz = chunkZ * chunkSize + pr(i * 2 + 1) * chunkSize;
                if(Math.sqrt(tx*tx + tz*tz) < SPAWN_CLEAR_RADIUS) continue;
                chunk.trees.push(createTreeAt(tx, tz));
            }

            // Rocks / boulders (biome-driven density + include tall cliff rocks)
            if(pr(50) < b.rockChance) {
                const rockCount = 1 + Math.floor(pr(51) * 3);
                for(let i = 0; i < rockCount; i++) {
                    const rx = chunkX * chunkSize + pr(60 + i*3) * chunkSize;
                    const rz = chunkZ * chunkSize + pr(61 + i*3) * chunkSize;
                    if(Math.sqrt(rx*rx + rz*rz) < SPAWN_CLEAR_RADIUS + 2) continue;
                    const isCliff = (pr(62 + i*3) < 0.25); // 25% chance of tall cliff rock
                    createRockAt(rx, rz, isCliff, chunk);
                }
            }

            // Water / ice patches
            if(b.waterChance > 0 && pr(80) < b.waterChance) {
                const wx = chunkX * chunkSize + pr(81) * chunkSize;
                const wz = chunkZ * chunkSize + pr(82) * chunkSize;
                if(Math.sqrt(wx*wx + wz*wz) >= SPAWN_CLEAR_RADIUS + 3) {
                    createWaterPatch(wx, wz, b, chunk);
                }
            }

            terrainChunks.set(chunkKey, chunk);
        }

        function createTreeAt(x, z) {
            const tree = new THREE.Group();
            if(currentBiome === 'desert') {
                // Cactus: tall green cylinder body + arm stubs
                const bodyH = 2.8 + Math.random() * 1.4;
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.28, 0.35, bodyH, 7),
                    new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
                );
                body.position.y = bodyH / 2;
                body.castShadow = true;
                tree.add(body);
                // Arms
                const armH = 0.9; const armY = bodyH * 0.55;
                [-1, 1].forEach(side => {
                    if(Math.random() > 0.35) {
                        const arm = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.16, 0.2, armH, 6),
                            new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
                        );
                        arm.rotation.z = side * Math.PI / 2.5;
                        arm.position.set(side * 0.55, armY, 0);
                        arm.castShadow = true;
                        tree.add(arm);
                    }
                });
                // Add trunk as collidable
                const col = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, bodyH, 6), body.material);
                col.position.y = bodyH / 2;
                col.userData.isTree = true; col.visible = false;
                tree.add(col);
                collidables.push(col);
            } else if(currentBiome === 'snow') {
                // Snow-capped pine
                const trunk = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 2.8, 0.7),
                    new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.9 })
                );
                trunk.position.y = 1.4; trunk.castShadow = true;
                tree.add(trunk);
                // Layered snow foliage
                [[3.0, 2.6, 0.75], [2.2, 2.0, 0.55], [1.4, 1.4, 0.35]].forEach(([w, h, yOff]) => {
                    const layer = new THREE.Mesh(
                        new THREE.ConeGeometry(w * 0.5, h, 7),
                        new THREE.MeshStandardMaterial({ color: 0xeef4ff, roughness: 0.6 })
                    );
                    layer.position.y = 2.8 + yOff * 3.5; layer.castShadow = true;
                    tree.add(layer);
                    // Green under-layer
                    const green = new THREE.Mesh(
                        new THREE.ConeGeometry(w * 0.42, h * 0.85, 7),
                        new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.8 })
                    );
                    green.position.y = 2.8 + yOff * 3.5 - 0.15;
                    tree.add(green);
                });
                trunk.userData.isTree = true;
                collidables.push(trunk);
            } else {
                // Forest: original tree
                const trunk = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 3, 0.8),
                    new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9, metalness: 0.1 })
                );
                trunk.position.y = 1.5; trunk.castShadow = true; trunk.receiveShadow = true;
                const leaves = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 2.5, 2.5),
                    new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
                );
                leaves.position.y = 3.5; leaves.castShadow = true;
                tree.add(trunk, leaves);
                trunk.userData.isTree = true;
                collidables.push(trunk);
            }
            tree.position.set(x, 0, z);
            scene.add(tree);
            trees.push(tree);
            return tree;
        }

        function createRockAt(x, z, isCliff, chunk) {
            const rockColors = [0x888888, 0x777766, 0x997755, 0x666677];
            const col = rockColors[Math.floor(Math.random() * rockColors.length)];
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.9, metalness: 0.15 });

            const group = new THREE.Group();
            group.position.set(x, 0, z);

            if(isCliff) {
                // Tall cliff pillar ‚Äî 2-3 stacked irregular boxes
                const layers = 2 + Math.floor(Math.random() * 2);
                let yOff = 0;
                for(let l = 0; l < layers; l++) {
                    const w = 1.4 - l * 0.25 + Math.random() * 0.4;
                    const h = 1.6 + Math.random() * 1.2;
                    const rock = new THREE.Mesh(new THREE.BoxGeometry(w, h, w + Math.random() * 0.5), mat);
                    rock.position.set(Math.random() * 0.3 - 0.15, yOff + h/2, Math.random() * 0.3 - 0.15);
                    rock.rotation.y = Math.random() * 0.5;
                    rock.castShadow = true; rock.receiveShadow = true;
                    group.add(rock);
                    collidables.push(rock);
                    chunk.obstacles.push(rock);
                    yOff += h;
                }
            } else {
                // Scattered smaller boulder(s)
                const count = 1 + Math.floor(Math.random() * 3);
                for(let r = 0; r < count; r++) {
                    const sz = 0.5 + Math.random() * 1.1;
                    const rock = new THREE.Mesh(new THREE.BoxGeometry(sz, sz * 0.65, sz * 0.85), mat);
                    rock.position.set(Math.random() * 2 - 1, sz * 0.3, Math.random() * 2 - 1);
                    rock.rotation.set(Math.random()*0.4, Math.random()*Math.PI, Math.random()*0.3);
                    rock.castShadow = true; rock.receiveShadow = true;
                    group.add(rock);
                    collidables.push(rock);
                    chunk.obstacles.push(rock);
                }
            }
            scene.add(group);
            chunk.obstacles.push(group); // track group for scene removal
        }

        function createWaterPatch(x, z, biomeDef, chunk) {
            const r = 2.5 + Math.random() * 3;
            const segs = 10;
            const waterMesh = new THREE.Mesh(
                new THREE.CircleGeometry(r, segs),
                new THREE.MeshStandardMaterial({
                    color: biomeDef.waterColor,
                    roughness: biomeDef.iceSlide ? 0.05 : 0.15,
                    metalness: biomeDef.iceSlide ? 0.5 : 0.4,
                    transparent: true, opacity: 0.75
                })
            );
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.position.set(x, 0.01, z);
            waterMesh.receiveShadow = true;
            scene.add(waterMesh);
            chunk.obstacles.push(waterMesh);
            const zone = { x, z, r, ice: biomeDef.iceSlide };
            waterZonesList.push(zone);
            chunk.waterZones.push(zone);
        }
        
        function removeTerrainChunk(key) {
            const chunk = terrainChunks.get(key);
            if(!chunk) return;
            if(chunk.floor) { scene.remove(chunk.floor); chunk.floor.geometry.dispose(); chunk.floor.material.dispose(); }
            chunk.trees.forEach(tree => {
                scene.remove(tree);
                tree.children.forEach(child => {
                    child.geometry.dispose(); child.material.dispose();
                    const idx = collidables.indexOf(child);
                    if(idx > -1) collidables.splice(idx, 1);
                });
                const ti = trees.indexOf(tree);
                if(ti > -1) trees.splice(ti, 1);
            });
            // Remove rock/cliff obstacles
            chunk.obstacles.forEach(obj => {
                scene.remove(obj);
                if(obj.geometry) { obj.geometry.dispose(); if(obj.material) obj.material.dispose(); }
                const ci = collidables.indexOf(obj);
                if(ci > -1) collidables.splice(ci, 1);
            });
            // Remove water zones from global list
            chunk.waterZones.forEach(zone => {
                const wi = waterZonesList.indexOf(zone);
                if(wi > -1) waterZonesList.splice(wi, 1);
            });
            terrainChunks.delete(key);
        }
        
        function updateTerrain() {
            const pp = player.position;
            const pc = getChunkCoords(pp.x, pp.z);
            const dist = Math.sqrt(
                Math.pow((pc.x - lastPlayerChunkPos.x) * chunkSize, 2) +
                Math.pow((pc.z - lastPlayerChunkPos.z) * chunkSize, 2)
            );
            if(dist < updateThreshold && terrainChunks.size > 0) return;
            lastPlayerChunkPos = { x: pc.x, z: pc.z };
            const cr = Math.ceil(renderDistance / chunkSize);
            const needed = new Set();
            for(let cx = pc.x - cr; cx <= pc.x + cr; cx++) {
                for(let cz = pc.z - cr; cz <= pc.z + cr; cz++) {
                    const ccx = cx * chunkSize + chunkSize/2, ccz = cz * chunkSize + chunkSize/2;
                    if(Math.sqrt(Math.pow(ccx-pp.x,2)+Math.pow(ccz-pp.z,2)) <= renderDistance) {
                        const k = getChunkKey(cx, cz);
                        needed.add(k);
                        createTerrainChunk(cx, cz);
                    }
                }
            }
            const toRemove = [];
            terrainChunks.forEach((_, k) => { if(!needed.has(k)) toRemove.push(k); });
            toRemove.forEach(k => removeTerrainChunk(k));
        }

        function createHealthBar(isWall = false) {
            const container = document.createElement('div');
            container.className = 'healthbar';
            const fill = document.createElement('div');
            fill.className = 'healthbar__fill ' + (isWall ? 'healthbar__fill--wall' : 'healthbar__fill--enemy');
            fill.style.width = '100%';
            container.appendChild(fill);
            document.body.appendChild(container);
            return { container, fill };
        }

        // Enemy projectiles (spit blobs from spitters)
        const enemyProjectiles = [];

        // Build a capybara mesh with given body/head colors and scale
        function buildCapybaraMesh(bodyColor, snoutColor, scale) {
            const character = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.8, metalness: 0.1 });
            const snoutMat = new THREE.MeshStandardMaterial({ color: snoutColor, roughness: 0.9, metalness: 0.1 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.7,1.8), bodyMat);
            body.position.y = 0.5; body.castShadow = true; character.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.6,0.7), bodyMat);
            head.position.set(0,0.65,1.0); head.castShadow = true; character.add(head);
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.3), snoutMat);
            snout.position.set(0,0.6,1.35); character.add(snout);
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshBasicMaterial({color:0x000000}));
            eyeL.position.set(-0.2,0.75,1.15); character.add(eyeL);
            const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshBasicMaterial({color:0x000000}));
            eyeR.position.set(0.2,0.75,1.15); character.add(eyeR);
            const earMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.8 });
            const earL = new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8), earMat);
            earL.position.set(-0.3,0.95,0.9); character.add(earL);
            const earR = new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8), earMat);
            earR.position.set(0.3,0.95,0.9); character.add(earR);
            const legMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.8 });
            const fll = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            fll.position.set(-0.4,0.25,0.6); fll.castShadow=true; character.add(fll); character.userData.frontLegLeft=fll;
            const flr = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            flr.position.set(0.4,0.25,0.6); flr.castShadow=true; character.add(flr); character.userData.frontLegRight=flr;
            const bll = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            bll.position.set(-0.4,0.25,-0.5); bll.castShadow=true; character.add(bll); character.userData.backLegLeft=bll;
            const blr = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            blr.position.set(0.4,0.25,-0.5); blr.castShadow=true; character.add(blr); character.userData.backLegRight=blr;
            character.scale.setScalar(scale);
            character.castShadow = true; character.receiveShadow = true;
            character.userData.animTime = 0; character.userData.vY = 0;
            character.userData.lastAttack = 0;
            return character;
        }

        // ENEMY TYPE DEFINITIONS
        // Each returns a fully configured Three.Group with userData stats
        function createScout() {
            const e = buildCapybaraMesh(0xa0522d, 0x7a3b10, 0.65); // small, tan
            e.userData.enemyType = 'scout';
            e.userData.health = 35; e.userData.maxHealth = 35;
            e.userData.speed = 0.10;
            e.userData.attackRange = 1.0; e.userData.attackCooldown = 800;
            e.userData.attackDamage = 8;
            e.userData.jumpCooldown = 4000; e.userData.lastJump = 0;
            return e;
        }

        function createNormal() {
            const e = buildCapybaraMesh(0x8b6f47, 0x654321, 1.0); // standard
            e.userData.enemyType = 'normal';
            e.userData.health = 100; e.userData.maxHealth = 100;
            e.userData.speed = 0.04;
            e.userData.attackRange = 1.2; e.userData.attackCooldown = 1000;
            e.userData.attackDamage = 20;
            return e;
        }

        function createTank() {
            const e = buildCapybaraMesh(0x4a3728, 0x2e1f0f, 1.75); // huge, dark brown
            // Crown/mark to distinguish
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xcc3300, roughness: 0.5 });
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(1.25,0.12,0.12), crownMat);
            stripe.position.set(0,0.82,0); e.add(stripe);
            e.userData.enemyType = 'tank';
            e.userData.health = 335; e.userData.maxHealth = 335;
            e.userData.speed = 0.022;
            e.userData.attackRange = 2.0; e.userData.attackCooldown = 1400;
            e.userData.attackDamage = 35;
            return e;
        }

        function createExploder() {
            const e = buildCapybaraMesh(0xcc6600, 0xff4400, 0.9); // orange tint
            // Glowing belly indicator
            const belly = new THREE.Mesh(
                new THREE.SphereGeometry(0.35,8,8),
                new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff3300, emissiveIntensity: 0.8, roughness: 0.4 })
            );
            belly.position.set(0, 0.45, 0.2); e.add(belly);
            e.userData.enemyType = 'exploder';
            e.userData.health = 60; e.userData.maxHealth = 60;
            e.userData.speed = 0.07;
            e.userData.attackRange = 1.8; e.userData.attackCooldown = 99999; // explodes once
            e.userData.attackDamage = 0; // handled by explosion
            e.userData.exploded = false;
            e.userData.belly = belly;
            return e;
        }

        function createSpitter() {
            const e = buildCapybaraMesh(0x557744, 0x334422, 1.0); // green-tinged
            // Green cheek puffs
            const puffMat = new THREE.MeshStandardMaterial({ color: 0x44bb44, emissive: 0x227722, emissiveIntensity: 0.4 });
            const pL = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), puffMat);
            pL.position.set(-0.45,0.68,1.0); e.add(pL);
            const pR = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), puffMat);
            pR.position.set(0.45,0.68,1.0); e.add(pR);
            e.userData.enemyType = 'spitter';
            e.userData.health = 80; e.userData.maxHealth = 80;
            e.userData.speed = 0.03;
            e.userData.attackRange = 1.2; e.userData.attackCooldown = 1200;
            e.userData.attackDamage = 10;
            e.userData.spitRange = 18;     // max spit distance
            e.userData.spitCooldown = 2800;
            e.userData.lastSpit = 0;
            e.userData.preferredDistance = 12; // tries to stay away
            return e;
        }

        function createAlphaBoss() {
            const e = buildCapybaraMesh(0x1a0a00, 0x3d0000, 2.2); // huge, near-black
            // Red crown spikes
            const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0xaa0000, emissiveIntensity: 0.6 });
            for(let i = -1; i <= 1; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 6), spikeMat);
                spike.position.set(i * 0.28, 1.05, 0); e.add(spike);
            }
            // Glowing red eyes
            const redEyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            e.children.forEach(c => {
                if(c.geometry && c.geometry.type === 'SphereGeometry' && Math.abs(c.position.y - 0.75) < 0.1) {
                    c.material = redEyeMat;
                }
            });
            e.userData.enemyType = 'boss';
            e.userData.health = 1500; e.userData.maxHealth = 1500;
            e.userData.speed = 0.035;
            e.userData.attackRange = 2.5; e.userData.attackCooldown = 900;
            e.userData.attackDamage = 40;
            e.userData.spitRange = 25;
            e.userData.spitCooldown = 1800;
            e.userData.lastSpit = 0;
            e.userData.jumpCooldown = 5000; e.userData.lastJump = 0;
            e.userData.isBoss = true;
            return e;
        }

        // Pick enemy type based on current wave, returns a configured group
        function createEnemyForWave() {
            // Boss spawns on waves 5, 10, 15...
            if(currentWave % 5 === 0 && currentWave > 0) {
                // Only one boss per wave ‚Äî tracked via flag
                if(!window._bossSpawnedThisWave) {
                    window._bossSpawnedThisWave = true;
                    return createAlphaBoss();
                }
            }
            const roll = Math.random();
            const w = currentWave;
            if(w >= 10 && roll < 0.12) return createSpitter();
            if(w >= 8  && roll < 0.22) return createExploder();
            if(w >= 4  && roll < 0.30) return createTank();
            if(w >= 2  && roll < 0.45) return createScout();
            return createNormal();
        }

        function fireEnemySpit(en) {
            const spitGroup = new THREE.Group();
            const blob = new THREE.Mesh(
                new THREE.SphereGeometry(0.18, 7, 7),
                new THREE.MeshStandardMaterial({ color: 0x44dd44, emissive: 0x22aa22, emissiveIntensity: 0.7, roughness: 0.6 })
            );
            spitGroup.add(blob);
            const worldPos = new THREE.Vector3();
            en.getWorldPosition(worldPos);
            worldPos.y += 0.7 * en.scale.y;
            spitGroup.position.copy(worldPos);
            const dir = new THREE.Vector3().subVectors(player.position, worldPos);
            dir.y += 0.15; // slight arc
            dir.normalize();
            spitGroup.userData.velocity = dir.multiplyScalar(0.9);
            spitGroup.userData.gravity = -0.003;
            spitGroup.userData.life = 180;
            spitGroup.userData.damage = en.userData.isBoss ? 18 : 10;
            scene.add(spitGroup);
            enemyProjectiles.push(spitGroup);
            playSound(220, 0.12, 'sine', 0.07);
        }

        function triggerExplosion(en) {
            if(en.userData.exploded) return;
            en.userData.exploded = true;
            // Visual flash
            en.children.forEach(c => {
                if(c.material) c.material = new THREE.MeshBasicMaterial({ color: 0xff6600 });
            });
            playSound(80, 0.4, 'sawtooth', 0.18);
            setTimeout(() => playSound(120, 0.3, 'square', 0.12), 80);
            // Area damage to player
            const dist = player.position.distanceTo(en.position);
            const blastRadius = 4.5;
            if(dist < blastRadius && !isPowerUpActive('invincible')) {
                const dmg = Math.round(60 * (1 - dist / blastRadius));
                health = Math.max(0, health - dmg);
                document.getElementById('health-bar').style.width = (health/maxPlayerHealth*100) + '%';
                document.getElementById('health-bar').style.width = health + '%';
                damageSound();
                if(health <= 0) {
                    showGameOver(currentWave - 1, killCount);
                }
            }
            // Show explosion ring indicator
            const expEl = document.createElement('div');
            expEl.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff6600;font-size:38px;font-weight:900;text-shadow:2px 2px 8px #000;pointer-events:none;z-index:200;`;
            expEl.innerText = 'üí• BOOM!';
            document.body.appendChild(expEl);
            setTimeout(() => expEl.remove(), 700);
            // Remove enemy
            setTimeout(() => {
                scene.remove(en);
                if(en.userData.healthBarElement) en.userData.healthBarElement.remove();
                const idx = enemies.indexOf(en);
                if(idx > -1) enemies.splice(idx, 1);
            }, 120);
        }

        function createHumanoid(color) {
            const character = new THREE.Group();
            if(color === 0xff4444) {
                // Legacy call ‚Äî return a normal capybara
                return createNormal();
            } else {
                // PLAYER
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), new THREE.MeshStandardMaterial({color:0xffdbac,roughness:0.7,metalness:0.1}));
                head.position.y = 1.5; head.castShadow = true; character.add(head);
                const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.7,0.3), new THREE.MeshStandardMaterial({color,roughness:0.6,metalness:0.2}));
                torso.position.y = 0.9; torso.castShadow = true; character.add(torso);
                const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.6,0.15), new THREE.MeshStandardMaterial({color,roughness:0.6,metalness:0.2}));
                lArm.position.set(-0.35,0.9,0); lArm.castShadow=true; character.add(lArm); character.userData.leftArm=lArm;
                const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.6,0.15), new THREE.MeshStandardMaterial({color,roughness:0.6,metalness:0.2}));
                rArm.position.set(0.35,0.9,0); rArm.castShadow=true; character.add(rArm); character.userData.rightArm=rArm;
                const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.2), new THREE.MeshStandardMaterial({color:0x2c3e50,roughness:0.7,metalness:0.3}));
                lLeg.position.set(-0.15,0.35,0); lLeg.castShadow=true; character.add(lLeg); character.userData.leftLeg=lLeg;
                const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.2), new THREE.MeshStandardMaterial({color:0x2c3e50,roughness:0.7,metalness:0.3}));
                rLeg.position.set(0.15,0.35,0); rLeg.castShadow=true; character.add(rLeg); character.userData.rightLeg=rLeg;
                character.userData.animTime = 0; character.userData.vY = 0;
            }
            character.castShadow = true; character.receiveShadow = true;
            return character;
        }

        const player = createHumanoid(0x2196f3);
        scene.add(player);
        
        // Held weapons setup (same as original)
        const heldKnife = new THREE.Group();
        const heldBlade = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.3,0.015), new THREE.MeshStandardMaterial({color:0xc0c0c0,metalness:0.8,roughness:0.2}));
        heldBlade.position.y = 0.12; heldKnife.add(heldBlade);
        const heldHandle = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.025), new THREE.MeshStandardMaterial({color:0x3d2817,roughness:0.7,metalness:0.1}));
        heldHandle.position.y = -0.06; heldKnife.add(heldHandle);
        heldKnife.position.set(0,-0.35,0); heldKnife.rotation.x = -Math.PI/2; heldKnife.scale.setScalar(0.8);
        player.userData.rightArm.add(heldKnife); player.userData.heldKnife = heldKnife;
        
        const heldBow = new THREE.Group();
        const bowMat = new THREE.MeshStandardMaterial({color:0x5d4037,roughness:0.8,metalness:0.1});
        heldBow.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.05), bowMat)));
        const bl1 = new THREE.Mesh(new THREE.BoxGeometry(0.03,0.35,0.04), bowMat);
        bl1.position.set(0,0.3,0); bl1.rotation.z=-0.4; heldBow.add(bl1);
        const bl2 = new THREE.Mesh(new THREE.BoxGeometry(0.03,0.35,0.04), bowMat);
        bl2.position.set(0,-0.3,0); bl2.rotation.z=0.4; heldBow.add(bl2);
        const bs = new THREE.Mesh(new THREE.BoxGeometry(0.008,0.55,0.002), new THREE.MeshStandardMaterial({color:0x888888,roughness:0.5}));
        bs.position.set(0,0,0.025); heldBow.add(bs);
        heldBow.position.set(0,-0.35,0); heldBow.rotation.x=Math.PI/3; heldBow.rotation.z=-Math.PI/8;
        heldBow.visible=false; player.userData.rightArm.add(heldBow); player.userData.heldBow=heldBow;
        
        const heldSpear = new THREE.Group();
        const spearShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.022,0.85,8), new THREE.MeshStandardMaterial({color:0x6b4423,roughness:0.7,metalness:0.1}));
        spearShaft.position.y=0.35; heldSpear.add(spearShaft);
        const spearHead = new THREE.Mesh(new THREE.ConeGeometry(0.025,0.25,8), new THREE.MeshStandardMaterial({color:0x909090,metalness:0.7,roughness:0.25}));
        spearHead.position.y=0.78; heldSpear.add(spearHead);
        const spearCollar = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.06,6), new THREE.MeshStandardMaterial({color:0x706050,metalness:0.5,roughness:0.4}));
        spearCollar.position.y=0.66; heldSpear.add(spearCollar);
        heldSpear.position.set(0,-0.35,0); heldSpear.rotation.x=-Math.PI/2; heldSpear.rotation.z=Math.PI/12; heldSpear.scale.setScalar(0.9);
        heldSpear.visible=false; player.userData.rightArm.add(heldSpear); player.userData.heldSpear=heldSpear;
        
        const heldAxe = new THREE.Group();
        const axeHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.03,0.6,6), new THREE.MeshStandardMaterial({color:0x4a3728,roughness:0.8,metalness:0.1}));
        axeHandle.position.y=0.15; heldAxe.add(axeHandle);
        const axeHeadBody = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.12,0.05), new THREE.MeshStandardMaterial({color:0x606060,metalness:0.6,roughness:0.35}));
        axeHeadBody.position.set(0,0.55,0); heldAxe.add(axeHeadBody);
        const axeBlade = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.18,0.03), new THREE.MeshStandardMaterial({color:0x808080,metalness:0.7,roughness:0.25}));
        axeBlade.position.set(0.08,0.55,0); axeBlade.rotation.z=-0.2; heldAxe.add(axeBlade);
        heldAxe.position.set(0,-0.35,0); heldAxe.rotation.x=-Math.PI/2.5; heldAxe.rotation.z=Math.PI/6;
        heldAxe.visible=false; player.userData.rightArm.add(heldAxe); player.userData.heldAxe=heldAxe;
        
        const camPivot = new THREE.Group();
        camPivot.position.y = 1.6;
        player.add(camPivot);
        camPivot.add(camera);
        camera.position.set(0, 0.5, 4);

        let wood = 30;
        let health = 100;
        let activeSlot = 1;
        let lastDamageTime = 0;
        let gameStarted = false;
        let currentAmmo = 30;
        let reserveAmmo = 90;
        let maxMagSize = 30;
        let isReloading = false;
        let currentArrows = 20;
        let maxArrows = 50;
        let currentSpears = 5;
        let maxSpears = 10;
        let lastAxeSwing = 0;
        let lastSpearThrow = 0;
        const axeCooldown = 300;
        let killCount = 0;
        let currentWave = 1;
        let enemiesInWave = 5;
        let enemiesKilledThisWave = 0;
        let lastShotTime = 0;
        const fireRate = 142;
        let isMouseDown = false;
        let bowChargeStart = 0;
        let bowCharging = false;
        const BOW_CHARGE_MAX_MS = 1000;
        const BOW_RAPID_DAMAGE = 22;
        const BOW_MAX_DAMAGE = 85;
        
        // Apply persistent skill tree bonuses from previous runs
        applyAllSkillBonuses();
        updateTerrain();

        function spawnEnemy() {
            const e = createEnemyForWave();
            e.position.set(Math.random()*60-30, 0, Math.random()*60-30);
            scene.add(e);
            const hBar = createHealthBar(false);
            e.userData.healthBarElement = hBar.container;
            e.userData.healthBarFill = hBar.fill;
            // Scale health/speed with wave (bosses get extra scaling)
            const wm = 1 + (currentWave - 1) * 0.15;
            e.userData.health = Math.floor(e.userData.health * wm);
            e.userData.maxHealth = Math.floor(e.userData.maxHealth * wm);
            e.userData.speed = e.userData.speed + (currentWave - 1) * 0.002;
            enemies.push(e);
        }
        
        function spawnEnemyNearPlayer() {
            const e = createEnemyForWave();
            const angle = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 70;
            e.position.set(player.position.x + Math.cos(angle)*dist, 0, player.position.z + Math.sin(angle)*dist);
            scene.add(e);
            const hBar = createHealthBar(false);
            e.userData.healthBarElement = hBar.container;
            e.userData.healthBarFill = hBar.fill;
            const wm = 1 + (currentWave - 1) * 0.15;
            e.userData.health = Math.floor(e.userData.health * wm);
            e.userData.maxHealth = Math.floor(e.userData.maxHealth * wm);
            e.userData.speed = e.userData.speed + (currentWave - 1) * 0.002;
            enemies.push(e);
        }
        
        for(let i=0; i<enemiesInWave; i++) spawnEnemy();

        function useWeapon() {
            if (activeSlot === 1) shootKnife();
            else if (activeSlot === 3) throwSpear();
            else if (activeSlot === 4) swingAxe();
        }
        
        function shootKnife() {
            const now = Date.now();
            const effectiveFireRate = getEffectiveFireRate();
            if(currentAmmo === 0 || isReloading || (now - lastShotTime < effectiveFireRate)) return;
            lastShotTime = now;
            currentAmmo--;
            updateAmmoDisplay();
            shootSound();
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'knife';
            const knifeGroup = new THREE.Group();
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.4,0.02), new THREE.MeshStandardMaterial({color:0xc0c0c0,metalness:0.8,roughness:0.2}));
            blade.position.y = 0.15; knifeGroup.add(blade);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.15,0.03), new THREE.MeshStandardMaterial({color:0x3d2817,roughness:0.7,metalness:0.1}));
            handle.position.y = -0.1; knifeGroup.add(handle);
            knifeGroup.position.copy(player.position).add(new THREE.Vector3(0,1.5,0));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            knifeGroup.lookAt(knifeGroup.position.clone().add(dir));
            knifeGroup.userData.velocity = dir.multiplyScalar(1.2);
            knifeGroup.userData.life = 100 + getRangeBonus();
            knifeGroup.userData.rotationSpeed = 0.3;
            knifeGroup.userData.damage = getDamage(34, 'knife');
            knifeGroup.userData.gravity = 0;
            scene.add(knifeGroup);
            bullets.push(knifeGroup);
            if(currentAmmo === 0 && reserveAmmo > 0) setTimeout(() => reload(), 500);
        }
        
        function startBowCharge() {
            if (currentArrows <= 0 || bowCharging) return;
            bowCharging = true;
            bowChargeStart = Date.now();
        }
        
        function releaseBow() {
            if (!bowCharging || currentArrows <= 0) return;
            const now = Date.now();
            const holdTime = now - bowChargeStart;
            bowCharging = false;
            const effectiveChargeMax = getEffectiveBowChargeMax();
            const rapidThreshold = 200;
            const baseDmg = getDamage(BOW_RAPID_DAMAGE, 'bow');
            const maxDmg = getDamage(BOW_MAX_DAMAGE, 'bow');
            const damage = (holdTime < rapidThreshold)
                ? baseDmg
                : baseDmg + (Math.min(holdTime, effectiveChargeMax) / effectiveChargeMax) * (maxDmg - baseDmg);
            lastShotTime = now;
            currentArrows--;
            updateAmmoDisplay();
            playSound(250, holdTime < rapidThreshold ? 0.08 : 0.15, 'sine', 0.1);
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'bow';
            const arrowGroup = new THREE.Group();
            const arrowShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.02,0.55,8), new THREE.MeshStandardMaterial({color:0x5d4037,roughness:0.6,metalness:0.1}));
            arrowShaft.position.y = 0.18; arrowShaft.castShadow=true; arrowGroup.add(arrowShaft);
            const arrowHead = new THREE.Mesh(new THREE.ConeGeometry(0.025,0.15,8), new THREE.MeshStandardMaterial({color:0x909090,metalness:0.6,roughness:0.25}));
            arrowHead.position.y = 0.48; arrowHead.castShadow=true; arrowGroup.add(arrowHead);
            const arrowFletching = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.08,0.01), new THREE.MeshStandardMaterial({color:0xc62828,roughness:0.5}));
            arrowFletching.position.y = -0.1; arrowFletching.rotation.z = Math.PI/4; arrowGroup.add(arrowFletching);
            arrowGroup.position.copy(player.position).add(new THREE.Vector3(0,1.5,0));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion())).normalize();
            arrowGroup.lookAt(arrowGroup.position.clone().add(dir.clone()));
            arrowGroup.rotation.x += Math.PI/2;
            const speed = (holdTime < rapidThreshold) ? 0.7 : 0.7 + (Math.min(holdTime, effectiveChargeMax) / effectiveChargeMax) * 0.4;
            arrowGroup.userData.velocity = dir.clone().multiplyScalar(speed);
            arrowGroup.userData.life = 120 + getRangeBonus();
            arrowGroup.userData.rotationSpeed = 0;
            arrowGroup.userData.damage = Math.round(damage);
            arrowGroup.userData.gravity = -0.015;
            scene.add(arrowGroup);
            bullets.push(arrowGroup);
        }
        
        function throwSpear() {
            const now = Date.now();
            const spearFireRate = 600;
            if(currentSpears <= 0 || (now - lastSpearThrow < spearFireRate)) return;
            lastSpearThrow = now;
            currentSpears--;
            updateAmmoDisplay();
            playSound(180, 0.12, 'square', 0.1);
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'spear';
            const spearGroup = new THREE.Group();
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.025,0.7,8), new THREE.MeshStandardMaterial({color:0x6b4423,roughness:0.7}));
            shaft.position.y = 0.2; spearGroup.add(shaft);
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.035,0.25,8), new THREE.MeshStandardMaterial({color:0x909090,metalness:0.6,roughness:0.3}));
            head.position.y = 0.58; spearGroup.add(head);
            spearGroup.position.copy(player.position).add(new THREE.Vector3(0,1.5,0));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            spearGroup.lookAt(spearGroup.position.clone().add(dir));
            spearGroup.userData.velocity = dir.multiplyScalar(1.1);
            spearGroup.userData.life = 100 + getRangeBonus();
            spearGroup.userData.rotationSpeed = 0.2;
            spearGroup.userData.damage = getDamage(70, 'spear');
            spearGroup.userData.gravity = 0;
            scene.add(spearGroup);
            bullets.push(spearGroup);
        }
        
        function swingAxe() {
            const now = Date.now();
            const effectiveCooldown = axeCooldown * (1 - playerUpgrades.fireRateBonus);
            if (now - lastAxeSwing < effectiveCooldown) return;
            lastAxeSwing = now;
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'axe';
            playSound(120, 0.15, 'sawtooth', 0.12);
            setTimeout(() => {
                const range = 3.5;
                const lookDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
                const playerPos = new THREE.Vector3().setFromMatrixPosition(player.matrixWorld);
                playerPos.y += 1;
                let closest = null, closestDist = range;
                enemies.forEach(en => {
                    const enPos = new THREE.Vector3().setFromMatrixPosition(en.matrixWorld);
                    const toEn = new THREE.Vector3().subVectors(enPos, playerPos).normalize();
                    const dist = playerPos.distanceTo(enPos);
                    if (dist < closestDist && lookDir.dot(toEn) > 0.5) { closestDist=dist; closest=en; }
                });
                if (closest) {
                    const dmg = getDamage(95, 'axe');
                    closest.userData.health -= dmg;
                    closest.userData.healthBarFill.style.width = (closest.userData.health / closest.userData.maxHealth * 100) + '%';
                    hitSound();
                    if (closest.userData.health <= 0) killEnemy(closest);
                }
                harvest();
            }, 90);
        }

        function killEnemy(en) {
            const enPos = en.position.clone();
            scene.remove(en);
            en.userData.healthBarElement.remove();
            const eIdx = enemies.indexOf(en);
            if (eIdx > -1) enemies.splice(eIdx, 1);
            killCount++;
            enemiesKilledThisWave++;
            document.getElementById('kill-counter').innerText = `ELIMINATIONS: ${killCount}`;
            document.getElementById('enemies-remaining').innerText = `ENEMIES: ${enemiesInWave - enemiesKilledThisWave}`;
            reserveAmmo = Math.min(reserveAmmo + 15, 300);
            currentArrows = Math.min(currentArrows + 5, maxArrows);
            currentSpears = Math.min(currentSpears + 2, maxSpears);

            // Skill-tree-scaled rewards
            wood += skillTree.woodPerKill;
            const healAmt = skillTree.healPerKill;
            health = Math.min(health + healAmt, maxPlayerHealth);
            updateAmmoDisplay();
            document.getElementById('mats').innerText = `ü™µ ${wood}`;
            document.getElementById('health-bar').style.width = (health / maxPlayerHealth * 100) + '%';

            // Coin reward ‚Äî boss worth more
            const coinReward = (en.userData.isBoss ? 25 : en.userData.enemyType === 'tank' ? 8 : 3) + skillTree.coinsPerKill;
            addCoins(coinReward);

            // Heal indicator
            const healEl = document.createElement('div');
            healEl.className = 'indicator indicator--heal';
            healEl.innerText = `+${healAmt} HP`;
            document.body.appendChild(healEl);
            setTimeout(() => {
                healEl.classList.add('indicator--fade-out','is-exiting');
                healEl.style.transform = 'translateY(-30px)';
                setTimeout(() => healEl.remove(), 500);
            }, 100);

            // Random power-up drop
            tryDropPowerUp(enPos);

            if (enemiesKilledThisWave >= enemiesInWave) waveComplete();
        }

        function waveComplete() {
            const completedWave = currentWave;
            currentWave++;
            enemiesKilledThisWave = 0;
            enemiesInWave = 5 + (currentWave - 1) * 2;
            document.getElementById('wave-counter').innerText = `WAVE: ${currentWave}`;
            document.getElementById('enemies-remaining').innerText = `ENEMIES: ${enemiesInWave}`;

            // Check biome change (every 10 waves)
            const newBiome = getBiomeForWave(currentWave);
            const biomeChanged = newBiome !== currentBiome;
            if(biomeChanged) {
                applyBiome(newBiome);
                // Clear all terrain chunks so they regenerate with new biome
                const keys = [...terrainChunks.keys()];
                keys.forEach(k => removeTerrainChunk(k));
                lastPlayerChunkPos = { x: Infinity, z: Infinity }; // force regeneration
            }

            // New weather every wave
            const newWeather = pickWeather();
            applyWeather(newWeather);

            const isBossWave = (currentWave % 5 === 0);
            let bannerText = isBossWave ? `‚ö†Ô∏è WAVE ${completedWave} COMPLETE! BOSS INCOMING!` : `WAVE ${completedWave} COMPLETE!`;
            const waveMsg = document.createElement('div');
            waveMsg.className = 'indicator indicator--center indicator--wave-complete';
            waveMsg.innerText = bannerText;
            waveMsg.style.color = isBossWave ? '#ff4400' : '';
            document.body.appendChild(waveMsg);

            pendingWaveSpawn = true;
            pendingWaveSize = enemiesInWave;
            window._bossSpawnedThisWave = false;
            setTimeout(() => {
                waveMsg.remove();
                if(biomeChanged || newWeather !== 'clear') showBiomeWeatherBanner(biomeChanged, currentBiome, newBiome, newWeather);
                showUpgradeScreen(completedWave);
            }, 1800);
        }
        
        function tryAutoFire() {
            if(!isMouseDown || !gameStarted || document.pointerLockElement !== document.body) return;
            if (activeSlot === 1) shootKnife();
        }

        function harvest() {
            trees.forEach(tree => {
                if(player.position.distanceTo(tree.position) < 4) {
                    wood += 10;
                    document.getElementById('mats').innerText = `ü™µ ${wood}`;
                    tree.scale.set(1.2,1.2,1.2);
                    hitSound();
                    setTimeout(() => tree.scale.set(1,1,1), 100);
                }
            });
        }
        
        function updateAmmoDisplay() {
            const reloadPrompt = document.getElementById('reload-prompt');
            if (activeSlot === 1) {
                document.getElementById('ammo-display').innerText = `KNIFE: ${currentAmmo}/${reserveAmmo}`;
                reloadPrompt.classList.toggle('u-hidden', !(currentAmmo === 0 && reserveAmmo > 0));
            } else if (activeSlot === 2) {
                document.getElementById('ammo-display').innerText = `ARROWS: ${currentArrows}/${maxArrows}`;
                reloadPrompt.classList.add('u-hidden');
            } else if (activeSlot === 3) {
                document.getElementById('ammo-display').innerText = `SPEARS: ${currentSpears}/${maxSpears}`;
                reloadPrompt.classList.add('u-hidden');
            } else {
                document.getElementById('ammo-display').innerText = `AXE: READY`;
                reloadPrompt.classList.add('u-hidden');
            }
        }
        
        function reload() {
            if(isReloading || reserveAmmo === 0 || currentAmmo === maxMagSize) return;
            isReloading = true;
            reloadSound();
            document.getElementById('reload-prompt').innerText = 'Reloading...';
            document.getElementById('reload-prompt').classList.remove('u-hidden');
            setTimeout(() => {
                const needed = maxMagSize - currentAmmo;
                const toReload = Math.min(needed, reserveAmmo);
                currentAmmo += toReload; reserveAmmo -= toReload;
                isReloading = false;
                updateAmmoDisplay();
            }, getEffectiveReloadTime());
        }

        function animateCharacter(character, isMoving, isAttacking = false) {
            if (isMoving || isAttacking) character.userData.animTime += 0.1;
            const isCapybara = character.userData.frontLegLeft !== undefined;
            if(isCapybara) {
                let fLX=0, fRX=0, bLX=0, bRX=0;
                if(isMoving || isAttacking) {
                    const s = Math.sin(character.userData.animTime) * 0.3;
                    fLX=s; fRX=-s; bLX=-s; bRX=s;
                }
                const lf = 0.15;
                if(character.userData.frontLegLeft) character.userData.frontLegLeft.rotation.x += (fLX - character.userData.frontLegLeft.rotation.x) * lf;
                if(character.userData.frontLegRight) character.userData.frontLegRight.rotation.x += (fRX - character.userData.frontLegRight.rotation.x) * lf;
                if(character.userData.backLegLeft) character.userData.backLegLeft.rotation.x += (bLX - character.userData.backLegLeft.rotation.x) * lf;
                if(character.userData.backLegRight) character.userData.backLegRight.rotation.x += (bRX - character.userData.backLegRight.rotation.x) * lf;
            } else {
                let tLA=0, tRA=0, tLL=0, tRL=0;
                const at = character.userData.attackType || 'knife';
                const throwing = character.userData.isThrowing;
                const throwDur = (at==='axe') ? 220 : (at==='bow') ? 380 : 300;
                const tElapsed = Date.now() - (character.userData.throwStartTime || 0);
                if (throwing && character.userData.heldKnife) {
                    character.userData.heldKnife.visible = false;
                    if(character.userData.heldBow) character.userData.heldBow.visible = false;
                    if(character.userData.heldSpear) character.userData.heldSpear.visible = false;
                    if(character.userData.heldAxe) character.userData.heldAxe.visible = false;
                    if(tElapsed >= throwDur) { character.userData.isThrowing = false; updateHeldWeapon(); }
                } else if(character.userData.heldKnife && !throwing) { updateHeldWeapon(); }
                if(throwing && tElapsed < throwDur) {
                    const t = tElapsed / throwDur;
                    if(at==='bow') {
                        if(t<0.5) { tRA=(t/0.5)*1.6; tLA=-0.5; }
                        else { const rp=(t-0.5)/0.5; tRA=1.6-rp*2.4; tLA=-0.5+rp*0.3; }
                    } else if(at==='spear') {
                        if(t<0.2) { tRA=(t/0.2)*-2.2; tLA=-0.4; }
                        else if(t<0.48) { tRA=-2.2+((t-0.2)/0.28)*2.6; tLA=-0.4; }
                        else { tRA=0.4-((t-0.48)/0.52)*0.4; tLA=-0.4+((t-0.48)/0.52)*0.4; }
                    } else if(at==='axe') {
                        if(t<0.12) { tRA=(t/0.12)*1.3; tLA=0.15; }
                        else { const cp=(t-0.12)/0.88; tRA=1.3-cp*2.5; tLA=0.15-cp*0.2; }
                    } else {
                        if(t<0.2) { tRA=(t/0.2)*-2.1; tLA=-0.2; }
                        else if(t<0.48) { tRA=-2.1+((t-0.2)/0.28)*2.4; tLA=-0.2; }
                        else { tRA=0.3-((t-0.48)/0.52)*0.3; tLA=-0.2; }
                    }
                } else if(isMoving || isAttacking) {
                    const sw = Math.sin(character.userData.animTime) * (isAttacking ? 0.6 : 0.25);
                    tLA=sw; tRA=-sw;
                    if(isMoving) { const ls=Math.sin(character.userData.animTime)*0.35; tLL=ls; tRL=-ls; }
                }
                const lf = (throwing && tElapsed < throwDur) ? 0.35 : 0.15;
                const tRAZ = ((at==='spear'||at==='knife') && throwing && tElapsed < throwDur) ? 0.5 : 0;
                if(character.userData.leftArm) character.userData.leftArm.rotation.x += (tLA - character.userData.leftArm.rotation.x) * lf;
                if(character.userData.rightArm) { character.userData.rightArm.rotation.x += (tRA - character.userData.rightArm.rotation.x) * lf; character.userData.rightArm.rotation.z += (tRAZ - character.userData.rightArm.rotation.z) * lf; }
                if(character.userData.leftLeg) character.userData.leftLeg.rotation.x += (tLL - character.userData.leftLeg.rotation.x) * lf;
                if(character.userData.rightLeg) character.userData.rightLeg.rotation.x += (tRL - character.userData.rightLeg.rotation.x) * lf;
                if(isMoving) {
                    const tb = Math.abs(Math.sin(character.userData.animTime*2))*0.03;
                    if(!character.userData.currentBob) character.userData.currentBob=0;
                    character.userData.currentBob += (tb - character.userData.currentBob) * 0.2;
                    character.position.y += character.userData.currentBob - (character.userData.lastBob||0);
                    character.userData.lastBob = character.userData.currentBob;
                } else if(character.userData.currentBob) {
                    character.userData.currentBob *= 0.9;
                    character.position.y += character.userData.currentBob - (character.userData.lastBob||0);
                    character.userData.lastBob = character.userData.currentBob;
                }
            }
        }

        let keys = {}, playerVY = 0, playerGrounded = true, pitch = 0;
        let playerVelocity = new THREE.Vector3(0, 0, 0);
        window.onkeydown = (e) => {
            if(!gameStarted) return;
            keys[e.code] = true;
            if(e.code==='Digit1') { activeSlot=1; bowCharging=false; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='Digit2') { activeSlot=2; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='Digit3') { activeSlot=3; bowCharging=false; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='Digit4') { activeSlot=4; bowCharging=false; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='KeyR') reload();
        };
        window.onkeyup = (e) => keys[e.code] = false;

        function updateInventoryUI() {
            [1,2,3,4].forEach(n => document.getElementById('slot'+n).classList.toggle('slot--active', activeSlot===n));
        }
        
        function updateHeldWeapon() {
            player.userData.heldKnife.visible = (activeSlot===1);
            player.userData.heldBow.visible = (activeSlot===2);
            player.userData.heldSpear.visible = (activeSlot===3);
            player.userData.heldAxe.visible = (activeSlot===4);
        }

        document.addEventListener('mousedown', (e) => {
            if(!gameStarted) return;
            if(upgradeScreenOpen || shopScreenOpen) return;
            if(document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            } else {
                isMouseDown = true;
                if(activeSlot===2) startBowCharge();
                else if(activeSlot>=1 && activeSlot<=4) useWeapon();
            }
        });
        document.addEventListener('mouseup', (e) => {
            if(activeSlot===2 && bowCharging) releaseBow();
            isMouseDown = false; bowCharging = false;
        });
        document.addEventListener('mousemove', (e) => {
            if(document.pointerLockElement === document.body) {
                const sens = 0.002;
                player.rotation.y -= e.movementX * sens;
                pitch = Math.max(-0.8, Math.min(0.8, pitch - e.movementY * sens));
                camPivot.rotation.x += (pitch - camPivot.rotation.x) * 0.3;
            }
        });
        
        document.getElementById('start-button').addEventListener('click', () => {
            document.getElementById('start-screen').classList.add('u-hidden');
            gameStarted = true;
            audioCtx.resume();
            document.body.requestPointerLock();
            updateHeldWeapon();
            updateAmmoDisplay();
        });

        function updateUIHealthBar(mesh, offsetY = 2.2) {
            if(!mesh.userData.healthBarElement) return;
            const pos = new THREE.Vector3();
            mesh.getWorldPosition(pos);
            pos.y += offsetY;
            pos.project(camera);
            mesh.userData.healthBarElement.style.left = (pos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            mesh.userData.healthBarElement.style.top = (-pos.y * 0.5 + 0.5) * window.innerHeight + 'px';
            mesh.userData.healthBarElement.style.display = (pos.z > 1 || (mesh.userData.health >= mesh.userData.maxHealth && mesh.userData.type==='wall')) ? 'none' : 'block';
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!gameStarted) { renderer.render(scene, camera); return; }
            
            updateDayNightCycle();
            animateClouds();
            updateRain();
            updateStormLightning();
            updatePowerUps();
            tryAutoFire();
            
            // Bow charge bar
            const chargeBar = document.getElementById('bow-charge-bar');
            const chargeFill = document.getElementById('bow-charge-fill');
            chargeBar.classList.toggle('u-hidden', !(activeSlot===2 && bowCharging));
            if(activeSlot===2 && bowCharging) {
                const pct = Math.min((Date.now() - bowChargeStart) / getEffectiveBowChargeMax(), 1) * 100;
                chargeFill.style.width = pct + '%';
            }
            
            const baseSpeed = getEffectiveMoveSpeed() * (isPowerUpActive('speed') ? 1.6 : 1.0);
            const sprintMult = 1.6;
            let moveDir = new THREE.Vector3();
            let isMoving = false;
            if(keys['KeyW']) { moveDir.z -= 1; isMoving = true; }
            if(keys['KeyS']) { moveDir.z += 1; isMoving = true; }
            if(keys['KeyA']) { moveDir.x -= 1; isMoving = true; }
            if(keys['KeyD']) { moveDir.x += 1; isMoving = true; }

            // Check if player is on water or ice
            let waterMult = 1.0, iceDecel = false;
            for(const zone of waterZonesList) {
                const dx = player.position.x - zone.x, dz = player.position.z - zone.z;
                if(dx*dx + dz*dz < zone.r * zone.r) {
                    if(zone.ice) { iceDecel = true; }
                    else { waterMult = 0.45; }
                    break;
                }
            }

            const isSprinting = (keys['ShiftLeft'] || keys['ShiftRight']) && isMoving;
            const speed = (isSprinting ? baseSpeed * sprintMult : baseSpeed) * waterMult;
            moveDir.normalize().applyQuaternion(player.quaternion);
            if(isMoving) { playerVelocity.lerp(moveDir.multiplyScalar(speed), 0.03); }
            else { playerVelocity.multiplyScalar(iceDecel ? 0.995 : 0.85); } // ice is slippery
            document.getElementById('sprint-indicator').classList.toggle('u-hidden', !isSprinting);
            
            if(playerVelocity.length() > 0.001) {
                const ray = new THREE.Raycaster(new THREE.Vector3(player.position.x,0.5,player.position.z), playerVelocity.clone().normalize());
                const hits = ray.intersectObjects(collidables);
                const blocked = hits.length > 0 && hits[0].distance < 0.8;
                const nx = player.position.x + playerVelocity.x;
                const nz = player.position.z + playerVelocity.z;
                let blockedTree = false;
                for(let t = 0; t < trees.length; t++) {
                    const dx = nx - trees[t].position.x, dz = nz - trees[t].position.z;
                    if(dx*dx + dz*dz < TREE_COLLISION_RADIUS * TREE_COLLISION_RADIUS) { blockedTree=true; break; }
                }
                if(!blocked && !blockedTree) player.position.add(playerVelocity);
            }
            
            if(isMoving && playerGrounded) footstepSound(isSprinting);
            animateCharacter(player, isMoving);
            updateTerrain();
            
            player.position.y += playerVY; playerVY -= 0.01;
            const activeFloors = [];
            terrainChunks.forEach(c => { if(c.floor) activeFloors.push(c.floor); });
            const pDownRay = new THREE.Raycaster(new THREE.Vector3(player.position.x, player.position.y+1.2, player.position.z), new THREE.Vector3(0,-1,0));
            const pHit = pDownRay.intersectObjects([...collidables, ...activeFloors]);
            if(pHit.length > 0 && pHit[0].distance <= 1.25) { player.position.y = (player.position.y+1.2) - pHit[0].distance; playerVY=0; playerGrounded=true; }
            else playerGrounded = false;
            if(keys['Space'] && playerGrounded) { playerVY=0.2; playerGrounded=false; }

            // Enemy AI
            enemies.forEach((en, idx) => {
                const dist = player.position.distanceTo(en.position);
                if(dist > renderDistance + 20) {
                    scene.remove(en);
                    if(en.userData.healthBarElement) en.userData.healthBarElement.remove();
                    enemies.splice(idx, 1);
                    spawnEnemyNearPlayer();
                    return;
                }

                const type = en.userData.enemyType || 'normal';
                const dirToPlayer = new THREE.Vector3().subVectors(player.position, en.position).normalize();
                const now = Date.now();

                // --- EXPLODER: pulse belly glow and explode on contact ---
                if(type === 'exploder') {
                    if(en.userData.belly) {
                        en.userData.belly.material.emissiveIntensity = 0.5 + Math.sin(now * 0.008) * 0.45;
                    }
                    if(dist < en.userData.attackRange * en.scale.x && !en.userData.exploded) {
                        triggerExplosion(en);
                        killEnemy(en);
                        return;
                    }
                }

                // --- SPITTER / BOSS: ranged spit attack ---
                if(type === 'spitter' || type === 'boss') {
                    if(dist < en.userData.spitRange && now - en.userData.lastSpit > en.userData.spitCooldown) {
                        en.userData.lastSpit = now;
                        fireEnemySpit(en);
                    }
                }

                const eRay = new THREE.Raycaster(new THREE.Vector3(en.position.x,0.5,en.position.z), dirToPlayer);
                const eHits = eRay.intersectObjects(collidables);
                let isBlocked = (eHits.length > 0 && eHits[0].distance < 0.8);

                // Spitters try to maintain preferred distance
                if(type === 'spitter' && dist < (en.userData.preferredDistance * 0.7)) {
                    const backDir = dirToPlayer.clone().negate();
                    en.position.add(new THREE.Vector3(backDir.x,0,backDir.z).multiplyScalar(en.userData.speed));
                } else if(!isBlocked && dist > en.userData.attackRange) {
                    en.position.add(new THREE.Vector3(dirToPlayer.x,0,dirToPlayer.z).multiplyScalar(en.userData.speed));
                } else if(isBlocked) {
                    const rDir = new THREE.Vector3(-dirToPlayer.z,0,dirToPlayer.x).normalize();
                    const lDir = new THREE.Vector3(dirToPlayer.z,0,-dirToPlayer.x).normalize();
                    const rRay = new THREE.Raycaster(new THREE.Vector3(en.position.x,0.5,en.position.z), rDir);
                    const lRay = new THREE.Raycaster(new THREE.Vector3(en.position.x,0.5,en.position.z), lDir);
                    const rH = rRay.intersectObjects(collidables);
                    const lH = lRay.intersectObjects(collidables);
                    if(!(rH.length > 0 && rH[0].distance < 0.8)) en.position.add(rDir.multiplyScalar(en.userData.speed * 0.7));
                    else if(!(lH.length > 0 && lH[0].distance < 0.8)) en.position.add(lDir.multiplyScalar(en.userData.speed * 0.7));
                }

                animateCharacter(en, !isBlocked && dist > en.userData.attackRange, false);
                en.rotation.y = Math.atan2(dirToPlayer.x, dirToPlayer.z);
                en.position.y += en.userData.vY; en.userData.vY -= 0.01;
                const eDown = new THREE.Raycaster(new THREE.Vector3(en.position.x,en.position.y+1.2,en.position.z), new THREE.Vector3(0,-1,0));
                const eHit2 = eDown.intersectObjects([...collidables, ...activeFloors]);
                if(eHit2.length > 0 && eHit2[0].distance <= 1.25) { en.position.y=(en.position.y+1.2)-eHit2[0].distance; en.userData.vY=0; }

                updateUIHealthBar(en, 2.2 * en.scale.y);

                // Melee damage to player
                const meleeDist = en.userData.attackRange * en.scale.x;
                if(dist < meleeDist && now - lastDamageTime > 1000 && type !== 'exploder' && !isPowerUpActive('invincible')) {
                    const dmg = en.userData.attackDamage || 20;
                    health -= dmg; lastDamageTime = now; damageSound();
                    document.getElementById('health-bar').style.width = (health/maxPlayerHealth*100) + '%';
                    if(health <= 0) { showGameOver(currentWave - 1, killCount); }
                }
            });

            // Enemy projectile (spit) physics
            for(let i = enemyProjectiles.length-1; i >= 0; i--) {
                const proj = enemyProjectiles[i];
                proj.position.add(proj.userData.velocity);
                proj.userData.velocity.y += proj.userData.gravity;
                proj.userData.life--;
                if(proj.position.y < 0.2 || proj.userData.life <= 0) { scene.remove(proj); enemyProjectiles.splice(i,1); continue; }
                if(proj.position.distanceTo(player.position) < 1.0) {
                    if(!isPowerUpActive('invincible')) {
                        health -= proj.userData.damage; lastDamageTime = Date.now(); damageSound();
                        document.getElementById('health-bar').style.width = Math.max(0, health/maxPlayerHealth*100) + '%';
                    }
                    scene.remove(proj); enemyProjectiles.splice(i,1);
                    if(health <= 0) { showGameOver(currentWave - 1, killCount); }
                }
            }

            collidables.forEach(c => { if(c.userData.type==='wall') updateUIHealthBar(c, 1.8); });
            // (wall health bars kept for safety, walls no longer buildable)

            // Bullet physics
            for(let i=bullets.length-1; i>=0; i--) {
                if(!bullets[i]) continue;
                bullets[i].position.add(bullets[i].userData.velocity);
                if(bullets[i].userData.gravity) bullets[i].userData.velocity.y += bullets[i].userData.gravity;
                if(bullets[i].userData.rotationSpeed) bullets[i].rotation.x += bullets[i].userData.rotationSpeed;
                
                const bRay = new THREE.Raycaster(
                    bullets[i].userData.lastPos || bullets[i].position.clone().sub(bullets[i].userData.velocity),
                    bullets[i].userData.velocity.clone().normalize(), 0, bullets[i].userData.velocity.length()
                );
                const obsHits = bRay.intersectObjects(collidables);
                if(obsHits.length > 0) {
                    scene.remove(bullets[i]); bullets.splice(i, 1); continue;
                }
                bullets[i].userData.lastPos = bullets[i].position.clone();
                
                enemies.forEach((en, eIdx) => {
                    if(!bullets[i]) return;
                    const bp = bullets[i].position;
                    const ewp = new THREE.Vector3();
                    en.getWorldPosition(ewp);
                    // Scale hitbox dimensions by the enemy's uniform scale
                    const s = en.scale.x;
                    const bMinX=ewp.x-0.6*s, bMaxX=ewp.x+0.6*s, bMinY=ewp.y+0.15*s, bMaxY=ewp.y+0.85*s, bMinZ=ewp.z-0.9*s, bMaxZ=ewp.z+0.9*s;
                    const hcz = ewp.z + Math.cos(en.rotation.y)*1.0*s, hcx = ewp.x + Math.sin(en.rotation.y)*1.0*s;
                    const hMinX=hcx-0.4*s, hMaxX=hcx+0.4*s, hMinY=ewp.y+0.35*s, hMaxY=ewp.y+0.95*s, hMinZ=hcz-0.35*s, hMaxZ=hcz+0.35*s;
                    const isHead = bp.x>=hMinX && bp.x<=hMaxX && bp.y>=hMinY && bp.y<=hMaxY && bp.z>=hMinZ && bp.z<=hMaxZ;
                    const isBody = bp.x>=bMinX && bp.x<=bMaxX && bp.y>=bMinY && bp.y<=bMaxY && bp.z>=bMinZ && bp.z<=bMaxZ;
                    if(isHead || isBody) {
                        const base = bullets[i].userData.damage || 34;
                        const dmg = isHead ? base * 2 : base;
                        en.userData.health -= dmg;
                        en.userData.healthBarFill.style.width = (en.userData.health / en.userData.maxHealth * 100) + '%';
                        hitSound();
                        if(isHead) {
                            const hs = document.createElement('div');
                            hs.className = 'indicator indicator--center indicator--headshot';
                            hs.innerText = 'HEADSHOT!';
                            document.body.appendChild(hs);
                            setTimeout(() => { hs.classList.add('indicator--fade-out','is-exiting'); hs.style.transform='translate(-50%,-100%)'; setTimeout(()=>hs.remove(),500); }, 100);
                            playSound(800, 0.2, 'sine', 0.15);
                        }
                        scene.remove(bullets[i]); bullets.splice(i, 1);
                        if(en.userData.health <= 0) killEnemy(en);
                    }
                });
                if(bullets[i] && bullets[i].userData.life-- <= 0) { scene.remove(bullets[i]); bullets.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }
        animate();
        updateAmmoDisplay();

        // Add CSS for upgrade screen out animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes upgradeScreenOut { from { opacity:1; transform:scale(1); } to { opacity:0; transform:scale(1.05); } }
            @keyframes hintFadeIn { from { opacity:0; transform:translate(-50%,-60%); } to { opacity:1; transform:translate(-50%,-50%); } }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>