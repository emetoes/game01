<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capybara Survivor</title>
    <style>
/* ============================================================
   Capybara Survivor ‚Äî Inlined Stylesheet
   ============================================================ */
*,*::before,*::after{box-sizing:border-box;}
body{margin:0;overflow:hidden;background-color:#6eb1ff;font-family:'Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell',sans-serif;}

/* Utilities */
.u-hidden{display:none!important;}
.u-visible{display:block!important;}
.u-flex-visible{display:flex!important;}
.u-flex{display:flex;}
.u-flex-center{display:flex;flex-direction:column;align-items:center;justify-content:center;}
.u-text-center{text-align:center;}
.u-center-h{position:absolute;left:50%;transform:translateX(-50%);}
.u-overlay{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1000;}
.u-floating-indicator{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:100;pointer-events:none;font-weight:bold;}

/* HUD */
.hud{position:absolute;bottom:20px;right:20px;width:250px;padding:15px;background:rgba(0,0,0,0.7);border-radius:10px;border-bottom:5px solid #2196f3;box-shadow:0 4px 20px rgba(0,0,0,0.5);}
.hud__stat{color:#fff;margin-top:10px;text-align:center;}
.hud__stat--ammo{font-size:20px;}
.hud__stat--reload{color:#f1c40f;font-size:16px;}
.hud__stat--sprint{color:#2ecc71;font-size:14px;}

/* Bars */
.bar{width:100%;height:15px;background:#222;margin:4px 0;border-radius:2px;overflow:hidden;}
.bar__fill{height:100%;border-radius:2px;transition:width 0.2s;}
.bar__fill--health{width:100%;background:linear-gradient(90deg,#4ef037,#2ecc71);}
.bar__fill--charge{width:0%;background:linear-gradient(90deg,#44aa99,#2ecc71);transition:width 0.05s;}
.bar--charge{height:8px;margin-top:8px;background:#333;border-radius:4px;}

/* Inventory */
.inventory{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:10px;}
.slot{width:60px;height:60px;background:rgba(0,0,0,0.6);border:2px solid #fff;border-radius:8px;color:#fff;display:flex;align-items:center;justify-content:center;font-size:10px;text-align:center;transition:all 0.2s;cursor:pointer;}
.slot:hover{background:rgba(255,255,255,0.15);}
.slot--active{background:rgba(255,255,255,0.3);border-color:#f1c40f;box-shadow:0 0 20px #f1c40f;transform:scale(1.1);}

/* Crosshair */
.crosshair{position:absolute;top:50%;left:50%;width:16px;height:16px;border:3px solid #fff;border-radius:50%;transform:translate(-50%,-50%);pointer-events:none;box-shadow:0 0 10px rgba(0,0,0,0.5);}

/* World health bars */
.healthbar{position:absolute;width:60px;height:6px;background:rgba(0,0,0,0.7);border-radius:3px;transform:translate(-50%,-50%);pointer-events:none;display:none;border:1px solid rgba(255,255,255,0.3);}
.healthbar__fill{height:100%;border-radius:3px;transition:width 0.2s;}
.healthbar__fill--enemy{background:linear-gradient(90deg,#ff4444,#cc0000);}
.healthbar__fill--wall{background:linear-gradient(90deg,#2196f3,#1976d2);}

/* Top stats */
.stat-bar{position:absolute;left:50%;transform:translateX(-50%);color:#fff;text-shadow:3px 3px 6px rgba(0,0,0,0.8);}
.stat-bar--kills{top:20px;font-size:32px;}
.stat-bar--wave{top:70px;font-size:36px;}
.stat-bar--enemies{top:115px;color:#f1c40f;font-size:24px;}

/* Materials */
.mats{position:absolute;bottom:160px;right:25px;color:#ffd966;font-size:28px;text-shadow:3px 3px 6px rgba(0,0,0,0.8);}

/* Modals */
.modal{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000;}
.modal--start{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);}
.modal--game-over{background:rgba(0,0,0,0.95);display:none;}
.modal--game-over.is-visible{display:flex;}
.modal__title{color:#fff;margin-bottom:20px;text-shadow:4px 4px 8px rgba(0,0,0,0.5);}
.modal__title--lg{font-size:72px;font-family:'Arial Black','Impact',sans-serif;}
.modal__title--xl{font-size:96px;color:#ff4444;text-shadow:4px 4px 8px rgba(0,0,0,0.8);}
.modal__subtitle{color:#fff;font-size:24px;margin-bottom:40px;}
.modal__stat{color:#f1c40f;font-size:36px;margin-bottom:10px;text-shadow:2px 2px 4px rgba(0,0,0,0.8);}
.modal__stat--secondary{color:#fff;font-size:28px;margin-bottom:20px;}
.modal__hint{color:#aaa;font-size:20px;}

/* Buttons */
.btn{padding:20px 60px;font-size:32px;font-family:'Arial Black','Impact',sans-serif;background:#f1c40f;border:none;border-radius:10px;cursor:pointer;color:#1a1a1a;box-shadow:0 8px 16px rgba(0,0,0,0.3);transition:transform 0.2s;}
.btn:hover{transform:scale(1.1);}

/* Indicators */
.indicator{position:absolute;z-index:100;pointer-events:none;font-weight:bold;}
.indicator--center{top:50%;left:50%;transform:translate(-50%,-50%);}
.indicator--headshot{color:#ff4444;font-size:48px;text-shadow:3px 3px 6px rgba(0,0,0,0.8);}
.indicator--wave-complete{color:#f1c40f;font-size:48px;text-shadow:4px 4px 8px rgba(0,0,0,0.8);}
.indicator--heal{bottom:100px;right:30px;color:#4ef037;font-size:24px;text-shadow:2px 2px 4px rgba(0,0,0,0.8);}
.indicator--fade-out{transition:opacity 0.5s,transform 0.5s;}
.indicator--fade-out.is-exiting{opacity:0!important;}

/* Upgrade tracker */
.upgrade-tracker{position:absolute;top:20px;left:20px;max-width:220px;background:rgba(0,0,0,0.6);border-radius:10px;padding:10px 14px;border-left:3px solid #2196f3;}
.upgrade-tracker__title{color:#2196f3;font-size:11px;font-weight:900;letter-spacing:1px;text-transform:uppercase;margin-bottom:6px;}

/* Upgrade screen */
.upgrade-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.88);z-index:900;display:none;flex-direction:column;align-items:center;justify-content:center;padding:30px 20px;}
.upgrade-screen.is-visible{display:flex;}
.upgrade-screen__header{text-align:center;margin-bottom:28px;}
.upgrade-screen__wave-badge{display:inline-block;padding:6px 20px;background:rgba(255,255,255,0.1);border-radius:20px;color:rgba(255,255,255,0.6);font-size:13px;letter-spacing:2px;text-transform:uppercase;margin-bottom:12px;}
.upgrade-screen__title{color:#fff;font-size:42px;font-family:'Arial Black',sans-serif;margin:0 0 6px;text-shadow:2px 2px 8px rgba(0,0,0,0.8);}
.upgrade-screen__subtitle{color:rgba(255,255,255,0.55);font-size:16px;margin:0;}
.upgrade-cards{display:flex;gap:20px;flex-wrap:wrap;justify-content:center;max-width:900px;}
.upgrade-card{width:240px;background:rgba(255,255,255,0.06);border-radius:16px;padding:24px 20px;border:2px solid rgba(255,255,255,0.12);cursor:pointer;transition:transform 0.15s,box-shadow 0.15s,border-color 0.15s;position:relative;overflow:hidden;}
.upgrade-card:hover{transform:translateY(-6px);}

/* Rarity variants */
.upgrade-card--common    { border-color: #555; }
.upgrade-card--uncommon  { border-color: #1ec850; box-shadow: 0 0 10px rgba(30,200,80,0.25); }
.upgrade-card--rare      { border-color: #3c82ff; box-shadow: 0 0 14px rgba(60,130,255,0.3); }
.upgrade-card--epic      { border-color: #b43cff; box-shadow: 0 0 18px rgba(180,60,255,0.35); }
.upgrade-card--legendary { border-color: #ffa500; box-shadow: 0 0 22px rgba(255,165,0,0.45); background: rgba(255,165,0,0.07); }

/* Rarity top bar */
.upgrade-card__rarity-bar { position:absolute; top:0; left:0; right:0; height:4px; border-radius:14px 14px 0 0; }
.upgrade-card--common    .upgrade-card__rarity-bar { background: #555; }
.upgrade-card--uncommon  .upgrade-card__rarity-bar { background: #1ec850; }
.upgrade-card--rare      .upgrade-card__rarity-bar { background: #3c82ff; }
.upgrade-card--epic      .upgrade-card__rarity-bar { background: #b43cff; }
.upgrade-card--legendary .upgrade-card__rarity-bar { background: linear-gradient(90deg,#ffa500,#ffe066,#ffa500); }

/* Card inner elements */
.upgrade-card__icon        { font-size: 40px; display: block; margin-bottom: 10px; }
.upgrade-card__rarity-label{ font-size: 11px; font-weight: 900; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; }
.upgrade-card--common    .upgrade-card__rarity-label { color: #aaa; }
.upgrade-card--uncommon  .upgrade-card__rarity-label { color: #1ec850; }
.upgrade-card--rare      .upgrade-card__rarity-label { color: #3c82ff; }
.upgrade-card--epic      .upgrade-card__rarity-label { color: #b43cff; }
.upgrade-card--legendary .upgrade-card__rarity-label { color: #ffa500; }
.upgrade-card__name  { font-size: 18px; font-weight: 900; color: #fff; margin-bottom: 8px; }
.upgrade-card__desc  { font-size: 13px; color: rgba(255,255,255,0.55); margin: 0 0 12px; line-height: 1.5; }
.upgrade-card__bonus { display: flex; align-items: center; gap: 6px; font-size: 14px; font-weight: 700; color: #f1c40f; margin-bottom: 8px; }
.upgrade-card__bonus-icon { font-size: 12px; }
.upgrade-card__applies { font-size: 11px; color: rgba(255,255,255,0.3); text-transform: uppercase; letter-spacing: 1px; }

/* Skill tree nodes */
.skill-node { background: rgba(255,255,255,0.06); border: 2px solid rgba(255,255,255,0.15); border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s; }
.skill-node:hover { transform: translateY(-3px); }
.skill-node.maxed { opacity: 0.5; cursor: default; }
.skill-node__icon { font-size: 28px; margin-bottom: 8px; }
.skill-node__name { font-size: 14px; font-weight: 900; color: #fff; margin-bottom: 4px; }
.skill-node__desc { font-size: 12px; color: rgba(255,255,255,0.5); margin-bottom: 8px; line-height: 1.4; }
.skill-node__rank { font-size: 11px; color: #f1c40f; font-weight: 700; }
    </style>
</head>
<body>
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         IN-GAME HUD ‚Äî hidden until game starts
         ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="hud-root" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;z-index:10;pointer-events:none;">

    <div id="crosshair" class="crosshair"></div>
    <div id="mats" class="mats">ü™µ 30</div>
    <div id="coin-display" style="position:absolute;bottom:215px;right:25px;color:#f1c40f;font-size:24px;text-shadow:2px 2px 6px rgba(0,0,0,0.8);">ü™ô 0</div>

    <!-- Biome + Weather badge -->
    <div id="biome-badge" style="position:absolute;top:20px;right:20px;background:rgba(0,0,0,0.6);border-radius:10px;padding:8px 14px;color:#fff;font-size:13px;font-weight:700;text-align:right;border:1px solid rgba(255,255,255,0.15);line-height:1.6;">
        <div id="biome-label" style="font-size:16px;">üå≤ Forest</div>
        <div id="weather-label" style="color:rgba(255,255,255,0.65);font-size:12px;">‚òÄÔ∏è Clear</div>
    </div>

    <div id="kill-counter" class="stat-bar stat-bar--kills">ELIMINATIONS: 0</div>
    <div id="wave-counter" class="stat-bar stat-bar--wave">WAVE: 1</div>
    <div id="enemies-remaining" class="stat-bar stat-bar--enemies">ENEMIES: 5</div>

    <!-- Active power-up indicator -->
    <div id="powerup-display" style="position:absolute;top:160px;left:20px;display:none;background:rgba(0,0,0,0.65);border-radius:8px;padding:8px 14px;border-left:3px solid #f1c40f;color:#fff;font-size:14px;min-width:160px;">
        <div style="font-size:10px;letter-spacing:2px;color:#f1c40f;text-transform:uppercase;font-weight:700;margin-bottom:4px;">‚ö° Active Power-Up</div>
        <div id="powerup-name" style="font-size:15px;font-weight:700;"></div>
        <div style="height:4px;background:#333;border-radius:2px;margin-top:6px;overflow:hidden;">
            <div id="powerup-bar" style="height:100%;background:linear-gradient(90deg,#f1c40f,#e67e22);width:100%;transition:width 0.1s;border-radius:2px;"></div>
        </div>
    </div>
    <div id="inventory" class="inventory">
        <div id="slot1" class="slot slot--active">1<br>KNIFE</div>
        <div id="slot2" class="slot">2<br>BOW</div>
        <div id="slot3" class="slot">3<br>SPEAR</div>
        <div id="slot4" class="slot">4<br>AXE</div>
    </div>
    <div id="hud" class="hud">
        <div class="bar"><div id="health-bar" class="bar__fill bar__fill--health"></div></div>
        <div id="ammo-display" class="hud__stat hud__stat--ammo">KNIFE: 30/90</div>
        <div id="bow-charge-bar" class="bar bar--charge u-hidden">
            <div id="bow-charge-fill" class="bar__fill bar__fill--charge"></div>
        </div>
        <div id="reload-prompt" class="hud__stat hud__stat--reload u-hidden">Press R to Reload</div>
        <div id="sprint-indicator" class="hud__stat hud__stat--sprint u-hidden">SPRINTING</div>
    </div>

    <!-- Upgrade Tracker HUD -->
    <div id="upgrade-tracker" class="upgrade-tracker">
        <div class="upgrade-tracker__title">‚ö° Upgrades</div>
        <div id="upgrade-tracker-items"></div>
    </div>

    <!-- Minimap -->
    <canvas id="minimap" style="position:absolute;bottom:20px;left:20px;width:160px;height:160px;border-radius:50%;border:2px solid rgba(255,255,255,0.3);box-shadow:0 0 12px rgba(0,0,0,0.6);pointer-events:none;z-index:50;"></canvas>
    <div id="minimap-label" style="position:absolute;bottom:10px;left:50px;color:rgba(255,255,255,0.35);font-size:10px;pointer-events:none;z-index:50;letter-spacing:1px;">MAP</div>

    </div><!-- /hud-root -->

    <!-- Weather screen overlay (outside hud-root so storms still show on upgrade screen) -->
    <div id="weather-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;opacity:0;transition:opacity 1.5s;"></div>

    <!-- Achievement toast container -->
    <div id="achievement-toasts" style="position:absolute;top:20px;right:20px;display:flex;flex-direction:column;gap:8px;z-index:200;pointer-events:none;align-items:flex-end;"></div>

    <div id="start-screen" class="modal modal--start" style="overflow-y:auto;align-items:center;justify-content:flex-start;padding:30px 20px;z-index:1000;">
      <div style="width:100%;max-width:960px;margin:0 auto;">
        <h1 class="modal__title modal__title--lg" style="text-align:center;margin-bottom:4px;">üêæ CAPYBARA SURVIVOR</h1>
        <p class="modal__subtitle" style="text-align:center;margin-bottom:20px;">Survive waves of capybaras ‚Äî collect wood to reroll upgrades!</p>

        <!-- Skill preview banner -->
        <div id="start-skill-preview" style="display:none;margin-bottom:16px;background:rgba(241,196,15,0.12);border:1px solid rgba(241,196,15,0.35);border-radius:10px;padding:10px 20px;color:#f1c40f;font-size:14px;font-weight:700;text-align:center;"></div>

        <!-- Three columns: Mode | Difficulty | Leaderboard | Achievements -->
        <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:14px;margin-bottom:18px;">

          <!-- MODE -->
          <div style="background:rgba(0,0,0,0.45);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.1);">
            <div style="color:#fff;font-size:13px;font-weight:900;letter-spacing:1px;margin-bottom:12px;text-align:center;">üéÆ GAME MODE</div>
            <div id="mode-btns" style="display:flex;flex-direction:column;gap:8px;"></div>
          </div>

          <!-- DIFFICULTY -->
          <div style="background:rgba(0,0,0,0.45);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.1);">
            <div style="color:#fff;font-size:13px;font-weight:900;letter-spacing:1px;margin-bottom:12px;text-align:center;">‚öîÔ∏è DIFFICULTY</div>
            <div id="diff-btns" style="display:flex;flex-direction:column;gap:8px;"></div>
          </div>

          <!-- LEADERBOARD -->
          <div style="background:rgba(0,0,0,0.45);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.1);">
            <div style="color:#fff;font-size:13px;font-weight:900;letter-spacing:1px;margin-bottom:10px;text-align:center;">üèÜ LEADERBOARD</div>
            <div id="leaderboard-list" style="font-size:12px;"></div>
          </div>

          <!-- ACHIEVEMENTS -->
          <div style="background:rgba(0,0,0,0.45);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.1);overflow-y:auto;max-height:240px;">
            <div style="color:#fff;font-size:13px;font-weight:900;letter-spacing:1px;margin-bottom:10px;text-align:center;">üèÖ ACHIEVEMENTS</div>
            <div id="start-ach-list" style="font-size:11px;"></div>
          </div>
        </div>

        <!-- Challenge objective display (shown only in challenge mode) -->
        <div id="challenge-info" style="display:none;margin-bottom:16px;background:rgba(255,165,0,0.12);border:1px solid rgba(255,165,0,0.4);border-radius:10px;padding:12px 20px;text-align:center;">
          <div style="color:#ffa500;font-size:14px;font-weight:900;margin-bottom:4px;">üéØ CHALLENGE SELECTED</div>
          <div id="challenge-desc" style="color:rgba(255,255,255,0.7);font-size:13px;"></div>
        </div>

        <!-- Customization row: Player skin + Weapon skin -->
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-bottom:18px;">
          <div style="background:rgba(0,0,0,0.45);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.1);">
            <div style="color:#fff;font-size:13px;font-weight:900;letter-spacing:1px;margin-bottom:12px;text-align:center;">üé® PLAYER SKIN</div>
            <div id="skin-btns" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;"></div>
          </div>
          <div style="background:rgba(0,0,0,0.45);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.1);">
            <div style="color:#fff;font-size:13px;font-weight:900;letter-spacing:1px;margin-bottom:12px;text-align:center;">‚öîÔ∏è WEAPON SKIN</div>
            <div id="weapon-skin-btns" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;"></div>
          </div>
        </div>

        <div style="text-align:center;">
          <button id="start-button" class="btn">‚ñ∂ PLAY</button>
        </div>
      </div>
    </div>

    <!-- Game Over + Skill Tree Screen -->
    <div id="game-over-screen" class="modal modal--game-over" style="overflow-y:auto;padding:30px 0;align-items:flex-start;justify-content:flex-start;">
        <div style="width:100%;max-width:900px;margin:0 auto;padding:0 20px;">
            <h1 class="modal__title modal__title--xl" style="text-align:center;margin-bottom:6px;">GAME OVER</h1>
            <p id="wave-stats" class="modal__stat" style="text-align:center;"></p>
            <p id="kill-stats" class="modal__stat modal__stat--secondary" style="text-align:center;"></p>
            <p id="run-meta" style="text-align:center;color:rgba(255,255,255,0.45);font-size:14px;margin-bottom:4px;"></p>
            <p id="leaderboard-result" style="text-align:center;color:#f1c40f;font-size:15px;font-weight:700;margin-bottom:8px;"></p>
            <!-- Achievements earned this run -->
            <div id="run-achievements" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-bottom:16px;min-height:10px;"></div>
            <!-- Skill point award banner -->
            <div id="sp-award-banner" style="text-align:center;margin:10px 0 20px;padding:10px 20px;background:rgba(241,196,15,0.15);border:2px solid #f1c40f;border-radius:12px;">
                <span style="color:#f1c40f;font-size:22px;font-weight:900;">‚≠ê <span id="sp-awarded">0</span> SKILL POINTS EARNED</span>
                <span style="color:rgba(255,255,255,0.55);font-size:13px;display:block;margin-top:2px;">1 point per wave survived ¬∑ bonus for boss waves</span>
            </div>
            <!-- Skill tree header -->
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;">
                <h3 style="color:#fff;font-size:20px;font-family:'Arial Black',sans-serif;margin:0;">üå≥ SKILL TREE</h3>
                <span style="color:#f1c40f;font-size:18px;font-weight:700;">‚≠ê <span id="sp-remaining">0</span> points remaining</span>
            </div>
            <div id="skill-tree-grid" style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:24px;"></div>
            <div style="text-align:center;">
                <p id="skill-save-note" style="color:rgba(255,255,255,0.4);font-size:13px;margin-bottom:14px;">Upgrades persist across all future runs</p>
                <button id="play-again-btn" style="padding:16px 60px;font-size:26px;font-family:'Arial Black',sans-serif;background:#2196f3;border:none;border-radius:10px;cursor:pointer;color:#fff;box-shadow:0 6px 20px rgba(33,150,243,0.4);transition:transform 0.15s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">‚ñ∂ PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <!-- Upgrade Selection Screen -->
    <div id="upgrade-screen" class="upgrade-screen">
        <div class="upgrade-screen__header">
            <div id="upgrade-wave-badge" class="upgrade-screen__wave-badge">Wave 1 Complete</div>
            <h2 class="upgrade-screen__title">CHOOSE UPGRADE</h2>
            <p class="upgrade-screen__subtitle">Select one upgrade to power up your arsenal</p>
            <div style="display:flex;align-items:center;gap:14px;justify-content:center;margin-top:10px;">
                <span id="upgrade-wood-display" style="color:#8bc34a;font-size:16px;font-weight:700;text-shadow:1px 1px 4px rgba(0,0,0,0.8);">ü™µ 0 wood</span>
                <button id="reroll-btn" style="padding:8px 22px;font-size:14px;font-family:'Arial Black',sans-serif;background:rgba(139,195,74,0.25);border:2px solid #8bc34a;border-radius:8px;cursor:pointer;color:#8bc34a;font-weight:700;transition:all 0.15s;" onmouseover="this.style.background='rgba(139,195,74,0.45)'" onmouseout="this.style.background='rgba(139,195,74,0.25)'">
                    üîÑ Reroll <span id="reroll-cost-display">(15 ü™µ)</span>
                </button>
            </div>
        </div>
        <div id="upgrade-cards" class="upgrade-cards"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // =====================================================================
        // COIN SYSTEM
        // =====================================================================
        let coins = 0;

        function addCoins(amount) {
            coins += amount;
            document.getElementById('coin-display').innerText = `ü™ô ${coins}`;
            // Floating coin indicator
            const el = document.createElement('div');
            el.style.cssText = `position:absolute;bottom:260px;right:30px;color:#f1c40f;font-size:18px;font-weight:700;text-shadow:1px 1px 4px rgba(0,0,0,0.9);pointer-events:none;z-index:200;transition:opacity 0.5s,transform 0.5s;`;
            el.innerText = `+${amount} ü™ô`;
            document.body.appendChild(el);
            setTimeout(() => { el.style.opacity='0'; el.style.transform='translateY(-30px)'; setTimeout(()=>el.remove(),500); }, 600);
        }

        // =====================================================================
        // POWER-UP DROP SYSTEM
        // =====================================================================
        const activePowerUp = { type: null, endTime: 0, timer: null };
        const powerUpPickups = []; // 3D orbs in the world

        const POWER_UP_TYPES = [
            { id: 'speed',       label: '‚ö° Speed Boost',    color: 0x00eeff, duration: 6000,  dropChance: 0.18 },
            { id: 'damage',      label: 'üî• Damage Boost',   color: 0xff6600, duration: 8000,  dropChance: 0.15 },
            { id: 'invincible',  label: 'üõ°Ô∏è Invincibility',  color: 0xffdd00, duration: 5000,  dropChance: 0.10 },
            { id: 'ammo',        label: 'üéØ Ammo Refill',    color: 0x44ff88, duration: 0,     dropChance: 0.20 },
        ];

        function tryDropPowerUp(position) {
            const roll = Math.random();
            let cumulative = 0;
            let chosen = null;
            for(const p of POWER_UP_TYPES) {
                cumulative += p.dropChance + skillTree.powerDropBonus;
                if(roll < cumulative) { chosen = p; break; }
            }
            if(!chosen) return; // ~37% chance nothing drops

            const orb = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 10, 10),
                new THREE.MeshStandardMaterial({ color: chosen.color, emissive: chosen.color, emissiveIntensity: 0.6, roughness: 0.3 })
            );
            orb.position.copy(position);
            orb.position.y = 0.6;
            orb.userData.powerUpType = chosen;
            orb.userData.spawnTime = Date.now();
            scene.add(orb);
            powerUpPickups.push(orb);
        }

        function applyPowerUp(type) {
            // Clear existing
            if(activePowerUp.timer) clearTimeout(activePowerUp.timer);
            activePowerUp.type = type.id;
            activePowerUp.endTime = Date.now() + type.duration;

            const display = document.getElementById('powerup-display');
            document.getElementById('powerup-name').innerText = type.label;
            display.style.display = 'block';

            playSound(700, 0.2, 'sine', 0.12);
            setTimeout(() => playSound(900, 0.15, 'sine', 0.1), 100);

            if(type.id === 'ammo') {
                // Instant refill
                currentAmmo = maxMagSize;
                reserveAmmo = Math.min(reserveAmmo + 60, 300);
                currentArrows = maxArrows;
                currentSpears = maxSpears;
                updateAmmoDisplay();
                activePowerUp.type = null;
                display.style.display = 'none';
                return;
            }

            activePowerUp.timer = setTimeout(() => {
                activePowerUp.type = null;
                display.style.display = 'none';
            }, type.duration);
        }

        function updatePowerUps() {
            // Animate orbs and check pickup
            for(let i = powerUpPickups.length - 1; i >= 0; i--) {
                const orb = powerUpPickups[i];
                orb.position.y = 0.6 + Math.sin((Date.now() - orb.userData.spawnTime) * 0.003) * 0.2;
                orb.rotation.y += 0.04;
                // Expire after 12 seconds
                if(Date.now() - orb.userData.spawnTime > 12000) {
                    scene.remove(orb); powerUpPickups.splice(i, 1); continue;
                }
                // Pickup range
                if(player.position.distanceTo(orb.position) < 1.4) {
                    applyPowerUp(orb.userData.powerUpType);
                    scene.remove(orb); powerUpPickups.splice(i, 1);
                }
            }
            // Update power-up timer bar
            if(activePowerUp.type && activePowerUp.endTime > 0) {
                const pType = POWER_UP_TYPES.find(p => p.id === activePowerUp.type);
                if(pType && pType.duration > 0) {
                    const remaining = Math.max(0, activePowerUp.endTime - Date.now());
                    document.getElementById('powerup-bar').style.width = (remaining / pType.duration * 100) + '%';
                }
            }
        }

        function isPowerUpActive(id) { return activePowerUp.type === id; }

        // =====================================================================
        // PERSISTENT SKILL TREE (survives page reloads via localStorage)
        // =====================================================================
        const SKILL_NODES = [
            { id: 'maxhp',     icon: '‚ù§Ô∏è',  name: 'Iron Constitution', desc: '+25 Max HP per rank',        color:'#e74c3c', maxRank: 8,  cost: 1,
              apply(rank) { maxPlayerHealth = 100 + rank * 25; } },
            { id: 'startammo', icon: 'üî™',  name: 'Loaded Pockets',    desc: '+15 starting knives/rank',   color:'#c0c0c0', maxRank: 6,  cost: 1,
              apply(rank) { /* applied at game start */ } },
            { id: 'movespd',   icon: 'üëü',  name: 'Fleet Foot',        desc: '+8% move speed per rank',    color:'#3498db', maxRank: 5,  cost: 1,
              apply(rank) { skillTree.moveSpeedBonus = rank * 0.08; } },
            { id: 'reloadspd', icon: 'üîÑ',  name: 'Quick Hands',       desc: '15% faster reload per rank', color:'#2ecc71', maxRank: 5,  cost: 1,
              apply(rank) { skillTree.reloadSpeedBonus = rank * 0.15; } },
            { id: 'dmgall',    icon: '‚öîÔ∏è',  name: 'Battle Hardened',   desc: '+4 all damage per rank',     color:'#e67e22', maxRank: 10, cost: 1,
              apply(rank) { playerUpgrades.allDamageBonus = rank * 4; } },
            { id: 'healregen', icon: 'üíä',  name: 'Bloodthirsty',      desc: '+3 HP on kill per rank',     color:'#ff6b9d', maxRank: 6,  cost: 1,
              apply(rank) { skillTree.healPerKill = 5 + rank * 3; } },
            { id: 'woodperk',  icon: 'ü™µ',  name: 'Lumberjack',        desc: '+8 wood per kill per rank',  color:'#8b4513', maxRank: 5,  cost: 1,
              apply(rank) { skillTree.woodPerKill = 20 + rank * 8; } },
            { id: 'arrowcap',  icon: 'üèπ',  name: 'Fletching Master',  desc: '+8 max arrows per rank',     color:'#9b59b6', maxRank: 5,  cost: 1,
              apply(rank) { /* applied at game start */ } },
            { id: 'invdur',    icon: 'üõ°Ô∏è',  name: 'Shielded Soul',     desc: '+1s invincibility per rank', color:'#f1c40f', maxRank: 5,  cost: 2,
              apply(rank) { skillTree.invincibilityBonus = rank * 1000; } },
            { id: 'powerdrop', icon: 'üåü',  name: 'Lucky Drops',       desc: '+8% power-up drop chance/rank', color:'#00eeff', maxRank: 4, cost: 2,
              apply(rank) { skillTree.powerDropBonus = rank * 0.08; } },
            { id: 'coinbonus', icon: 'ü™ô',  name: 'Treasure Hunter',   desc: '+2 coins per kill per rank', color:'#f1c40f', maxRank: 6,  cost: 1,
              apply(rank) { skillTree.coinsPerKill = rank * 2; } },
            { id: 'startwood', icon: 'üå≤',  name: 'Prepared',          desc: '+30 starting wood per rank', color:'#4caf50', maxRank: 5,  cost: 1,
              apply(rank) { /* applied at game start */ } },

            // ‚îÄ‚îÄ NEW OFFENSE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            { id: 'knife_dmg',  icon: 'üó°Ô∏è',  name: 'Knife Specialist',  desc: '+10 knife damage per rank',   color:'#e0e0e0', maxRank: 6,  cost: 1,
              apply(rank) { playerUpgrades.knifeDamageBonus = rank * 10; } },
            { id: 'bow_dmg',    icon: 'üèπ',  name: 'Bowmaster',         desc: '+12 bow damage per rank',     color:'#9b59b6', maxRank: 6,  cost: 1,
              apply(rank) { playerUpgrades.bowDamageBonus = rank * 12; } },
            { id: 'spear_dmg',  icon: 'üèöÔ∏è',  name: 'Spear Expert',      desc: '+15 spear damage per rank',   color:'#16a085', maxRank: 5,  cost: 1,
              apply(rank) { playerUpgrades.spearDamageBonus = rank * 15; } },
            { id: 'axe_dmg',    icon: 'ü™ì',  name: 'Axe Crusher',       desc: '+20 axe damage per rank',     color:'#d35400', maxRank: 5,  cost: 1,
              apply(rank) { playerUpgrades.axeDamageBonus = rank * 20; } },
            { id: 'headhunter', icon: 'üíÄ',  name: 'Headhunter',        desc: '+0.5√ó headshot multiplier/rank', color:'#e74c3c', maxRank: 4, cost: 2,
              apply(rank) { skillTree.headshotMult = 2.0 + rank * 0.5; } },
            { id: 'magsize',    icon: 'üîÅ',  name: 'Expanded Mag',      desc: '+10 knife mag size per rank', color:'#95a5a6', maxRank: 4,  cost: 1,
              apply(rank) { maxMagSize = 30 + rank * 10; } },

            // ‚îÄ‚îÄ NEW DEFENSE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            { id: 'thick_hide', icon: 'ü¶è',  name: 'Thick Hide',        desc: '8% damage reduction per rank', color:'#7f8c8d', maxRank: 4, cost: 2,
              apply(rank) { skillTree.damageReduction = rank * 0.08; } },
            { id: 'laststand',  icon: '‚ö∞Ô∏è',  name: 'Last Stand',        desc: 'Survive a fatal hit once per run', color:'#ff0066', maxRank: 1, cost: 3,
              apply(rank) { skillTree.lastStandRanks = rank; } },
            { id: 'wallhp',     icon: 'üí•',  name: 'Shockwave',         desc: 'Killing an enemy slows all enemies nearby by 60% for 2s per rank (larger radius)', color:'#795548', maxRank: 4,  cost: 2,
              apply(rank) { skillTree.wallHPBonus = rank; } },

            // ‚îÄ‚îÄ NEW UTILITY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            { id: 'sprint_spd', icon: 'üí®',  name: 'Afterburner',       desc: '+12% sprint speed per rank',  color:'#1abc9c', maxRank: 4,  cost: 1,
              apply(rank) { skillTree.sprintBonus = rank * 0.12; } },
            { id: 'berserker',  icon: 'üò§',  name: 'Berserker',         desc: '+25% speed below 30% HP/rank', color:'#e74c3c', maxRank: 3, cost: 2,
              apply(rank) { skillTree.berserkerRanks = rank; } },
            { id: 'scavenger',  icon: 'üéí',  name: 'Scavenger',         desc: '+12 reserve ammo per kill/rank', color:'#f39c12', maxRank: 5, cost: 1,
              apply(rank) { skillTree.ammoPerKill = rank * 12; } },
            { id: 'spear_start',icon: 'üó∫Ô∏è',  name: 'Spear Cache',       desc: '+3 starting spears per rank', color:'#27ae60', maxRank: 4,  cost: 1,
              apply(rank) { skillTree.spearCountBonus = rank * 3; } },
            { id: 'jump',       icon: 'ü¶ò',  name: 'Spring Legs',       desc: '+25% jump height per rank',   color:'#3498db', maxRank: 4,  cost: 1,
              apply(rank) { skillTree.jumpHeightBonus = rank * 0.05; } },
        ];

        // Load saved skill ranks from localStorage
        function loadSkillRanks() {
            try { return JSON.parse(localStorage.getItem('capybara_skills') || '{}'); } catch(e) { return {}; }
        }
        function saveSkillRanks(ranks) {
            try { localStorage.setItem('capybara_skills', JSON.stringify(ranks)); } catch(e) {}
        }
        function loadSkillPoints() {
            try { return parseInt(localStorage.getItem('capybara_sp') || '0'); } catch(e) { return 0; }
        }
        function saveSkillPoints(sp) {
            try { localStorage.setItem('capybara_sp', String(sp)); } catch(e) {}
        }

        let savedRanks = loadSkillRanks();
        let availableSkillPoints = loadSkillPoints();

        // Apply all saved skill tree bonuses at startup
        function applyAllSkillBonuses() {
            SKILL_NODES.forEach(node => {
                const rank = savedRanks[node.id] || 0;
                if(rank > 0) node.apply(rank);
            });
            // Start-of-game stat overrides from skill tree
            const ammoRank = savedRanks['startammo'] || 0;
            currentAmmo = Math.min(maxMagSize + ammoRank * 15, maxMagSize);
            reserveAmmo = 90 + ammoRank * 15;
            const arrowRank = savedRanks['arrowcap'] || 0;
            maxArrows = 50 + arrowRank * 8;
            currentArrows = maxArrows;
            const woodRank = savedRanks['startwood'] || 0;
            wood = 30 + woodRank * 30;
            document.getElementById('mats').innerText = `ü™µ ${wood}`;
            document.getElementById('health-bar').style.width = '100%';
            // New nodes
            const magRank = savedRanks['magsize'] || 0;
            if(magRank > 0) { maxMagSize = 30 + magRank * 10; currentAmmo = Math.min(currentAmmo, maxMagSize); }
            currentSpears = Math.min(5 + skillTree.spearCountBonus, maxSpears);
            skillTree.lastStandUsed = false; // reset each run
        }

        // Render the skill tree grid in the game over screen
        function renderSkillTree() {
            document.getElementById('sp-remaining').innerText = availableSkillPoints;
            const grid = document.getElementById('skill-tree-grid');
            grid.innerHTML = '';
            SKILL_NODES.forEach(node => {
                const rank = savedRanks[node.id] || 0;
                const maxed = rank >= node.maxRank;
                const canAfford = availableSkillPoints >= node.cost;
                const card = document.createElement('div');
                card.style.cssText = `
                    background:rgba(255,255,255,0.06);border-radius:10px;padding:14px 12px 12px;
                    border:2px solid ${maxed ? 'rgba(255,255,255,0.15)' : canAfford ? node.color+'99' : 'rgba(255,255,255,0.1)'};
                    opacity:${maxed ? 0.5 : 1};cursor:${!maxed && canAfford ? 'pointer' : 'default'};
                    transition:transform 0.12s,box-shadow 0.12s;position:relative;
                `;
                // Rank pips
                let pips = '';
                for(let i = 0; i < node.maxRank; i++) {
                    pips += `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:3px;background:${i < rank ? node.color : 'rgba(255,255,255,0.15)'};"></span>`;
                }
                card.innerHTML = `
                    <div style="font-size:26px;margin-bottom:6px;">${node.icon}</div>
                    <div style="color:#fff;font-size:13px;font-weight:800;margin-bottom:4px;">${node.name}</div>
                    <div style="color:rgba(255,255,255,0.5);font-size:11px;line-height:1.4;margin-bottom:8px;">${node.desc}</div>
                    <div style="margin-bottom:8px;">${pips}</div>
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <span style="color:${node.color};font-size:12px;font-weight:700;">${maxed ? 'MAX' : `Rank ${rank}/${node.maxRank}`}</span>
                        <span style="color:#f1c40f;font-size:12px;font-weight:700;">${maxed ? '' : `‚≠ê ${node.cost}`}</span>
                    </div>
                `;
                if(!maxed && canAfford) {
                    card.addEventListener('mouseenter', () => { card.style.transform='translateY(-3px)'; card.style.boxShadow=`0 6px 20px ${node.color}44`; });
                    card.addEventListener('mouseleave', () => { card.style.transform=''; card.style.boxShadow=''; });
                    card.addEventListener('click', () => {
                        availableSkillPoints -= node.cost;
                        savedRanks[node.id] = (savedRanks[node.id] || 0) + 1;
                        saveSkillRanks(savedRanks);
                        saveSkillPoints(availableSkillPoints);
                        playSound(600, 0.15, 'sine', 0.12);
                        setTimeout(() => playSound(900, 0.12, 'sine', 0.08), 100);
                        renderSkillTree();
                    });
                }
                grid.appendChild(card);
            });
        }

        // Show the game over + skill tree screen
        function showGameOver(wavesCompleted, totalKills) {
            gameStarted = false;
            document.exitPointerLock();
            document.getElementById('hud-root').style.display = 'none';
            setMusicForState('stop');
            checkAchievements();

            // Add leaderboard entry and get rank
            const elapsed = Date.now() - runStartTime;
            addLeaderboardEntry(wavesCompleted, totalKills, activeMode, activeDifficulty, activeChallenge, elapsed);

            // Award skill points scaled by difficulty
            const dm = getDifficultyMult();
            const bossWaveBonus = Math.floor(wavesCompleted / 5);
            const earned = Math.round((wavesCompleted + bossWaveBonus) * dm.spGain);
            availableSkillPoints += earned;
            saveSkillPoints(availableSkillPoints);

            // Format run time
            const mins = Math.floor(elapsed/60000), secs = Math.floor((elapsed%60000)/1000);
            const timeStr = `${mins}m ${secs.toString().padStart(2,'0')}s`;

            document.getElementById('wave-stats').innerText = `Waves Completed: ${wavesCompleted}`;
            document.getElementById('kill-stats').innerText = `Total Eliminations: ${totalKills}`;
            const diffD = DIFFICULTIES[activeDifficulty]; const modeD = MODES[activeMode];
            const challengeD = CHALLENGES.find(c=>c.id===activeChallenge);
            let metaStr = `${diffD?.label||''} ¬∑ ${modeD?.label||''} ¬∑ ${timeStr}`;
            if(activeMode === 'challenge' && challengeD) metaStr += ` ¬∑ ${challengeD.label}`;
            document.getElementById('run-meta').innerText = metaStr;

            // Check leaderboard placement
            const lb = loadLeaderboard();
            const rank = lb.findIndex(e => e.waves===wavesCompleted && e.kills===totalKills && e.mode===activeMode && e.difficulty===activeDifficulty) + 1;
            const lbEl = document.getElementById('leaderboard-result');
            if(rank === 1) lbEl.innerText = 'ü•á NEW #1 RECORD!';
            else if(rank === 2) lbEl.innerText = 'ü•à 2nd Place!';
            else if(rank === 3) lbEl.innerText = 'ü•â 3rd Place!';
            else if(rank > 0 && rank <= 7) lbEl.innerText = `#${rank} on Leaderboard`;
            else lbEl.innerText = '';

            document.getElementById('sp-awarded').innerText = earned;

            // Show earned achievements
            const achContainer = document.getElementById('run-achievements');
            if (achContainer) {
                achContainer.innerHTML = '';
                ACHIEVEMENTS.filter(a => earnedAchievements.has(a.id)).forEach(a => {
                    const badge = document.createElement('div');
                    badge.title = a.desc;
                    badge.style.cssText = 'background:rgba(241,196,15,0.12);border:1px solid rgba(241,196,15,0.3);border-radius:8px;padding:6px 12px;display:flex;align-items:center;gap:6px;';
                    badge.innerHTML = `<span style="font-size:18px;">${a.icon}</span><span style="color:#fff;font-size:12px;font-weight:700;">${a.name}</span>`;
                    achContainer.appendChild(badge);
                });
                if (achContainer.children.length === 0) {
                    achContainer.innerHTML = '<span style="color:rgba(255,255,255,0.25);font-size:12px;">No achievements earned yet</span>';
                }
            }
            renderSkillTree();
            document.getElementById('game-over-screen').classList.add('is-visible');
        }

        document.getElementById('play-again-btn').addEventListener('click', () => {
            location.reload();
        });

        // =====================================================================
        // DIFFICULTY / MODE / CHALLENGE SYSTEM
        // =====================================================================
        const DIFFICULTIES = {
            easy:      { label:'üòä Easy',      color:'#4caf50', enemyHPMult:0.6,  enemySpeedMult:0.75, enemyDmgMult:0.5,  enemyCountMult:0.75, playerHPBonus:50,  spGain:0.5  },
            normal:    { label:'‚öîÔ∏è Normal',     color:'#2196f3', enemyHPMult:1.0,  enemySpeedMult:1.0,  enemyDmgMult:1.0,  enemyCountMult:1.0,  playerHPBonus:0,   spGain:1.0  },
            hard:      { label:'üíÄ Hard',       color:'#ff9800', enemyHPMult:1.5,  enemySpeedMult:1.3,  enemyDmgMult:1.5,  enemyCountMult:1.4,  playerHPBonus:-20, spGain:1.5  },
            nightmare: { label:'‚ò†Ô∏è Nightmare',  color:'#e53935', enemyHPMult:2.2,  enemySpeedMult:1.6,  enemyDmgMult:2.2,  enemyCountMult:2.0,  playerHPBonus:-40, spGain:2.0  }
        };
        const MODES = {
            normal:    { label:'üåä Normal',     desc:'Classic waves. Survive as long as you can.',          color:'#2196f3' },
            endless:   { label:'‚ôæÔ∏è Endless',    desc:'Waves never stop. How long can you last?',             color:'#9c27b0' },
            challenge: { label:'üéØ Challenge',  desc:'Special rules. Pick your challenge below.',           color:'#ff9800' }
        };
        const CHALLENGES = [
            { id:'melee',  label:'ü™ì Melee Only',    desc:'Only axe & knife allowed. Ranged weapons disabled.',       color:'#e53935' },
            { id:'glass',  label:'üîÆ Glass Cannon',  desc:'You have 1 HP but deal 4√ó damage. One hit = death.',       color:'#9c27b0' },
            { id:'speed',  label:'‚ö° Speed Run',     desc:'Enemies are 2√ó faster. Score is total enemies killed.',    color:'#ff9800' }
        ];

        let selectedDifficulty = localStorage.getItem('capybara_difficulty') || 'normal';
        let selectedMode       = localStorage.getItem('capybara_mode')       || 'normal';
        let selectedChallenge  = localStorage.getItem('capybara_challenge')  || 'melee';
        let activeDifficulty   = 'normal'; // set at game start
        let activeMode         = 'normal';
        let activeChallenge    = 'melee';
        let runStartTime       = 0;

        function savePref(key, val) { try { localStorage.setItem(key, val); } catch(e) {} }

        // =====================================================================
        // LEADERBOARD
        // =====================================================================
        function loadLeaderboard() {
            try { return JSON.parse(localStorage.getItem('capybara_lb') || '[]'); } catch(e) { return []; }
        }
        function saveLeaderboard(lb) {
            try { localStorage.setItem('capybara_lb', JSON.stringify(lb.slice(0,20))); } catch(e) {}
        }
        function addLeaderboardEntry(waves, kills, mode, difficulty, challenge, timeMs) {
            const lb = loadLeaderboard();
            lb.push({ waves, kills, mode, difficulty, challenge: mode==='challenge' ? challenge : null, time: timeMs, date: Date.now() });
            lb.sort((a,b) => b.waves - a.waves || b.kills - a.kills);
            saveLeaderboard(lb);
            // Return rank (1-based)
            return lb.findIndex(e => e.date === lb.find(x => x.waves===waves && x.kills===kills && x.date)?.date) + 1;
        }
        function renderLeaderboard() {
            const lb = loadLeaderboard();
            const el = document.getElementById('leaderboard-list');
            if(!el) return;
            if(lb.length === 0) { el.innerHTML = '<div style="color:rgba(255,255,255,0.35);text-align:center;margin-top:12px;">No runs yet.<br>Be the first!</div>'; return; }
            const top = lb.slice(0, 7);
            el.innerHTML = top.map((e, i) => {
                const medal = ['ü•á','ü•à','ü•â'][i] || `${i+1}.`;
                const modeD = MODES[e.mode] || MODES.normal;
                const diffD = DIFFICULTIES[e.difficulty] || DIFFICULTIES.normal;
                const mins = Math.floor((e.time||0)/60000), secs = Math.floor(((e.time||0)%60000)/1000);
                const timeStr = e.time ? `${mins}m${secs.toString().padStart(2,'0')}s` : '';
                return `<div style="display:flex;justify-content:space-between;align-items:center;padding:5px 0;border-bottom:1px solid rgba(255,255,255,0.07);">
                    <span style="color:${diffD.color};font-weight:700;font-size:13px;">${medal}</span>
                    <span style="color:#fff;font-size:12px;margin:0 6px;">W${e.waves} ¬∑ ${e.kills}üíÄ</span>
                    <span style="color:rgba(255,255,255,0.45);font-size:11px;">${modeD.label.split(' ')[0]} ${timeStr}</span>
                </div>`;
            }).join('');
        }

        // =====================================================================
        // =====================================================================
        // CHALLENGE CONSTRAINT HELPERS (checked at weapon-use time)
        // =====================================================================
        function isMeleeOnly() { return activeMode === 'challenge' && activeChallenge === 'melee'; }
        function isGlassCannon() { return activeMode === 'challenge' && activeChallenge === 'glass'; }

        // =====================================================================
        // BUILD START SCREEN UI
        // =====================================================================
        function buildStartScreenUI() {
            // Skill preview
            const totalRanks = Object.values(savedRanks).reduce((s,v) => s+v, 0);
            const preview = document.getElementById('start-skill-preview');
            if(preview && totalRanks > 0) { preview.style.display='block'; preview.innerText=`‚≠ê ${availableSkillPoints} skill points available ¬∑ ${totalRanks} skill ranks active`; }

            // --- Mode buttons ---
            const modeBtns = document.getElementById('mode-btns');
            if(modeBtns) {
                modeBtns.innerHTML = '';
                Object.entries(MODES).forEach(([key, m]) => {
                    const btn = document.createElement('button');
                    btn.dataset.key = key;
                    btn.style.cssText = `width:100%;padding:10px 12px;border-radius:8px;font-size:13px;font-family:'Arial Black',sans-serif;cursor:pointer;border:2px solid ${key===selectedMode ? m.color : 'rgba(255,255,255,0.15)'};background:${key===selectedMode ? m.color+'28' : 'rgba(0,0,0,0.3)'};color:${key===selectedMode ? m.color : 'rgba(255,255,255,0.65)'};text-align:left;transition:all 0.15s;`;
                    btn.innerHTML = `<div style="font-weight:900;">${m.label}</div><div style="font-size:11px;font-weight:400;opacity:0.7;margin-top:2px;">${m.desc}</div>`;
                    btn.addEventListener('click', () => {
                        selectedMode = key;
                        savePref('capybara_mode', key);
                        buildStartScreenUI();
                    });
                    modeBtns.appendChild(btn);
                });

                // Challenge sub-picker
                const challengeInfo = document.getElementById('challenge-info');
                const challengeDesc = document.getElementById('challenge-desc');
                if(selectedMode === 'challenge') {
                    challengeInfo.style.display = 'block';
                    // Challenge picker inside the mode panel
                    let sub = document.getElementById('challenge-sub');
                    if(!sub) { sub = document.createElement('div'); sub.id = 'challenge-sub'; modeBtns.appendChild(sub); }
                    sub.innerHTML = '';
                    CHALLENGES.forEach(c => {
                        const cbtn = document.createElement('button');
                        cbtn.style.cssText = `width:100%;padding:8px 10px;border-radius:6px;font-size:12px;font-family:'Arial Black',sans-serif;cursor:pointer;border:2px solid ${c.id===selectedChallenge ? c.color : 'rgba(255,255,255,0.1)'};background:${c.id===selectedChallenge ? c.color+'22' : 'rgba(0,0,0,0.2)'};color:${c.id===selectedChallenge ? c.color : 'rgba(255,255,255,0.5)'};text-align:left;margin-top:6px;`;
                        cbtn.innerHTML = `<span style="font-weight:900;">${c.label}</span><br><span style="font-size:10px;opacity:0.7;">${c.desc}</span>`;
                        cbtn.addEventListener('click', (e) => { e.stopPropagation(); selectedChallenge=c.id; savePref('capybara_challenge',c.id); buildStartScreenUI(); });
                        sub.appendChild(cbtn);
                    });
                    const sel = CHALLENGES.find(c=>c.id===selectedChallenge);
                    if(sel) challengeDesc.innerText = sel.desc;
                } else {
                    challengeInfo.style.display = 'none';
                }
            }

            // --- Difficulty buttons ---
            const diffBtns = document.getElementById('diff-btns');
            if(diffBtns) {
                diffBtns.innerHTML = '';
                Object.entries(DIFFICULTIES).forEach(([key, d]) => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width:100%;padding:10px 12px;border-radius:8px;font-size:13px;font-family:'Arial Black',sans-serif;cursor:pointer;border:2px solid ${key===selectedDifficulty ? d.color : 'rgba(255,255,255,0.15)'};background:${key===selectedDifficulty ? d.color+'28' : 'rgba(0,0,0,0.3)'};color:${key===selectedDifficulty ? d.color : 'rgba(255,255,255,0.65)'};text-align:left;transition:all 0.15s;`;
                    const diffs = { easy:'Slower enemies ¬∑ More HP ¬∑ Fewer foes', normal:'Balanced experience', hard:'Faster & harder enemies', nightmare:'Brutal. Good luck.' };
                    btn.innerHTML = `<span style="font-weight:900;">${d.label}</span><br><span style="font-size:11px;opacity:0.7;">${diffs[key]}</span>`;
                    btn.addEventListener('click', () => { selectedDifficulty=key; savePref('capybara_difficulty',key); buildStartScreenUI(); });
                    diffBtns.appendChild(btn);
                });
            }

            // --- Leaderboard ---
            renderLeaderboard();

            // --- Skin selectors (functions declared later, guard with typeof) ---
            if (typeof buildSkinUI === 'function') buildSkinUI();
            if (typeof buildWeaponSkinUI === 'function') buildWeaponSkinUI();

            // --- Achievements ---
            const achList = document.getElementById('start-ach-list');
            if (achList) {
                achList.innerHTML = '';
                ACHIEVEMENTS.forEach(a => {
                    const earned = earnedAchievements.has(a.id);
                    const row = document.createElement('div');
                    row.style.cssText = `display:flex;align-items:center;gap:6px;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.05);opacity:${earned ? '1' : '0.35'};`;
                    row.innerHTML = `<span style="font-size:16px;">${a.icon}</span><div><div style="color:${earned ? '#f1c40f' : '#fff'};font-weight:700;">${a.name}</div><div style="color:rgba(255,255,255,0.45);font-size:10px;">${a.desc}</div></div>`;
                    achList.appendChild(row);
                });
            }
        }

        // Achievements must be declared BEFORE buildStartScreenUI() so the panel renders correctly
        // Skins must also be declared here for the same reason (const in TDZ crashes buildSkinUI)
        const PLAYER_SKINS = [
            { id:'blue',    label:'Classic',   color:0x2196f3, head:0xffdbac, pants:0x2c3e50 },
            { id:'red',     label:'Crimson',   color:0xe74c3c, head:0xffdbac, pants:0x1a252f },
            { id:'green',   label:'Forest',    color:0x27ae60, head:0xffdbac, pants:0x1e3a1e },
            { id:'purple',  label:'Shadow',    color:0x8e44ad, head:0xcccccc, pants:0x2d1540 },
            { id:'gold',    label:'Gold',      color:0xf1c40f, head:0xffdbac, pants:0x7d6608 },
            { id:'black',   label:'Stealth',   color:0x222222, head:0x999999, pants:0x111111 },
            { id:'orange',  label:'Blaze',     color:0xe67e22, head:0xffdbac, pants:0x784212 },
            { id:'pink',    label:'Bubblegum', color:0xff69b4, head:0xffdbac, pants:0x8b1a5a },
        ];
        const WEAPON_SKINS = [
            { id:'default', label:'Normal',    bladeColor:0xc0c0c0, handleColor:0x3d2817, emissive:0x000000, glow:false },
            { id:'golden',  label:'ü•á Gold',   bladeColor:0xffd700, handleColor:0x8B6914, emissive:0x554400, glow:false },
            { id:'neon',    label:'‚ö° Neon',   bladeColor:0x00ffee, handleColor:0x004040, emissive:0x00aaaa, glow:true  },
            { id:'fire',    label:'üî• Fire',   bladeColor:0xff6600, handleColor:0x400000, emissive:0x661100, glow:true  },
            { id:'shadow',  label:'üëª Shadow', bladeColor:0x330066, handleColor:0x110022, emissive:0x220044, glow:false },
            { id:'crystal', label:'üíé Gem',    bladeColor:0x88eeff, handleColor:0x226688, emissive:0x004455, glow:true  },
        ];
        let selectedSkin    = (function(){ try { return localStorage.getItem('capybara_skin')   ||'blue';    } catch(e){ return 'blue';    } })();
        let selectedWepSkin = (function(){ try { return localStorage.getItem('capybara_wepskin')||'default'; } catch(e){ return 'default'; } })();

        // Achievements must be declared BEFORE buildStartScreenUI()
        const ACHIEVEMENTS = [
            { id:'first_blood',   icon:'ü©∏', name:'First Blood',      desc:'Kill your first capybara',              check: () => (typeof killCount!=='undefined') && killCount >= 1 },
            { id:'survivor',      icon:'üõ°Ô∏è', name:'Survivor',          desc:'Complete wave 5',                       check: () => (typeof currentWave!=='undefined') && currentWave > 5 },
            { id:'warlord',       icon:'‚öîÔ∏è', name:'Warlord',           desc:'Complete wave 10',                      check: () => (typeof currentWave!=='undefined') && currentWave > 10 },
            { id:'legend',        icon:'üëë', name:'Legend',            desc:'Complete wave 20',                      check: () => (typeof currentWave!=='undefined') && currentWave > 20 },
            { id:'headhunter',    icon:'üéØ', name:'Headhunter',        desc:'Land 10 headshots in one run',          check: () => (window._headshotsThisRun||0) >= 10 },
            { id:'sniper',        icon:'üèπ', name:'Sniper',            desc:'Land 25 headshots in one run',          check: () => (window._headshotsThisRun||0) >= 25 },
            { id:'lumberjack',    icon:'ü™µ', name:'Lumberjack',        desc:'Collect 500 wood in one run',           check: () => (typeof wood!=='undefined') && wood >= 500 },
            { id:'boss_slayer',   icon:'üíÄ', name:'Boss Slayer',       desc:'Kill your first boss',                  check: () => (window._bossesKilled||0) >= 1 },
            { id:'exterminator',  icon:'üê≠', name:'Exterminator',      desc:'Kill 100 capybaras in one run',         check: () => (typeof killCount!=='undefined') && killCount >= 100 },
            { id:'untouchable',   icon:'‚ú®', name:'Untouchable',       desc:'Complete a wave without taking damage', check: () => (window._wavesWithoutDamage||0) >= 1 },
            { id:'nightmare_run', icon:'‚ò†Ô∏è', name:'Nightmare Runner',  desc:'Complete wave 5 on Nightmare',         check: () => (typeof activeDifficulty!=='undefined') && activeDifficulty==='nightmare' && (typeof currentWave!=='undefined') && currentWave > 5 },
            { id:'glass_wave5',   icon:'üîÆ', name:'Glass Legend',      desc:'Complete wave 5 as Glass Cannon',      check: () => (typeof isGlassCannon==='function') && isGlassCannon() && (typeof currentWave!=='undefined') && currentWave > 5 },
        ];
        let earnedAchievements = new Set();
        try { earnedAchievements = new Set(JSON.parse(localStorage.getItem('capybara_ach')||'[]')); } catch(e) {}
        function saveAchievements() { try { localStorage.setItem('capybara_ach', JSON.stringify([...earnedAchievements])); } catch(e) {} }

        buildStartScreenUI();

        // =====================================================================
        // SHOP SYSTEM (removed - replaced by post-death skill tree)
        // =====================================================================
        let shopScreenOpen = false; // kept for mousedown guard compatibility

        function getEffectiveReloadTime() { return 2000 * (1 - skillTree.reloadSpeedBonus); }
        function getEffectiveMoveSpeed() { return 0.15 * (1 + skillTree.moveSpeedBonus); }

        // =====================================================================
        // RUNTIME STATE (overridden by skill tree on start)
        // =====================================================================
        let maxPlayerHealth = 100;
        const skillTree = {
            reloadSpeedBonus: 0,
            moveSpeedBonus: 0,
            woodPerKill: 20,
            healPerKill: 5,
            coinsPerKill: 0,
            invincibilityBonus: 0,
            powerDropBonus: 0,
            // new fields
            damageReduction: 0,
            berserkerRanks: 0,
            headshotMult: 2.0,
            ammoPerKill: 0,
            wallHPBonus: 0,
            sprintBonus: 0,
            lastStandUsed: false,
            lastStandRanks: 0,
            spearCountBonus: 0,
            jumpHeightBonus: 0,
        };

        // Current player upgrade stats (multipliers/bonuses on top of base values)
        const playerUpgrades = {
            knifeDamageBonus: 0,
            bowDamageBonus: 0,
            spearDamageBonus: 0,
            axeDamageBonus: 0,
            allDamageBonus: 0,
            fireRateBonus: 0,
            bowChargeSpeedBonus: 0,
            rangeBonus: 0,
        };

        // Track upgrade history for the tracker HUD
        const upgradeHistory = [];

        // Rarity definitions: { weight, color class, label }
        const RARITIES = {
            common:    { weight: 50, cssClass: 'upgrade-card--common',    label: 'Common',    starColor: '#aaaaaa' },
            uncommon:  { weight: 28, cssClass: 'upgrade-card--uncommon',  label: 'Uncommon',  starColor: '#1ec850' },
            rare:      { weight: 14, cssClass: 'upgrade-card--rare',      label: 'Rare',      starColor: '#3c82ff' },
            epic:      { weight: 6,  cssClass: 'upgrade-card--epic',      label: 'Epic',      starColor: '#b43cff' },
            legendary: { weight: 2,  cssClass: 'upgrade-card--legendary', label: 'Legendary', starColor: '#ffa500' },
        };

        // Upgrade template definitions
        // Each entry: { type, icon, name, desc, getRarity, apply }
        // getRarity returns one key of RARITIES; apply mutates playerUpgrades and returns display string
        const UPGRADE_POOL = [
            // ---- DAMAGE UPGRADES ----
            {
                type: 'damage',
                icon: 'üó°Ô∏è',
                name: 'Knife Edge',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 2, uncommon: 4, rare: 6, epic: 10, legendary: 16 }[r];
                    return { rarity: r, bonus, desc: `Your thrown knives hit harder.`, bonusText: `+${bonus} Knife Damage` };
                },
                apply(variant) { playerUpgrades.knifeDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'üèπ',
                name: 'Eagle Eye',
                applies: 'Bow',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 3, uncommon: 6, rare: 10, epic: 16, legendary: 25 }[r];
                    return { rarity: r, bonus, desc: `Arrows pierce deeper on impact.`, bonusText: `+${bonus} Arrow Damage` };
                },
                apply(variant) { playerUpgrades.bowDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'üî±',
                name: 'Iron Tip',
                applies: 'Spear',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 4, uncommon: 8, rare: 14, epic: 22, legendary: 35 }[r];
                    return { rarity: r, bonus, desc: `Forged tip tears through thick fur.`, bonusText: `+${bonus} Spear Damage` };
                },
                apply(variant) { playerUpgrades.spearDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'ü™ì',
                name: 'Whetstone',
                applies: 'Axe',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 5, uncommon: 10, rare: 18, epic: 28, legendary: 45 }[r];
                    return { rarity: r, bonus, desc: `A finely honed axe leaves no survivors.`, bonusText: `+${bonus} Axe Damage` };
                },
                apply(variant) { playerUpgrades.axeDamageBonus += variant.bonus; }
            },
            {
                type: 'damage',
                icon: 'üí•',
                name: 'Bloodlust',
                applies: 'All Weapons',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 2, uncommon: 4, rare: 7, epic: 11, legendary: 18 }[r];
                    return { rarity: r, bonus, desc: `Raw power surges through every strike.`, bonusText: `+${bonus} All Damage` };
                },
                apply(variant) { playerUpgrades.allDamageBonus += variant.bonus; }
            },
            // ---- FIRE RATE UPGRADES ----
            {
                type: 'firerate',
                icon: '‚ö°',
                name: 'Quick Draw',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const pct = { common: 5, uncommon: 10, rare: 16, epic: 22, legendary: 32 }[r];
                    return { rarity: r, bonus: pct, desc: `Muscle memory speeds up your throw cycle.`, bonusText: `-${pct}% Knife Cooldown` };
                },
                apply(variant) { playerUpgrades.fireRateBonus = Math.min(0.85, playerUpgrades.fireRateBonus + variant.bonus / 100); }
            },
            {
                type: 'firerate',
                icon: 'üåÄ',
                name: 'Rapid Nock',
                applies: 'Bow',
                getVariant() {
                    const r = rollRarity();
                    const pct = { common: 5, uncommon: 10, rare: 16, epic: 22, legendary: 32 }[r];
                    return { rarity: r, bonus: pct, desc: `Train yourself to draw the bow with practiced speed.`, bonusText: `-${pct}% Bow Charge Time` };
                },
                apply(variant) { playerUpgrades.bowChargeSpeedBonus = Math.min(0.85, playerUpgrades.bowChargeSpeedBonus + variant.bonus / 100); }
            },
            {
                type: 'firerate',
                icon: 'üî•',
                name: 'Berserker',
                applies: 'All Weapons',
                getVariant() {
                    const r = rollRarity();
                    const pct = { common: 4, uncommon: 8, rare: 13, epic: 20, legendary: 30 }[r];
                    return { rarity: r, bonus: pct, desc: `Fury takes over ‚Äî every weapon feels lighter.`, bonusText: `-${pct}% All Cooldowns` };
                },
                apply(variant) {
                    playerUpgrades.fireRateBonus = Math.min(0.85, playerUpgrades.fireRateBonus + variant.bonus / 100);
                    playerUpgrades.bowChargeSpeedBonus = Math.min(0.85, playerUpgrades.bowChargeSpeedBonus + variant.bonus / 100);
                }
            },
            // ---- RANGE UPGRADES ----
            {
                type: 'range',
                icon: 'üéØ',
                name: 'Far Reach',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 15, uncommon: 25, rare: 40, epic: 60, legendary: 90 }[r];
                    return { rarity: r, bonus, desc: `Honed aerodynamics let the blade fly further.`, bonusText: `+${bonus} Knife Range` };
                },
                apply(variant) { playerUpgrades.rangeBonus += variant.bonus; }
            },
            {
                type: 'range',
                icon: 'üèîÔ∏è',
                name: 'Long Shot',
                applies: 'Bow',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 15, uncommon: 30, rare: 50, epic: 75, legendary: 110 }[r];
                    return { rarity: r, bonus, desc: `Limb tension launches arrows into the distance.`, bonusText: `+${bonus} Arrow Range` };
                },
                apply(variant) { playerUpgrades.rangeBonus += variant.bonus; }
            },
            {
                type: 'range',
                icon: 'üåä',
                name: 'Javelin',
                applies: 'Spear',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 15, uncommon: 28, rare: 45, epic: 68, legendary: 100 }[r];
                    return { rarity: r, bonus, desc: `A rebalanced shaft carries the spear farther.`, bonusText: `+${bonus} Spear Range` };
                },
                apply(variant) { playerUpgrades.rangeBonus += variant.bonus; }
            },
            {
                type: 'capacity',
                icon: 'üî™',
                name: 'Knife Pouch',
                applies: 'Knife',
                getVariant() {
                    const r = rollRarity();
                    const bonus = { common: 3, uncommon: 6, rare: 10, epic: 16, legendary: 25 }[r];
                    return { rarity: r, bonus, desc: `A larger pouch lets you carry more throwing knives before reloading.`, bonusText: `+${bonus} Knife Capacity` };
                },
                apply(variant) {
                    maxMagSize += variant.bonus;
                    currentAmmo = Math.min(currentAmmo + variant.bonus, maxMagSize);
                    updateAmmoDisplay();
                }
            },
        ];

        function rollRarity() {
            const total = Object.values(RARITIES).reduce((s, r) => s + r.weight, 0);
            let rand = Math.random() * total;
            for (const [key, r] of Object.entries(RARITIES)) {
                rand -= r.weight;
                if (rand <= 0) return key;
            }
            return 'common';
        }

        function pickThreeUpgrades() {
            // Shuffle pool and pick 3 different upgrade templates, generate their variants
            const shuffled = [...UPGRADE_POOL].sort(() => Math.random() - 0.5);
            const picks = [];
            const usedTypes = new Set();
            for (const template of shuffled) {
                if (picks.length >= 3) break;
                // Allow duplicates of same type only if pool is thin
                if (!usedTypes.has(template.name)) {
                    usedTypes.add(template.name);
                    const variant = template.getVariant();
                    picks.push({ template, variant });
                }
            }
            // Pad if needed
            while (picks.length < 3) {
                const t = UPGRADE_POOL[Math.floor(Math.random() * UPGRADE_POOL.length)];
                const variant = t.getVariant();
                picks.push({ template: t, variant });
            }
            return picks;
        }

        let upgradeScreenOpen = false;
        let rerollCount = 0; // resets each wave, cost escalates

        function getRerollCost() {
            return 15 + rerollCount * 10; // 15, 25, 35, 45...
        }

        function showUpgradeScreen(waveCompleted) {
            upgradeScreenOpen = true;
            rerollCount = 0; // reset reroll count for this wave
            const screen = document.getElementById('upgrade-screen');
            document.getElementById('upgrade-wave-badge').textContent = `Wave ${waveCompleted} Complete`;

            // Wire reroll button (add listener once, replace each call via renderCards)
            const rerollBtn = document.getElementById('reroll-btn');
            rerollBtn.onclick = () => {
                const cost = getRerollCost();
                if(wood < cost) {
                    // Flash red briefly
                    rerollBtn.style.borderColor = '#e74c3c';
                    rerollBtn.style.color = '#e74c3c';
                    setTimeout(() => { rerollBtn.style.borderColor='#8bc34a'; rerollBtn.style.color='#8bc34a'; }, 400);
                    return;
                }
                wood -= cost;
                rerollCount++;
                document.getElementById('mats').innerText = `ü™µ ${wood}`;
                playSound(300, 0.08, 'sine', 0.08);
                renderUpgradeCards();
            };

            screen.classList.add('is-visible');
            if(document.pointerLockElement) document.exitPointerLock();
            renderUpgradeCards();
        }

        function renderUpgradeCards() {
            const cost = getRerollCost();
            const canAfford = wood >= cost;
            const rerollBtn = document.getElementById('reroll-btn');
            document.getElementById('upgrade-wood-display').innerText = `ü™µ ${wood} wood`;
            document.getElementById('reroll-cost-display').innerText = `(${cost} ü™µ)`;
            rerollBtn.style.opacity = canAfford ? '1' : '0.45';
            rerollBtn.style.cursor = canAfford ? 'pointer' : 'default';

            const cards = document.getElementById('upgrade-cards');
            cards.innerHTML = '';
            const options = pickThreeUpgrades();
            options.forEach(({ template, variant }) => {
                const rarity = RARITIES[variant.rarity];
                const card = document.createElement('div');
                card.className = `upgrade-card ${rarity.cssClass}`;
                card.innerHTML = `
                    <div class="upgrade-card__rarity-bar"></div>
                    <span class="upgrade-card__icon">${template.icon}</span>
                    <div class="upgrade-card__rarity-label">${rarity.label}</div>
                    <div class="upgrade-card__name">${template.name}</div>
                    <p class="upgrade-card__desc">${variant.desc}</p>
                    <div class="upgrade-card__bonus">
                        <span class="upgrade-card__bonus-icon">‚ú¶</span>
                        <span>${variant.bonusText}</span>
                    </div>
                    <div class="upgrade-card__applies">${template.applies}</div>
                `;
                card.addEventListener('click', () => {
                    template.apply(variant);
                    upgradeHistory.push({ icon: template.icon, name: template.name, bonus: variant.bonusText, rarity: variant.rarity });
                    updateUpgradeTracker();
                    playSound(600, 0.15, 'sine', 0.12);
                    setTimeout(() => playSound(900, 0.2, 'sine', 0.1), 120);
                    closeUpgradeScreen();
                });
                cards.appendChild(card);
            });
        }

        function closeUpgradeScreen() {
            upgradeScreenOpen = false;
            const screen = document.getElementById('upgrade-screen');
            screen.style.animation = 'upgradeScreenOut 0.25s ease forwards';
            setTimeout(() => {
                screen.classList.remove('is-visible');
                screen.style.animation = '';
                spawnNextWave();
                document.body.requestPointerLock();
            }, 250);
        }

        function updateUpgradeTracker() {
            if (upgradeHistory.length === 0) return;
            const tracker = document.getElementById('upgrade-tracker');
            tracker.classList.add('is-visible');
            const itemsEl = document.getElementById('upgrade-tracker-items');
            itemsEl.innerHTML = '';
            // Show last 4 upgrades
            const recent = upgradeHistory.slice(-4);
            recent.forEach(u => {
                const item = document.createElement('div');
                item.className = 'upgrade-tracker__item';
                item.innerHTML = `<span>${u.icon} ${u.name}</span><span>${u.bonus}</span>`;
                itemsEl.appendChild(item);
            });
        }

        // This will be called after upgrade is selected to spawn enemies
        let pendingWaveSpawn = false;
        let pendingWaveSize = 0;
        function spawnNextWave() {
            const isSwarm = !!window._isSwarmWave;
            for(let i = 0; i < pendingWaveSize; i++) {
                spawnEnemy(isSwarm);
                if (Math.random() < 0.25) setTimeout(() => capybaraAggroSound(), Math.random() * 1500);
            }
            pendingWaveSpawn = false;
            setMusicForState('intense');
        }

        // Helper to get effective fire rate (lower = faster)
        function getEffectiveFireRate() {
            return fireRate * (1 - playerUpgrades.fireRateBonus);
        }

        // Helper to get effective bow charge max
        function getEffectiveBowChargeMax() {
            return BOW_CHARGE_MAX_MS * (1 - playerUpgrades.bowChargeSpeedBonus);
        }

        // Helper: damage with upgrades applied
        function getDamage(base, type) {
            let bonus = playerUpgrades.allDamageBonus;
            if (type === 'knife')  bonus += playerUpgrades.knifeDamageBonus;
            if (type === 'bow')    bonus += playerUpgrades.bowDamageBonus;
            if (type === 'spear')  bonus += playerUpgrades.spearDamageBonus;
            if (type === 'axe')    bonus += playerUpgrades.axeDamageBonus;
            const powerMult = isPowerUpActive('damage') ? 2.0 : 1.0;
            const glassMult = isGlassCannon() ? 4.0 : 1.0;
            return (base + bonus) * powerMult * glassMult;
        }

        // Helper: range bonus in bullet life frames
        function getRangeBonus() {
            return playerUpgrades.rangeBonus;
        }

        // =====================================================================
        // Sound System
        // =====================================================================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }
        
        function shootSound() {
            playSound(300, 0.1, 'square', 0.08);
            setTimeout(() => playSound(150, 0.05, 'square', 0.06), 50);
        }
        function hitSound() { playSound(100, 0.1, 'triangle', 0.12); }
        function damageSound() { playSound(80, 0.2, 'sawtooth', 0.12); }
        function reloadSound() {
            playSound(400, 0.1, 'sine', 0.08);
            setTimeout(() => playSound(600, 0.15, 'sine', 0.08), 150);
        }
        
        let lastFootstepTime = 0;
        function footstepSound(isSprinting) {
            const now = Date.now();
            const footstepInterval = isSprinting ? 300 : 450;
            if(now - lastFootstepTime > footstepInterval) {
                playSound(isSprinting ? 180 : 150, 0.08, 'sine', 0.05);
                lastFootstepTime = now;
            }
        }

        // =====================================================================
        // PARTICLE SYSTEM ‚Äî dust clouds & explosions
        // =====================================================================
        const particles = [];

        function spawnParticles(pos, count, opts = {}) {
            for (let i = 0; i < count; i++) {
                const size  = opts.size  || (0.08 + Math.random() * 0.18);
                const color = opts.color || 0xbb8855;
                const speed = opts.speed || 0.06;
                const life  = opts.life  || 35;
                const geom  = new THREE.SphereGeometry(size, 5, 5);
                const mat   = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.85 });
                const mesh  = new THREE.Mesh(geom, mat);
                mesh.position.copy(pos).add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.6,
                    (Math.random() - 0.5) * 0.5
                ));
                const angle = Math.random() * Math.PI * 2;
                const upward = opts.explode ? (0.08 + Math.random() * 0.12) : (Math.random() * 0.04);
                mesh.userData.vel = new THREE.Vector3(
                    Math.cos(angle) * speed * (0.5 + Math.random()),
                    upward,
                    Math.sin(angle) * speed * (0.5 + Math.random())
                );
                mesh.userData.life     = life + Math.floor(Math.random() * 15);
                mesh.userData.maxLife  = mesh.userData.life;
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function spawnExplosionParticles(pos) {
            // Fire/orange burst
            spawnParticles(pos, 22, { color: 0xff6600, size: 0.18, speed: 0.14, life: 28, explode: true });
            // Smoke puffs ‚Äî grey, slower
            spawnParticles(pos, 14, { color: 0x888888, size: 0.25, speed: 0.06, life: 50 });
            // Sparks ‚Äî bright yellow, fast
            spawnParticles(pos, 18, { color: 0xffee44, size: 0.07, speed: 0.22, life: 18, explode: true });
        }

        function spawnDustParticles(pos) {
            spawnParticles(pos, 6, { color: 0xbbaa88, size: 0.12, speed: 0.035, life: 40 });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.vel.y -= 0.003; // gravity
                p.position.add(p.userData.vel);
                p.userData.vel.multiplyScalar(0.94); // drag
                p.userData.life--;
                p.material.opacity = (p.userData.life / p.userData.maxLife) * 0.85;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        // =====================================================================
        // RAGDOLL DEATH ANIMATIONS
        // =====================================================================
        const ragdolls = [];

        function spawnRagdoll(en) {
            // Detach the capybara mesh from enemies array and animate it flying/tumbling
            const rd = {
                group: en,
                vel: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.18,
                    0.22 + Math.random() * 0.12,
                    (Math.random() - 0.5) * 0.18
                ),
                rotVel: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.22,
                    (Math.random() - 0.5) * 0.18,
                    0.15 + Math.random() * 0.25
                ),
                life: 55,
                maxLife: 55
            };
            // Tint red briefly
            en.traverse(c => {
                if (c.isMesh && c.material) {
                    c.material = c.material.clone();
                    c.material.color.set(0xff3300);
                }
            });
            ragdolls.push(rd);
        }

        function updateRagdolls() {
            for (let i = ragdolls.length - 1; i >= 0; i--) {
                const rd = ragdolls[i];
                rd.vel.y -= 0.018; // gravity
                rd.group.position.add(rd.vel);
                rd.vel.multiplyScalar(0.88);
                rd.group.rotation.x += rd.rotVel.x;
                rd.group.rotation.y += rd.rotVel.y;
                rd.group.rotation.z += rd.rotVel.z;
                rd.rotVel.multiplyScalar(0.9);
                rd.life--;
                // Fade out
                const alpha = rd.life / rd.maxLife;
                rd.group.traverse(c => {
                    if (c.isMesh && c.material) c.material.opacity = alpha;
                    if (c.isMesh && c.material) c.material.transparent = true;
                });
                if (rd.life <= 0) {
                    scene.remove(rd.group);
                    ragdolls.splice(i, 1);
                }
            }
        }

        // =====================================================================
        // MINIMAP
        // =====================================================================
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx    = minimapCanvas ? minimapCanvas.getContext('2d') : null;
        minimapCanvas.width  = 160;
        minimapCanvas.height = 160;
        const MINIMAP_RADIUS = 160 / 2;   // px radius of the circular map
        const MINIMAP_RANGE  = 90;         // world-units visible radius

        function updateMinimap() {
            if (!minimapCtx || !gameStarted) return;
            const ctx = minimapCtx;
            const W = minimapCanvas.width, H = minimapCanvas.height;
            const cx = W / 2, cy = H / 2;

            // Dark background circle
            ctx.clearRect(0, 0, W, H);
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, MINIMAP_RADIUS, 0, Math.PI * 2);
            ctx.clip();

            ctx.fillStyle = 'rgba(0,0,0,0.72)';
            ctx.fillRect(0, 0, W, H);

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let g = -MINIMAP_RANGE; g <= MINIMAP_RANGE; g += 20) {
                const gx = cx + (g / MINIMAP_RANGE) * MINIMAP_RADIUS;
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, H); ctx.stroke();
                const gy = cy + (g / MINIMAP_RANGE) * MINIMAP_RADIUS;
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(W, gy); ctx.stroke();
            }

            // Convert world pos to minimap px, rotated to face player direction
            const yaw = player.rotation.y;
            function worldToMM(wx, wz) {
                const dx = wx - player.position.x;
                const dz = wz - player.position.z;
                // Rotate so player always faces up
                const rx =  dx * Math.cos(-yaw) - dz * Math.sin(-yaw);
                const rz =  dx * Math.sin(-yaw) + dz * Math.cos(-yaw);
                return {
                    x: cx + (rx / MINIMAP_RANGE) * MINIMAP_RADIUS,
                    y: cy + (rz / MINIMAP_RANGE) * MINIMAP_RADIUS
                };
            }

            // Draw water zones as blue blobs
            for (const zone of waterZonesList) {
                const mm = worldToMM(zone.x, zone.z);
                const r  = Math.max(2, (zone.r / MINIMAP_RANGE) * MINIMAP_RADIUS);
                ctx.beginPath();
                ctx.arc(mm.x, mm.y, r, 0, Math.PI * 2);
                ctx.fillStyle = zone.ice ? 'rgba(160,220,255,0.35)' : 'rgba(30,100,200,0.35)';
                ctx.fill();
            }

            // Draw trees as tiny green dots
            for (const tree of trees) {
                const mm = worldToMM(tree.position.x, tree.position.z);
                if (mm.x < 0 || mm.x > W || mm.y < 0 || mm.y > H) continue;
                ctx.beginPath();
                ctx.arc(mm.x, mm.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(60,160,60,0.7)';
                ctx.fill();
            }

            // Draw enemies ‚Äî red dots, bosses are bigger
            for (const en of enemies) {
                const mm = worldToMM(en.position.x, en.position.z);
                const r  = en.userData.isBoss ? 5 : 3;
                ctx.beginPath();
                ctx.arc(mm.x, mm.y, r, 0, Math.PI * 2);
                ctx.fillStyle = en.userData.isBoss     ? '#ff6600'
                              : en.userData.enemyType === 'armored' ? '#aaaaff'
                              : en.userData.enemyType === 'healer'  ? '#00ee88'
                              : en.userData.enemyType === 'ranged'  ? '#ffcc44'
                              : '#ff3333';
                ctx.fill();
                // Pulse ring on boss
                if (en.userData.isBoss) {
                    ctx.beginPath();
                    ctx.arc(mm.x, mm.y, r + 3 + Math.sin(Date.now() * 0.005) * 2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255,100,0,0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }

            // Draw power-up drops as yellow stars
            for (const pu of powerUpPickups) {
                const mm = worldToMM(pu.position.x, pu.position.z);
                ctx.beginPath();
                ctx.arc(mm.x, mm.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#f1c40f';
                ctx.fill();
            }

            // Draw player ‚Äî white arrow triangle pointing up (always center)
            ctx.save();
            ctx.translate(cx, cy);
            ctx.beginPath();
            ctx.moveTo(0, -7);
            ctx.lineTo(5, 6);
            ctx.lineTo(0, 3);
            ctx.lineTo(-5, 6);
            ctx.closePath();
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.restore();

            // Outer vignette
            const grad = ctx.createRadialGradient(cx, cy, MINIMAP_RADIUS * 0.65, cx, cy, MINIMAP_RADIUS);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            ctx.restore();

            // Compass labels
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.font = 'bold 9px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('N', cx, 11);
            ctx.fillText('S', cx, H - 3);
            ctx.fillText('W', 7, cy + 4);
            ctx.fillText('E', W - 6, cy + 4);
        }

        // =====================================================================
        // SOUND VARIETY ‚Äî capybara calls + ambient nature
        // =====================================================================
        // Synthesise a "capybara grunt" ‚Äî short burst of descending noise
        function capybaraDeathSound() {
            // Layered descending squeal
            [280, 210, 160].forEach((f, i) => {
                setTimeout(() => playSound(f, 0.18, 'sawtooth', 0.09 - i * 0.02), i * 55);
            });
        }
        function capybaraAggroSound() {
            playSound(320, 0.12, 'sawtooth', 0.06);
            setTimeout(() => playSound(260, 0.1, 'sawtooth', 0.04), 70);
        }
        function capybaraBossRoar() {
            [180, 130, 100, 80].forEach((f, i) => {
                setTimeout(() => playSound(f, 0.35, 'sawtooth', 0.13 - i * 0.02), i * 90);
            });
        }

        // Ambient nature sounds ‚Äî birds, wind, water burbles
        let ambientIntervalId = null;
        let lastAmbientBiome  = null;

        function playBirdChirp() {
            const notes = [800, 1000, 900, 1100, 850];
            notes.forEach((f, i) => setTimeout(() => playSound(f, 0.08, 'sine', 0.025), i * 110 + Math.random() * 80));
        }
        function playWindGust() {
            // White-noise approximation: rapid random frequencies
            for (let i = 0; i < 6; i++) {
                setTimeout(() => playSound(80 + Math.random() * 40, 0.3, 'sawtooth', 0.018), i * 60);
            }
        }
        function playWaterBurble() {
            for (let i = 0; i < 4; i++) {
                setTimeout(() => playSound(500 + Math.random() * 200, 0.07, 'sine', 0.02), i * 80);
            }
        }
        function playSnowWind() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => playSound(60 + Math.random() * 30, 0.4, 'sawtooth', 0.015), i * 80);
            }
        }

        function startAmbientSounds() {
            if (ambientIntervalId) clearInterval(ambientIntervalId);
            ambientIntervalId = setInterval(() => {
                if (!gameStarted) return;
                const biome = currentBiome || 'forest';
                if (biome === 'forest') {
                    if (Math.random() < 0.55) playBirdChirp();
                    else playWindGust();
                } else if (biome === 'desert') {
                    playWindGust();
                } else if (biome === 'snow') {
                    if (Math.random() < 0.4) playSnowWind();
                }
                if (biome === 'forest' && Math.random() < 0.2) playWaterBurble();
            }, 3800 + Math.random() * 2000);
        }

        // =====================================================================
        // MUSIC SYSTEM ‚Äî procedural calm / intense layers
        // =====================================================================
        let musicState    = 'none'; // 'calm' | 'intense' | 'none'
        let musicNodes    = [];
        let musicFadeTimer = null;

        function stopMusic() {
            musicNodes.forEach(n => {
                try { n.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.4); setTimeout(() => { try { n.osc.stop(); } catch(e){} }, 600); } catch(e) {}
            });
            musicNodes = [];
            musicState = 'none';
        }

        function startCalmMusic() {
            if (musicState === 'calm') return;
            stopMusic();
            musicState = 'calm';
            // Gentle ambient drone: 3 harmonically-related sine tones
            const baseFreq = 110;
            [[1, 0.018], [1.5, 0.012], [2, 0.008]].forEach(([mult, vol]) => {
                const osc  = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = baseFreq * mult;
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 2.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start();
                musicNodes.push({ osc, gain });
            });
            // Slow LFO-like frequency wobble via setInterval
            const wobbleId = setInterval(() => {
                if (musicState !== 'calm') { clearInterval(wobbleId); return; }
                musicNodes.forEach((n, i) => {
                    const base = 110 * [1, 1.5, 2][i] || 110;
                    n.osc.frequency.setTargetAtTime(base + Math.sin(Date.now() * 0.0004) * 3, audioCtx.currentTime, 0.8);
                });
            }, 200);
        }

        function startIntenseMusic() {
            if (musicState === 'intense') return;
            stopMusic();
            musicState = 'intense';
            // Driving pulse: square wave bass + higher harmonic
            const baseFreq = 110;
            [[1, 'square', 0.022], [2, 'sawtooth', 0.012], [3, 'square', 0.007]].forEach(([mult, type, vol]) => {
                const osc  = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.value = baseFreq * mult;
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 1.2);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start();
                musicNodes.push({ osc, gain });
            });
            // Rhythmic accent pulse every ~500ms
            const rhythmId = setInterval(() => {
                if (musicState !== 'intense') { clearInterval(rhythmId); return; }
                playSound(55, 0.08, 'square', 0.025);
            }, 500);
        }

        // Called from waveComplete and enemy spawning
        function setMusicForState(state) {
            if (state === 'calm')   { clearTimeout(musicFadeTimer); musicFadeTimer = setTimeout(startCalmMusic,  400); }
            if (state === 'intense') { clearTimeout(musicFadeTimer); musicFadeTimer = setTimeout(startIntenseMusic, 200); }
            if (state === 'stop')   { clearTimeout(musicFadeTimer); stopMusic(); }
        }

        // =====================================================================
        // ACHIEVEMENT SYSTEM
        // =====================================================================
        function checkAchievements() {
            for (const ach of ACHIEVEMENTS) {
                if (!earnedAchievements.has(ach.id) && ach.check()) {
                    earnedAchievements.add(ach.id);
                    saveAchievements();
                    showAchievementToast(ach);
                }
            }
        }

        function showAchievementToast(ach) {
            playSound(880, 0.08, 'sine', 0.1);
            setTimeout(() => playSound(1100, 0.12, 'sine', 0.08), 100);
            const container = document.getElementById('achievement-toasts');
            if (!container) return;
            const toast = document.createElement('div');
            toast.style.cssText = `
                background:linear-gradient(135deg,rgba(241,196,15,0.22),rgba(255,255,255,0.08));
                border:1px solid rgba(241,196,15,0.55);border-radius:10px;
                padding:10px 16px;display:flex;align-items:center;gap:10px;
                box-shadow:0 4px 18px rgba(0,0,0,0.5);
                animation:achSlideIn 0.35s ease-out;
                max-width:280px;
            `;
            toast.innerHTML = `
                <span style="font-size:26px;">${ach.icon}</span>
                <div>
                    <div style="color:#f1c40f;font-size:11px;font-weight:900;letter-spacing:1px;">ACHIEVEMENT UNLOCKED</div>
                    <div style="color:#fff;font-size:13px;font-weight:800;margin:1px 0;">${ach.name}</div>
                    <div style="color:rgba(255,255,255,0.55);font-size:11px;">${ach.desc}</div>
                </div>
            `;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.transition = 'opacity 0.5s, transform 0.5s';
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(40px)';
                setTimeout(() => toast.remove(), 500);
            }, 3500);
        }

        // Inject achievement slide-in keyframe
        const achStyle = document.createElement('style');
        achStyle.textContent = `@keyframes achSlideIn { from { opacity:0; transform:translateX(40px); } to { opacity:1; transform:translateX(0); } }`;
        document.head.appendChild(achStyle);

        // Tracking vars for achievements
        window._headshotsThisRun    = 0;
        window._bossesKilled        = 0;
        window._wavesWithoutDamage  = 0;
        window._damageThisWave      = false;

        // (PLAYER_SKINS / WEAPON_SKINS moved above buildStartScreenUI call)

        function applySkinToPlayer() {
            const skin = PLAYER_SKINS.find(s => s.id === selectedSkin) || PLAYER_SKINS[0];
            player.traverse(child => {
                if (!child.isMesh || !child.material) return;
                const col = child.material.color?.getHex();
                // Torso + arms use the main skin color
                if (col === 0x2196f3 || col === player.userData._skinColor) {
                    child.material.color.setHex(skin.color);
                }
                // Head
                if (col === 0xffdbac || col === player.userData._headColor) {
                    child.material.color.setHex(skin.head);
                }
                // Pants/legs
                if (col === 0x2c3e50 || col === player.userData._pantsColor) {
                    child.material.color.setHex(skin.pants);
                }
            });
            player.userData._skinColor  = skin.color;
            player.userData._headColor  = skin.head;
            player.userData._pantsColor = skin.pants;
        }

        function applyWeaponSkin() {
            const ws = WEAPON_SKINS.find(s => s.id === selectedWepSkin) || WEAPON_SKINS[0];
            // Apply to held knife
            player.userData.heldKnife.traverse(c => {
                if (!c.isMesh) return;
                const h = c.material.color?.getHex();
                if (h === 0xc0c0c0 || h === player.userData._wsBlade) {
                    c.material.color.setHex(ws.bladeColor);
                    c.material.emissive?.setHex(ws.emissive);
                    c.material.emissiveIntensity = ws.glow ? 0.6 : 0;
                }
                if (h === 0x3d2817 || h === player.userData._wsHandle) {
                    c.material.color.setHex(ws.handleColor);
                }
            });
            player.userData._wsBlade  = ws.bladeColor;
            player.userData._wsHandle = ws.handleColor;
            // Store for thrown knife creation
            player.userData.activeWepSkin = ws;
        }

        function buildSkinUI() {
            const container = document.getElementById('skin-btns');
            if (!container) return;
            container.innerHTML = '';
            PLAYER_SKINS.forEach(skin => {
                const btn = document.createElement('button');
                const isActive = selectedSkin === skin.id;
                btn.style.cssText = `width:36px;height:36px;border-radius:50%;border:3px solid ${isActive ? '#fff' : 'rgba(255,255,255,0.2)'};background:#${skin.color.toString(16).padStart(6,'0')};cursor:pointer;transition:all 0.15s;box-shadow:${isActive ? '0 0 12px rgba(255,255,255,0.6)' : 'none'};`;
                btn.title = skin.label;
                btn.addEventListener('click', () => {
                    selectedSkin = skin.id;
                    try { localStorage.setItem('capybara_skin', skin.id); } catch(e){}
                    buildSkinUI();
                });
                container.appendChild(btn);
            });
        }

        function buildWeaponSkinUI() {
            const container = document.getElementById('weapon-skin-btns');
            if (!container) return;
            container.innerHTML = '';
            WEAPON_SKINS.forEach(ws => {
                const btn = document.createElement('button');
                const isActive = selectedWepSkin === ws.id;
                btn.style.cssText = `padding:5px 10px;font-size:11px;font-weight:700;border-radius:8px;border:2px solid ${isActive ? '#f1c40f' : 'rgba(255,255,255,0.2)'};background:${isActive ? 'rgba(241,196,15,0.2)' : 'rgba(0,0,0,0.3)'};color:${isActive ? '#f1c40f' : 'rgba(255,255,255,0.7)'};cursor:pointer;transition:all 0.15s;`;
                btn.textContent = ws.label;
                btn.addEventListener('click', () => {
                    selectedWepSkin = ws.id;
                    try { localStorage.setItem('capybara_wepskin', ws.id); } catch(e){}
                    buildWeaponSkinUI();
                });
                container.appendChild(btn);
            });
        }

        // =====================================================================
        // DAMAGE NUMBERS
        // =====================================================================
        function spawnDamageNumber(worldPos, damage, isHeadshot) {
            const pos = worldPos.clone();
            pos.project(camera);
            if (pos.z > 1) return; // behind camera
            const x = (pos.x *  0.5 + 0.5) * window.innerWidth;
            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
            const el = document.createElement('div');
            el.style.cssText = `position:absolute;left:${x}px;top:${y}px;transform:translate(-50%,-50%);
                font-size:${isHeadshot ? 26 : 18}px;font-weight:900;
                color:${isHeadshot ? '#ff3333' : '#fff'};
                text-shadow:1px 1px 4px rgba(0,0,0,0.9),0 0 8px ${isHeadshot ? '#ff0000' : '#000'};
                pointer-events:none;z-index:300;font-family:'Arial Black',sans-serif;
                transition:top 0.6s ease-out,opacity 0.6s ease-in;`;
            el.textContent = isHeadshot ? `üíÄ ${damage}` : `-${damage}`;
            document.body.appendChild(el);
            requestAnimationFrame(() => {
                el.style.top = (y - 55) + 'px';
                el.style.opacity = '0';
            });
            setTimeout(() => el.remove(), 650);
        }

        // =====================================================================
        // SCREEN SHAKE ‚Äî moves the camera, never touches DOM (avoids stacking-context bug)
        // =====================================================================
        let shakeIntensity = 0;
        const shakeDecay   = 0.82;
        let   _shakeCameraOffset = new THREE.Vector3();

        function triggerScreenShake(intensity) {
            shakeIntensity = Math.max(shakeIntensity, intensity * 0.012);
        }

        function updateScreenShake() {
            // Remove last frame's offset
            camera.position.sub(_shakeCameraOffset);

            if (shakeIntensity < 0.0003) {
                shakeIntensity = 0;
                _shakeCameraOffset.set(0, 0, 0);
                return;
            }
            _shakeCameraOffset.set(
                (Math.random() - 0.5) * shakeIntensity,
                (Math.random() - 0.5) * shakeIntensity,
                0
            );
            camera.position.add(_shakeCameraOffset);
            shakeIntensity *= shakeDecay;
        }

        // =====================================================================
        // FLASHLIGHT + MOON SHADOW LIGHT  (scene.add calls happen after scene is created below)
        // =====================================================================
        let flashlight = null;
        let moonLight  = null;

        function updateFlashlightAndMoon(isDaytime, nightProgress) {
            if (!gameStarted || !flashlight) return;
            const nightStrength = Math.max(0, nightProgress);
            if (!isDaytime && nightStrength > 0.3) {
                const camPos = new THREE.Vector3();
                camera.getWorldPosition(camPos);
                const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
                flashlight.position.copy(camPos);
                flashlight.target.position.copy(camPos).addScaledVector(camDir, 10);
                flashlight.target.updateMatrixWorld();
                flashlight.intensity = Math.min(1.8, (nightStrength - 0.3) * 2.5);
            } else {
                flashlight.intensity = 0;
            }
            if (!isDaytime) {
                moonLight.position.copy(moonMesh.position);
                moonLight.intensity = nightStrength * 0.4;
            } else {
                moonLight.intensity = 0;
            }
        }

        // =====================================================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        // Now scene exists ‚Äî create flashlight and moon light
        flashlight = new THREE.SpotLight(0xffffff, 0, 30, Math.PI / 6, 0.4, 1.5);
        flashlight.castShadow = false;
        scene.add(flashlight);
        scene.add(flashlight.target);

        moonLight = new THREE.DirectionalLight(0x8899cc, 0);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width  = 1024;
        moonLight.shadow.mapSize.height = 1024;
        moonLight.shadow.camera.far    = 150;
        moonLight.shadow.camera.left   = -80;
        moonLight.shadow.camera.right  =  80;
        moonLight.shadow.camera.top    =  80;
        moonLight.shadow.camera.bottom = -80;
        scene.add(moonLight);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        // Pin canvas behind all UI ‚Äî prevents transform stacking-context from covering HUD
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top      = '0';
        renderer.domElement.style.left     = '0';
        renderer.domElement.style.zIndex   = '0';

        let dayNightTime = 180;
        const dayNightCycleSpeed = 360 / (180 * 60);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.far = 200;
        sun.shadow.camera.left = -100;
        sun.shadow.camera.right = 100;
        sun.shadow.camera.top = 100;
        sun.shadow.camera.bottom = -100;
        scene.add(sun);
        
        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x4a7c59, 0.3);
        scene.add(hemiLight);
        
        const sunMesh = new THREE.Mesh(
            new THREE.SphereGeometry(15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        sunMesh.visible = false;
        scene.add(sunMesh);
        
        const moonMesh = new THREE.Mesh(
            new THREE.SphereGeometry(18, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xdddddd })
        );
        moonMesh.visible = true;
        scene.add(moonMesh);
        
        const stars = [];
        for(let i = 0; i < 200; i++) {
            const star = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1.0 })
            );
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI / 2.5;
            const radius = 180;
            star.position.x = radius * Math.sin(phi) * Math.cos(theta);
            star.position.y = Math.abs(radius * Math.cos(phi)) + 30;
            star.position.z = radius * Math.sin(phi) * Math.sin(theta);
            star.visible = true;
            scene.add(star);
            stars.push(star);
        }
        
        const clouds = [];
        for(let i = 0; i < 15; i++) {
            const cloud = new THREE.Mesh(
                new THREE.BoxGeometry(Math.random()*8+4, Math.random()*2+1, Math.random()*8+4),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 })
            );
            cloud.position.set(Math.random()*150-75, Math.random()*30+40, Math.random()*150-75);
            scene.add(cloud);
            clouds.push(cloud);
        }
        
        function updateDayNightCycle() {
            if(!gameStarted) return;
            dayNightTime += dayNightCycleSpeed;
            if(dayNightTime > 360) dayNightTime -= 360;
            const timeRadians = (dayNightTime * Math.PI) / 180;
            const sunHeight = Math.sin(timeRadians);
            const sunAngle = timeRadians;
            const sunDistance = 150;
            sunMesh.position.x = sunDistance * Math.cos(sunAngle);
            sunMesh.position.y = Math.abs(sunHeight * sunDistance);
            sunMesh.position.z = sunDistance * Math.sin(sunAngle) * 0.5;
            moonMesh.position.x = -sunMesh.position.x;
            moonMesh.position.y = -sunMesh.position.y;
            moonMesh.position.z = -sunMesh.position.z;
            sun.position.copy(sunMesh.position);
            const b = BIOME_DEFS[currentBiome];
            const wDef = WEATHER_DEFS[currentWeather];
            // Fog range modified by weather
            const effectiveFogFar = b.fogFar * wDef.fogMult;
            scene.fog.near = b.fogNear * wDef.fogMult;
            scene.fog.far  = effectiveFogFar;
            const isDaytime = sunHeight > 0;
            const dayProgress = Math.max(0, sunHeight);
            const nightProgress = Math.max(0, -sunHeight);
            if(isDaytime) {
                const skyDay   = new THREE.Color(b.skyDay);
                const skyDawn  = new THREE.Color(b.dawnTint);
                const skyColor = skyDay.clone().lerp(skyDawn, (1 - dayProgress) * 0.5);
                scene.background = skyColor; scene.fog.color.copy(skyColor);
                ambientLight.intensity = 0.4 + dayProgress * 0.3;
                sun.intensity = 0.8 + dayProgress * 0.4;
                hemiLight.intensity = 0.2 + dayProgress * 0.2;
                stars.forEach(s => s.visible = false);
                moonMesh.visible = false; sunMesh.visible = true;
                const co = wDef.cloudOpacity;
                clouds.forEach(c => c.material.opacity = Math.min(co, 0.5 + dayProgress * 0.3));
            } else {
                const skyNight = new THREE.Color(b.skyNight);
                const skyDay2  = new THREE.Color(b.skyDay);
                const nightSky = skyNight.clone().lerp(skyDay2, (1 - nightProgress));
                scene.background = nightSky; scene.fog.color.copy(nightSky);
                ambientLight.intensity = 0.15 + (1 - nightProgress) * 0.3;
                sun.intensity = 0.3 + (1 - nightProgress) * 0.5;
                hemiLight.intensity = 0.05 + (1 - nightProgress) * 0.2;
                stars.forEach(s => { s.visible = true; s.material.opacity = 0.5 + Math.random() * 0.5; });
                moonMesh.visible = true; sunMesh.visible = false;
                clouds.forEach(c => c.material.opacity = 0.1 + (1 - nightProgress) * 0.3);
            }
            updateFlashlightAndMoon(isDaytime, nightProgress);
        }
        
        function animateClouds() {
            clouds.forEach((cloud, i) => {
                cloud.position.x += Math.sin(Date.now() * 0.0001 + i) * 0.01;
                cloud.position.z += Math.cos(Date.now() * 0.0001 + i) * 0.01;
                if(cloud.position.x > 100) cloud.position.x = -100;
                if(cloud.position.x < -100) cloud.position.x = 100;
                if(cloud.position.z > 100) cloud.position.z = -100;
                if(cloud.position.z < -100) cloud.position.z = 100;
            });
        }

        // =====================================================================
        // BIOME SYSTEM
        // =====================================================================
        const BIOME_DEFS = {
            forest:  { name:'Forest',    icon:'üå≤', floorColor:0x4caf50, floorRough:0.85, skyDay:0x87CEEB, skyNight:0x0a0a1a, dawnTint:0xff9966, fogNear:50,  fogFar:150, hemiGround:0x4a7c59, rockChance:0.30, waterChance:0.15, waterColor:0x2255cc, waterLabel:'Puddles',  iceSlide:false },
            desert:  { name:'Desert',    icon:'üèúÔ∏è', floorColor:0xd4a843, floorRough:0.95, skyDay:0xecc97a, skyNight:0x0d0a06, dawnTint:0xff7700, fogNear:70,  fogFar:200, hemiGround:0xc4982d, rockChance:0.55, waterChance:0.00, waterColor:0x0,        waterLabel:'',         iceSlide:false },
            snow:    { name:'Snowfield', icon:'‚ùÑÔ∏è', floorColor:0xe8eff5, floorRough:0.55, skyDay:0xb8d4e8, skyNight:0x08101a, dawnTint:0xffccaa, fogNear:22,  fogFar:85,  hemiGround:0x8aaabb, rockChance:0.25, waterChance:0.22, waterColor:0xaaccdd, waterLabel:'Ice',      iceSlide:true  }
        };
        const BIOME_SEQUENCE = ['forest','desert','snow'];
        let currentBiome = 'forest';
        const waterZonesList = []; // { x, z, r, ice }

        function getBiomeForWave(wave) {
            return BIOME_SEQUENCE[Math.floor((wave - 1) / 10) % 3];
        }

        function applyBiome(name) {
            const b = BIOME_DEFS[name];
            currentBiome = name;
            scene.fog.near = b.fogNear;
            scene.fog.far  = b.fogFar;
            hemiLight.groundColor.set(b.hemiGround);
            // Update existing chunk floors
            terrainChunks.forEach(chunk => {
                if(chunk.floor) { chunk.floor.material.color.set(b.floorColor); chunk.floor.material.roughness = b.floorRough; }
            });
            document.getElementById('biome-label').innerText = `${b.icon} ${b.name}`;
        }

        // =====================================================================
        // WEATHER SYSTEM
        // =====================================================================
        const WEATHER_DEFS = {
            clear:  { label:'‚òÄÔ∏è Clear',   fogMult:1.0, overlayColor:'',                       overlayOpacity:0,    cloudOpacity:0.6, darkens:false },
            fog:    { label:'üå´Ô∏è Fog',     fogMult:0.3, overlayColor:'rgba(180,180,200,0.12)', overlayOpacity:0.7,  cloudOpacity:0.9, darkens:false },
            rain:   { label:'üåßÔ∏è Rain',    fogMult:0.55, overlayColor:'rgba(30,50,80,0.18)',    overlayOpacity:0.55, cloudOpacity:0.95, darkens:false },
            storm:  { label:'‚õàÔ∏è Storm',   fogMult:0.4, overlayColor:'rgba(10,10,30,0.35)',     overlayOpacity:0.85, cloudOpacity:1.0,  darkens:true  }
        };
        const WEATHER_POOL = ['clear','clear','clear','fog','rain','rain','storm'];
        let currentWeather = 'clear';
        let lastLightningTime = 0;
        let onIce = false;

        function pickWeather() {
            return WEATHER_POOL[Math.floor(Math.random() * WEATHER_POOL.length)];
        }

        function applyWeather(name) {
            currentWeather = name;
            const w = WEATHER_DEFS[name];
            const overlay = document.getElementById('weather-overlay');
            overlay.style.background = w.overlayColor;
            overlay.style.opacity = w.overlayOpacity;
            document.getElementById('weather-label').innerText = w.label;
            rainMesh.visible = (name === 'rain' || name === 'storm');
        }

        // Rain particle system (InstancedMesh for performance)
        const RAIN_COUNT = 400;
        const rainGeom = new THREE.BoxGeometry(0.03, 0.55, 0.03);
        const rainMat  = new THREE.MeshBasicMaterial({ color: 0x88aacc, transparent: true, opacity: 0.38 });
        const rainMesh = new THREE.InstancedMesh(rainGeom, rainMat, RAIN_COUNT);
        rainMesh.visible = false;
        scene.add(rainMesh);
        const _rainPos = [];
        for(let i = 0; i < RAIN_COUNT; i++) _rainPos.push({ x:(Math.random()-0.5)*80, y:Math.random()*32, z:(Math.random()-0.5)*80 });
        const _rainMat4 = new THREE.Matrix4();

        function updateRain() {
            if(!rainMesh.visible) return;
            const px = player.position.x, pz = player.position.z;
            const isStorm = currentWeather === 'storm';
            const fallSpeed = isStorm ? 1.1 : 0.65;
            const windX = isStorm ? 0.04 : 0;
            for(let i = 0; i < RAIN_COUNT; i++) {
                const p = _rainPos[i];
                p.y -= fallSpeed;
                p.x += windX;
                if(p.y < -2 || Math.abs(p.x - px) > 45 || Math.abs(p.z - pz) > 45) {
                    p.y = 28 + Math.random() * 6;
                    p.x = px + (Math.random()-0.5) * 78;
                    p.z = pz + (Math.random()-0.5) * 78;
                }
                _rainMat4.makeTranslation(p.x, p.y, p.z);
                rainMesh.setMatrixAt(i, _rainMat4);
            }
            rainMesh.instanceMatrix.needsUpdate = true;
        }

        function updateStormLightning() {
            if(currentWeather !== 'storm') return;
            const now = Date.now();
            if(now - lastLightningTime > 3500 + Math.random() * 5000) {
                lastLightningTime = now;
                const savedIntensity = ambientLight.intensity;
                ambientLight.intensity = 3.5;
                playSound(55, 0.6, 'sawtooth', 0.28);
                setTimeout(() => { ambientLight.intensity = savedIntensity; }, 80);
                setTimeout(() => { ambientLight.intensity = 3.0; }, 140);
                setTimeout(() => { ambientLight.intensity = savedIntensity; }, 220);
            }
        }

        function showBiomeWeatherBanner(biomeChanged, oldBiome, newBiome, weather) {
            const el = document.createElement('div');
            el.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:300;text-align:center;pointer-events:none;`;
            let html = '';
            if(biomeChanged) {
                const b = BIOME_DEFS[newBiome];
                html += `<div style="color:#fff;font-size:42px;font-family:'Arial Black',sans-serif;text-shadow:2px 2px 12px rgba(0,0,0,0.9);">${b.icon} ${b.name.toUpperCase()}</div>`;
            }
            const w = WEATHER_DEFS[weather];
            html += `<div style="color:rgba(255,255,255,0.8);font-size:22px;margin-top:6px;text-shadow:1px 1px 6px rgba(0,0,0,0.8);">${w.label}</div>`;
            el.innerHTML = html;
            document.body.appendChild(el);
            setTimeout(() => { el.style.transition='opacity 0.6s'; el.style.opacity='0'; setTimeout(()=>el.remove(), 700); }, 2200);
        }

        let collidables = [];
        const enemies = [];
        const bullets = [];
        const trees = [];
        
        const chunkSize = 50;
        const renderDistance = 150;
        const updateThreshold = renderDistance * 0.15;
        const terrainChunks = new Map();
        let lastPlayerChunkPos = { x: 0, z: 0 };
        const SPAWN_CLEAR_RADIUS = 6;
        const TREE_COLLISION_RADIUS = 0.9;
        
        function getChunkKey(x, z) { return `${x},${z}`; }
        function getChunkCoords(wx, wz) { return { x: Math.floor(wx / chunkSize), z: Math.floor(wz / chunkSize) }; }
        
        function createTerrainChunk(chunkX, chunkZ) {
            const chunkKey = getChunkKey(chunkX, chunkZ);
            if(terrainChunks.has(chunkKey)) return;
            const b = BIOME_DEFS[currentBiome];
            const chunk = { key: chunkKey, x: chunkX, z: chunkZ, trees: [], obstacles: [], waterZones: [], floor: null };

            // Floor
            const floorSegment = new THREE.Mesh(
                new THREE.PlaneGeometry(chunkSize, chunkSize),
                new THREE.MeshStandardMaterial({ color: b.floorColor, roughness: b.floorRough, metalness: 0.1 })
            );
            floorSegment.rotation.x = -Math.PI / 2;
            floorSegment.position.set(chunkX * chunkSize + chunkSize/2, 0, chunkZ * chunkSize + chunkSize/2);
            floorSegment.receiveShadow = true;
            scene.add(floorSegment);
            chunk.floor = floorSegment;

            const seed = chunkX * 1000 + chunkZ;
            const pr = (n) => Math.abs(Math.sin(seed * 127.1 + n * 311.7) * 43758.5453) % 1;

            // Trees / cacti / snow-trees
            const treeCount = 3 + (Math.abs(seed) % 4);
            for(let i = 0; i < treeCount; i++) {
                const tx = chunkX * chunkSize + pr(i * 2) * chunkSize;
                const tz = chunkZ * chunkSize + pr(i * 2 + 1) * chunkSize;
                if(Math.sqrt(tx*tx + tz*tz) < SPAWN_CLEAR_RADIUS) continue;
                chunk.trees.push(createTreeAt(tx, tz));
            }

            // Rocks / boulders (biome-driven density + include tall cliff rocks)
            if(pr(50) < b.rockChance) {
                const rockCount = 1 + Math.floor(pr(51) * 3);
                for(let i = 0; i < rockCount; i++) {
                    const rx = chunkX * chunkSize + pr(60 + i*3) * chunkSize;
                    const rz = chunkZ * chunkSize + pr(61 + i*3) * chunkSize;
                    if(Math.sqrt(rx*rx + rz*rz) < SPAWN_CLEAR_RADIUS + 2) continue;
                    const isCliff = (pr(62 + i*3) < 0.25); // 25% chance of tall cliff rock
                    createRockAt(rx, rz, isCliff, chunk);
                }
            }

            // Water / ice patches
            if(b.waterChance > 0 && pr(80) < b.waterChance) {
                const wx = chunkX * chunkSize + pr(81) * chunkSize;
                const wz = chunkZ * chunkSize + pr(82) * chunkSize;
                if(Math.sqrt(wx*wx + wz*wz) >= SPAWN_CLEAR_RADIUS + 3) {
                    createWaterPatch(wx, wz, b, chunk);
                }
            }

            terrainChunks.set(chunkKey, chunk);
        }

        function createTreeAt(x, z) {
            const tree = new THREE.Group();
            if(currentBiome === 'desert') {
                // Cactus: tall green cylinder body + arm stubs
                const bodyH = 2.8 + Math.random() * 1.4;
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.28, 0.35, bodyH, 7),
                    new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
                );
                body.position.y = bodyH / 2;
                body.castShadow = true;
                tree.add(body);
                // Arms
                const armH = 0.9; const armY = bodyH * 0.55;
                [-1, 1].forEach(side => {
                    if(Math.random() > 0.35) {
                        const arm = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.16, 0.2, armH, 6),
                            new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
                        );
                        arm.rotation.z = side * Math.PI / 2.5;
                        arm.position.set(side * 0.55, armY, 0);
                        arm.castShadow = true;
                        tree.add(arm);
                    }
                });
                // Add trunk as collidable
                const col = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, bodyH, 6), body.material);
                col.position.y = bodyH / 2;
                col.userData.isTree = true; col.visible = false;
                tree.add(col);
                collidables.push(col);
            } else if(currentBiome === 'snow') {
                // Snow-capped pine
                const trunk = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 2.8, 0.7),
                    new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.9 })
                );
                trunk.position.y = 1.4; trunk.castShadow = true;
                tree.add(trunk);
                // Layered snow foliage
                [[3.0, 2.6, 0.75], [2.2, 2.0, 0.55], [1.4, 1.4, 0.35]].forEach(([w, h, yOff]) => {
                    const layer = new THREE.Mesh(
                        new THREE.ConeGeometry(w * 0.5, h, 7),
                        new THREE.MeshStandardMaterial({ color: 0xeef4ff, roughness: 0.6 })
                    );
                    layer.position.y = 2.8 + yOff * 3.5; layer.castShadow = true;
                    tree.add(layer);
                    // Green under-layer
                    const green = new THREE.Mesh(
                        new THREE.ConeGeometry(w * 0.42, h * 0.85, 7),
                        new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.8 })
                    );
                    green.position.y = 2.8 + yOff * 3.5 - 0.15;
                    tree.add(green);
                });
                trunk.userData.isTree = true;
                collidables.push(trunk);
            } else {
                // Forest: original tree
                const trunk = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 3, 0.8),
                    new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9, metalness: 0.1 })
                );
                trunk.position.y = 1.5; trunk.castShadow = true; trunk.receiveShadow = true;
                const leaves = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 2.5, 2.5),
                    new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
                );
                leaves.position.y = 3.5; leaves.castShadow = true;
                tree.add(trunk, leaves);
                trunk.userData.isTree = true;
                collidables.push(trunk);
            }
            tree.position.set(x, 0, z);
            scene.add(tree);
            trees.push(tree);
            return tree;
        }

        function createRockAt(x, z, isCliff, chunk) {
            const rockColors = [0x888888, 0x777766, 0x997755, 0x666677];
            const col = rockColors[Math.floor(Math.random() * rockColors.length)];
            const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.9, metalness: 0.15 });

            const group = new THREE.Group();
            group.position.set(x, 0, z);

            if(isCliff) {
                // Tall cliff pillar ‚Äî 2-3 stacked irregular boxes
                const layers = 2 + Math.floor(Math.random() * 2);
                let yOff = 0;
                for(let l = 0; l < layers; l++) {
                    const w = 1.4 - l * 0.25 + Math.random() * 0.4;
                    const h = 1.6 + Math.random() * 1.2;
                    const rock = new THREE.Mesh(new THREE.BoxGeometry(w, h, w + Math.random() * 0.5), mat);
                    rock.position.set(Math.random() * 0.3 - 0.15, yOff + h/2, Math.random() * 0.3 - 0.15);
                    rock.rotation.y = Math.random() * 0.5;
                    rock.castShadow = true; rock.receiveShadow = true;
                    group.add(rock);
                    collidables.push(rock);
                    chunk.obstacles.push(rock);
                    yOff += h;
                }
            } else {
                // Scattered smaller boulder(s)
                const count = 1 + Math.floor(Math.random() * 3);
                for(let r = 0; r < count; r++) {
                    const sz = 0.5 + Math.random() * 1.1;
                    const rock = new THREE.Mesh(new THREE.BoxGeometry(sz, sz * 0.65, sz * 0.85), mat);
                    rock.position.set(Math.random() * 2 - 1, sz * 0.3, Math.random() * 2 - 1);
                    rock.rotation.set(Math.random()*0.4, Math.random()*Math.PI, Math.random()*0.3);
                    rock.castShadow = true; rock.receiveShadow = true;
                    group.add(rock);
                    collidables.push(rock);
                    chunk.obstacles.push(rock);
                }
            }
            scene.add(group);
            chunk.obstacles.push(group); // track group for scene removal
        }

        // All active water groups for per-frame animation
        // ---- WATER SHADER ----
        const waterVertexShader = `
            uniform float uTime;
            uniform float uRadius;
            varying vec2  vUv;
            varying float vDist;   // 0 = centre, 1 = edge
            varying float vWave;   // local wave height for foam

            void main() {
                vUv = uv;
                vec3 pos = position;

                // Distance from centre (normalised 0-1)
                float d = length(pos.xz) / uRadius;
                vDist = d;

                // Gerstner-like wave: several sine waves in XZ superimposed
                float w = 0.0;
                w += sin(pos.x * 1.8 + uTime * 1.6) * 0.055;
                w += sin(pos.z * 2.1 - uTime * 1.2) * 0.045;
                w += sin((pos.x + pos.z) * 1.3 + uTime * 0.9) * 0.035;
                w += sin((pos.x - pos.z) * 2.5 - uTime * 2.1) * 0.020;
                // Suppress waves at the very edge so they don't poke above ground
                w *= smoothstep(1.0, 0.6, d);
                pos.y += w;
                vWave = w;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const waterFragmentShader = `
            uniform float uTime;
            uniform float uRadius;
            varying vec2  vUv;
            varying float vDist;
            varying float vWave;

            void main() {
                // Scrolling caustic pattern: two overlapping sin grids
                vec2 uv = vUv * 4.0;
                float c1 = sin(uv.x * 3.0 + uTime * 1.1) * sin(uv.y * 2.8 - uTime * 0.8);
                float c2 = sin((uv.x + uv.y) * 2.5 - uTime * 1.4) * sin((uv.x - uv.y) * 2.2 + uTime * 1.0);
                float caustic = clamp((c1 + c2) * 0.5 + 0.5, 0.0, 1.0);

                // Depth colour: dark navy at centre -> teal at edge
                vec3 deepCol  = vec3(0.03, 0.18, 0.42);
                vec3 shallowCol = vec3(0.12, 0.55, 0.72);
                vec3 baseCol  = mix(deepCol, shallowCol, vDist * vDist);

                // Add caustic highlight
                baseCol += caustic * 0.12 * (1.0 - vDist);

                // Wave crest sparkle
                float crest = smoothstep(0.035, 0.06, vWave);
                baseCol += crest * vec3(0.6, 0.85, 1.0) * 0.55;

                // Fresnel-style fade: transparent at edge, opaque in centre
                float fresnel = 1.0 - smoothstep(0.55, 1.0, vDist);
                float alpha = mix(0.55, 0.92, fresnel);

                // Foam ring near edge
                float foam = smoothstep(0.78, 0.85, vDist) * (0.5 + 0.5 * sin(uTime * 3.0 + vDist * 30.0));
                baseCol = mix(baseCol, vec3(0.75, 0.92, 1.0), foam * 0.7);
                alpha = max(alpha, foam * 0.6);

                gl_FragColor = vec4(baseCol, alpha);
            }
        `;

        const iceVertexShader = `
            uniform float uTime;
            varying vec2  vUv;
            varying float vDist;

            void main() {
                vUv = uv;
                vDist = length(position.xz) / 6.0; // normalised (rough)
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const iceFragmentShader = `
            uniform float uTime;
            varying vec2  vUv;
            varying float vDist;

            // Simple pseudo-random for crack pattern
            float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }

            void main() {
                vec2 uv = vUv;

                // Base: icy blue-white gradient, centre slightly darker (depth)
                vec3 iceDeep    = vec3(0.55, 0.78, 0.92);
                vec3 iceShallow = vec3(0.88, 0.95, 1.00);
                vec3 baseCol = mix(iceDeep, iceShallow, vDist);

                // Iridescent shimmer band scrolling slowly
                float shimmer = sin((uv.x + uv.y) * 8.0 + uTime * 0.4) * 0.5 + 0.5;
                vec3 shiftCol = vec3(0.7 + shimmer * 0.3, 0.88 + shimmer * 0.1, 1.0);
                baseCol = mix(baseCol, shiftCol, shimmer * 0.22);

                // Internal refraction-like noise (fake sub-surface lines)
                float lines = abs(sin((uv.x * 6.0 + uv.y * 4.0) * 3.14159 + uTime * 0.15));
                baseCol += smoothstep(0.85, 1.0, lines) * vec3(0.3, 0.5, 0.7) * 0.18;

                // Edge frost
                float frost = smoothstep(0.72, 1.0, vDist);
                baseCol = mix(baseCol, vec3(1.0), frost * 0.55);

                float alpha = mix(0.80, 0.95, 1.0 - vDist * 0.6);
                alpha = mix(alpha, 0.55, frost);

                gl_FragColor = vec4(baseCol, alpha);
            }
        `;

        // Shared uniforms pool ‚Äî each water patch gets its own uTime ref
        const activeWaterMeshes = []; // { mesh, uniforms }

        function createWaterPatch(x, z, biomeDef, chunk) {
            const r = 2.8 + Math.random() * 3.2;
            const isIce = biomeDef.iceSlide;
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            group.userData.waterRadius = r;
            group.userData.isIce = isIce;

            const uniforms = {
                uTime:   { value: 0 },
                uRadius: { value: r }
            };

            if(isIce) {
                // Flat ice ‚Äî no vertex displacement, pure fragment shader
                const geom = new THREE.CircleGeometry(r, 48);
                const mat  = new THREE.ShaderMaterial({
                    vertexShader:   iceVertexShader,
                    fragmentShader: iceFragmentShader,
                    uniforms,
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = 0.015;
                group.add(mesh);
                activeWaterMeshes.push({ mesh, uniforms });

                // Crack lines on top ‚Äî dark thin planes
                const crackCount = 5 + Math.floor(Math.random() * 4);
                for(let c = 0; c < crackCount; c++) {
                    const angle = (c / crackCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.8;
                    const len   = r * (0.35 + Math.random() * 0.55);
                    const crackMat = new THREE.MeshBasicMaterial({
                        color: 0x4488aa, transparent: true, opacity: 0.45
                    });
                    const crack = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.02, len), crackMat
                    );
                    crack.rotation.y = angle;
                    crack.position.set(Math.cos(angle) * len * 0.4, 0.02, Math.sin(angle) * len * 0.4);
                    group.add(crack);

                    // Branching sub-cracks
                    if(Math.random() > 0.4) {
                        const subLen = len * (0.2 + Math.random() * 0.35);
                        const subAngle = angle + (Math.random() - 0.5) * 1.1;
                        const sub = new THREE.Mesh(
                            new THREE.BoxGeometry(0.03, 0.02, subLen), crackMat
                        );
                        sub.rotation.y = subAngle;
                        sub.position.set(Math.cos(angle) * len * 0.6, 0.021, Math.sin(angle) * len * 0.6);
                        group.add(sub);
                    }
                }

            } else {
                // Animated water ‚Äî subdivided plane for vertex wave displacement
                const segments = 36;
                const geom = new THREE.CircleGeometry(r, segments);
                const mat  = new THREE.ShaderMaterial({
                    vertexShader:   waterVertexShader,
                    fragmentShader: waterFragmentShader,
                    uniforms,
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.y = 0.012;
                group.add(mesh);
                activeWaterMeshes.push({ mesh, uniforms });
            }

            scene.add(group);
            activeWaterMeshes[activeWaterMeshes.length - 1].group = group;
            chunk.obstacles.push(group);
            const zone = { x, z, r, ice: isIce };
            waterZonesList.push(zone);
            chunk.waterZones.push(zone);
        }

        function updateWater() {
            if(activeWaterMeshes.length === 0) return;
            const t = Date.now() * 0.001;
            for(const entry of activeWaterMeshes) {
                entry.uniforms.uTime.value = t;
            }
        }
        
        function removeTerrainChunk(key) {
            const chunk = terrainChunks.get(key);
            if(!chunk) return;
            if(chunk.floor) { scene.remove(chunk.floor); chunk.floor.geometry.dispose(); chunk.floor.material.dispose(); }
            chunk.trees.forEach(tree => {
                scene.remove(tree);
                tree.children.forEach(child => {
                    child.geometry.dispose(); child.material.dispose();
                    const idx = collidables.indexOf(child);
                    if(idx > -1) collidables.splice(idx, 1);
                });
                const ti = trees.indexOf(tree);
                if(ti > -1) trees.splice(ti, 1);
            });
            // Remove rock/cliff obstacles
            chunk.obstacles.forEach(obj => {
                scene.remove(obj);
                if(obj.geometry) { obj.geometry.dispose(); if(obj.material) obj.material.dispose(); }
                const ci = collidables.indexOf(obj);
                if(ci > -1) collidables.splice(ci, 1);
                // Also remove from activeWaterMeshes if it's a water group
                for(let wi = activeWaterMeshes.length - 1; wi >= 0; wi--) {
                    if(activeWaterMeshes[wi].group === obj) { activeWaterMeshes.splice(wi, 1); break; }
                }
            });
            // Remove water zones from global list
            chunk.waterZones.forEach(zone => {
                const wi = waterZonesList.indexOf(zone);
                if(wi > -1) waterZonesList.splice(wi, 1);
            });
            terrainChunks.delete(key);
        }
        
        function updateTerrain() {
            const pp = player.position;
            const pc = getChunkCoords(pp.x, pp.z);
            const dist = Math.sqrt(
                Math.pow((pc.x - lastPlayerChunkPos.x) * chunkSize, 2) +
                Math.pow((pc.z - lastPlayerChunkPos.z) * chunkSize, 2)
            );
            if(dist < updateThreshold && terrainChunks.size > 0) return;
            lastPlayerChunkPos = { x: pc.x, z: pc.z };
            const cr = Math.ceil(renderDistance / chunkSize);
            const needed = new Set();
            for(let cx = pc.x - cr; cx <= pc.x + cr; cx++) {
                for(let cz = pc.z - cr; cz <= pc.z + cr; cz++) {
                    const ccx = cx * chunkSize + chunkSize/2, ccz = cz * chunkSize + chunkSize/2;
                    if(Math.sqrt(Math.pow(ccx-pp.x,2)+Math.pow(ccz-pp.z,2)) <= renderDistance) {
                        const k = getChunkKey(cx, cz);
                        needed.add(k);
                        createTerrainChunk(cx, cz);
                    }
                }
            }
            const toRemove = [];
            terrainChunks.forEach((_, k) => { if(!needed.has(k)) toRemove.push(k); });
            toRemove.forEach(k => removeTerrainChunk(k));
        }

        function createHealthBar(isWall = false) {
            const container = document.createElement('div');
            container.className = 'healthbar';
            const fill = document.createElement('div');
            fill.className = 'healthbar__fill ' + (isWall ? 'healthbar__fill--wall' : 'healthbar__fill--enemy');
            fill.style.width = '100%';
            container.appendChild(fill);
            document.body.appendChild(container);
            return { container, fill };
        }

        // Enemy projectiles (spit blobs from spitters)
        const enemyProjectiles = [];

        // Build a capybara mesh with given body/head colors and scale
        function buildCapybaraMesh(bodyColor, snoutColor, scale) {
            const character = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.8, metalness: 0.1 });
            const snoutMat = new THREE.MeshStandardMaterial({ color: snoutColor, roughness: 0.9, metalness: 0.1 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.7,1.8), bodyMat);
            body.position.y = 0.5; body.castShadow = true; character.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.6,0.7), bodyMat);
            head.position.set(0,0.65,1.0); head.castShadow = true; character.add(head);
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.3), snoutMat);
            snout.position.set(0,0.6,1.35); character.add(snout);
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshBasicMaterial({color:0x000000}));
            eyeL.position.set(-0.2,0.75,1.15); character.add(eyeL);
            const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshBasicMaterial({color:0x000000}));
            eyeR.position.set(0.2,0.75,1.15); character.add(eyeR);
            const earMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.8 });
            const earL = new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8), earMat);
            earL.position.set(-0.3,0.95,0.9); character.add(earL);
            const earR = new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8), earMat);
            earR.position.set(0.3,0.95,0.9); character.add(earR);
            const legMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.8 });
            const fll = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            fll.position.set(-0.4,0.25,0.6); fll.castShadow=true; character.add(fll); character.userData.frontLegLeft=fll;
            const flr = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            flr.position.set(0.4,0.25,0.6); flr.castShadow=true; character.add(flr); character.userData.frontLegRight=flr;
            const bll = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            bll.position.set(-0.4,0.25,-0.5); bll.castShadow=true; character.add(bll); character.userData.backLegLeft=bll;
            const blr = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.5,0.25), legMat);
            blr.position.set(0.4,0.25,-0.5); blr.castShadow=true; character.add(blr); character.userData.backLegRight=blr;
            character.scale.setScalar(scale);
            character.castShadow = true; character.receiveShadow = true;
            character.userData.animTime = 0; character.userData.vY = 0;
            character.userData.lastAttack = 0;
            return character;
        }

        // ENEMY TYPE DEFINITIONS
        // Each returns a fully configured Three.Group with userData stats
        function createScout() {
            const e = buildCapybaraMesh(0xa0522d, 0x7a3b10, 0.65); // small, tan
            e.userData.enemyType = 'scout';
            e.userData.health = 35; e.userData.maxHealth = 35;
            e.userData.speed = 0.10;
            e.userData.attackRange = 1.0; e.userData.attackCooldown = 800;
            e.userData.attackDamage = 8;
            e.userData.jumpCooldown = 4000; e.userData.lastJump = 0;
            return e;
        }

        function createNormal() {
            const e = buildCapybaraMesh(0x8b6f47, 0x654321, 1.0); // standard
            e.userData.enemyType = 'normal';
            e.userData.health = 100; e.userData.maxHealth = 100;
            e.userData.speed = 0.04;
            e.userData.attackRange = 1.2; e.userData.attackCooldown = 1000;
            e.userData.attackDamage = 20;
            return e;
        }

        function createTank() {
            const e = buildCapybaraMesh(0x4a3728, 0x2e1f0f, 1.75); // huge, dark brown
            // Crown/mark to distinguish
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xcc3300, roughness: 0.5 });
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(1.25,0.12,0.12), crownMat);
            stripe.position.set(0,0.82,0); e.add(stripe);
            e.userData.enemyType = 'tank';
            e.userData.health = 335; e.userData.maxHealth = 335;
            e.userData.speed = 0.022;
            e.userData.attackRange = 2.0; e.userData.attackCooldown = 1400;
            e.userData.attackDamage = 35;
            return e;
        }

        function createExploder() {
            const e = buildCapybaraMesh(0xcc6600, 0xff4400, 0.9); // orange tint
            // Glowing belly indicator
            const belly = new THREE.Mesh(
                new THREE.SphereGeometry(0.35,8,8),
                new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff3300, emissiveIntensity: 0.8, roughness: 0.4 })
            );
            belly.position.set(0, 0.45, 0.2); e.add(belly);
            e.userData.enemyType = 'exploder';
            e.userData.health = 60; e.userData.maxHealth = 60;
            e.userData.speed = 0.07;
            e.userData.attackRange = 1.8; e.userData.attackCooldown = 99999; // explodes once
            e.userData.attackDamage = 0; // handled by explosion
            e.userData.exploded = false;
            e.userData.belly = belly;
            return e;
        }

        function createSpitter() {
            const e = buildCapybaraMesh(0x557744, 0x334422, 1.0); // green-tinged
            // Green cheek puffs
            const puffMat = new THREE.MeshStandardMaterial({ color: 0x44bb44, emissive: 0x227722, emissiveIntensity: 0.4 });
            const pL = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), puffMat);
            pL.position.set(-0.45,0.68,1.0); e.add(pL);
            const pR = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), puffMat);
            pR.position.set(0.45,0.68,1.0); e.add(pR);
            e.userData.enemyType = 'spitter';
            e.userData.health = 80; e.userData.maxHealth = 80;
            e.userData.speed = 0.03;
            e.userData.attackRange = 1.2; e.userData.attackCooldown = 1200;
            e.userData.attackDamage = 10;
            e.userData.spitRange = 18;     // max spit distance
            e.userData.spitCooldown = 2800;
            e.userData.lastSpit = 0;
            e.userData.preferredDistance = 12; // tries to stay away
            return e;
        }

        function createArmored() {
            const e = buildCapybaraMesh(0x7a7a7a, 0x555555, 1.1); // grey metallic
            // Steel plate on front
            const plateMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.85, roughness: 0.2 });
            const plate = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.55, 0.12), plateMat);
            plate.position.set(0, 0.52, 0.95); e.add(plate);
            const shoulderL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), plateMat);
            shoulderL.position.set(-0.55, 0.6, 0.5); e.add(shoulderL);
            const shoulderR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), plateMat);
            shoulderR.position.set(0.55, 0.6, 0.5); e.add(shoulderR);
            e.userData.enemyType   = 'armored';
            e.userData.health      = 220; e.userData.maxHealth = 220;
            e.userData.speed       = 0.033;
            e.userData.attackRange = 1.4; e.userData.attackCooldown = 1100;
            e.userData.attackDamage= 28;
            e.userData.armorAngle  = Math.PI; // front arc (radians half-angle)
            return e;
        }

        function createRanged() {
            const e = buildCapybaraMesh(0x9e6b3a, 0x5c3a1a, 0.95); // sandy brown
            // Mud pouch on back
            const pouchMat = new THREE.MeshStandardMaterial({ color: 0x5a3010, roughness: 0.95 });
            const pouch = new THREE.Mesh(new THREE.SphereGeometry(0.28, 7, 7), pouchMat);
            pouch.position.set(0, 0.6, -0.75); e.add(pouch);
            e.userData.enemyType     = 'ranged';
            e.userData.health        = 70; e.userData.maxHealth = 70;
            e.userData.speed         = 0.028;
            e.userData.attackRange   = 1.2; e.userData.attackCooldown = 99999;
            e.userData.attackDamage  = 0;
            e.userData.preferredDistance = 14;
            e.userData.throwRange    = 18;
            e.userData.throwCooldown = 2200;
            e.userData.lastThrow     = 0;
            return e;
        }

        function createHealer() {
            const e = buildCapybaraMesh(0x3a8a3a, 0x1e5e1e, 0.9); // bright green
            // Green cross on back
            const crossMat = new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00aa55, emissiveIntensity: 0.7 });
            const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.12, 0.08), crossMat);
            crossH.position.set(0, 0.75, -0.5); e.add(crossH);
            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.55, 0.08), crossMat);
            crossV.position.set(0, 0.75, -0.5); e.add(crossV);
            e.userData.enemyType      = 'healer';
            e.userData.health         = 90; e.userData.maxHealth = 90;
            e.userData.speed          = 0.026;
            e.userData.attackRange    = 1.2; e.userData.attackCooldown = 99999;
            e.userData.attackDamage   = 0;
            e.userData.healRange      = 9;
            e.userData.healAmount     = 4;
            e.userData.healCooldown   = 2000;
            e.userData.lastHeal       = 0;
            e.userData.preferredDistance = 12; // hangs back
            e.userData.crossH         = crossH;
            e.userData.crossV         = crossV;
            return e;
        }

        function fireRangedThrow(en) {
            const mudGroup = new THREE.Group();
            const blob = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 7, 7),
                new THREE.MeshStandardMaterial({ color: 0x5a3010, roughness: 0.95, emissive: 0x200800, emissiveIntensity: 0.3 })
            );
            mudGroup.add(blob);
            const worldPos = new THREE.Vector3();
            en.getWorldPosition(worldPos);
            worldPos.y += 0.8;
            mudGroup.position.copy(worldPos);
            const dir = new THREE.Vector3().subVectors(player.position, worldPos);
            dir.y += 0.2;
            dir.normalize();
            mudGroup.userData.velocity = dir.multiplyScalar(0.7);
            mudGroup.userData.gravity  = -0.006;
            mudGroup.userData.life     = 160;
            mudGroup.userData.damage   = 12;
            scene.add(mudGroup);
            enemyProjectiles.push(mudGroup);
            playSound(160, 0.1, 'sawtooth', 0.06);
        }
        function createAlphaBoss() {
            const e = buildCapybaraMesh(0x1a0a00, 0x3d0000, 2.2);
            const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0xaa0000, emissiveIntensity: 0.6 });
            for(let i = -1; i <= 1; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 6), spikeMat);
                spike.position.set(i * 0.28, 1.05, 0); e.add(spike);
            }
            const redEyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            e.children.forEach(c => {
                if(c.geometry && c.geometry.type === 'SphereGeometry' && Math.abs(c.position.y - 0.75) < 0.1) {
                    c.material = redEyeMat;
                }
            });
            e.userData.enemyType    = 'boss';
            e.userData.health       = 1500; e.userData.maxHealth = 1500;
            e.userData.speed        = 0.035; e.userData._baseSpeed = 0.035;
            e.userData.attackRange  = 2.5; e.userData.attackCooldown = 900;
            e.userData.attackDamage = 40;
            e.userData.spitRange    = 25;
            e.userData.spitCooldown = 1800;
            e.userData.lastSpit     = 0;
            e.userData.jumpCooldown = 5000; e.userData.lastJump = 0;
            e.userData.isBoss       = true;
            e.userData.phase        = 1;
            return e;
        }

        // Pick enemy type based on current wave
        function createEnemyForWave(forceSwarm) {
            if(currentWave % 5 === 0 && currentWave > 0 && !forceSwarm) {
                if(!window._bossSpawnedThisWave) {
                    window._bossSpawnedThisWave = true;
                    return createAlphaBoss();
                }
            }
            const roll = Math.random();
            const w = currentWave;
            // Swarm enemies are fast, weak scouts
            if(forceSwarm) {
                const e = createScout();
                e.userData.health = Math.ceil(e.userData.maxHealth * 0.5);
                e.userData.maxHealth = e.userData.health;
                e.userData.speed *= 1.55;
                return e;
            }
            if(w >= 14 && roll < 0.10) return createHealer();
            if(w >= 12 && roll < 0.20) return createRanged();
            if(w >= 9  && roll < 0.30) return createArmored();
            if(w >= 10 && roll < 0.38) return createSpitter();
            if(w >= 8  && roll < 0.46) return createExploder();
            if(w >= 4  && roll < 0.56) return createTank();
            if(w >= 2  && roll < 0.68) return createScout();
            return createNormal();
        }

        function fireEnemySpit(en) {
            const spitGroup = new THREE.Group();
            const blob = new THREE.Mesh(
                new THREE.SphereGeometry(0.18, 7, 7),
                new THREE.MeshStandardMaterial({ color: 0x44dd44, emissive: 0x22aa22, emissiveIntensity: 0.7, roughness: 0.6 })
            );
            spitGroup.add(blob);
            const worldPos = new THREE.Vector3();
            en.getWorldPosition(worldPos);
            worldPos.y += 0.7 * en.scale.y;
            spitGroup.position.copy(worldPos);
            const dir = new THREE.Vector3().subVectors(player.position, worldPos);
            dir.y += 0.15; // slight arc
            dir.normalize();
            spitGroup.userData.velocity = dir.multiplyScalar(0.9);
            spitGroup.userData.gravity = -0.003;
            spitGroup.userData.life = 180;
            spitGroup.userData.damage = en.userData.isBoss ? 18 : 10;
            scene.add(spitGroup);
            enemyProjectiles.push(spitGroup);
            playSound(220, 0.12, 'sine', 0.07);
        }

        function triggerExplosion(en) {
            if(en.userData.exploded) return;
            en.userData.exploded = true;
            // Visual flash
            en.children.forEach(c => {
                if(c.material) c.material = new THREE.MeshBasicMaterial({ color: 0xff6600 });
            });
            playSound(80, 0.4, 'sawtooth', 0.18);
            setTimeout(() => playSound(120, 0.3, 'square', 0.12), 80);
            // Area damage to player
            const dist = player.position.distanceTo(en.position);
            const blastRadius = 4.5;
            if(dist < blastRadius && !isPowerUpActive('invincible')) {
                const rawDmg = Math.round(60 * (1 - dist / blastRadius));
                takeDamage(rawDmg);
                damageSound();
                triggerScreenShake(12);
            }
            // Show explosion ring indicator
            const expEl = document.createElement('div');
            expEl.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff6600;font-size:38px;font-weight:900;text-shadow:2px 2px 8px #000;pointer-events:none;z-index:200;`;
            expEl.innerText = 'üí• BOOM!';
            document.body.appendChild(expEl);
            setTimeout(() => expEl.remove(), 700);
            // Remove enemy
            setTimeout(() => {
                scene.remove(en);
                if(en.userData.healthBarElement) en.userData.healthBarElement.remove();
                const idx = enemies.indexOf(en);
                if(idx > -1) enemies.splice(idx, 1);
            }, 120);
        }

        function createHumanoid(color) {
            const character = new THREE.Group();
            if(color === 0xff4444) {
                // Legacy call ‚Äî return a normal capybara
                return createNormal();
            } else {
                // PLAYER
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), new THREE.MeshStandardMaterial({color:0xffdbac,roughness:0.7,metalness:0.1}));
                head.position.y = 1.5; head.castShadow = true; character.add(head);
                const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.7,0.3), new THREE.MeshStandardMaterial({color,roughness:0.6,metalness:0.2}));
                torso.position.y = 0.9; torso.castShadow = true; character.add(torso);
                const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.6,0.15), new THREE.MeshStandardMaterial({color,roughness:0.6,metalness:0.2}));
                lArm.position.set(-0.35,0.9,0); lArm.castShadow=true; character.add(lArm); character.userData.leftArm=lArm;
                const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.6,0.15), new THREE.MeshStandardMaterial({color,roughness:0.6,metalness:0.2}));
                rArm.position.set(0.35,0.9,0); rArm.castShadow=true; character.add(rArm); character.userData.rightArm=rArm;
                const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.2), new THREE.MeshStandardMaterial({color:0x2c3e50,roughness:0.7,metalness:0.3}));
                lLeg.position.set(-0.15,0.35,0); lLeg.castShadow=true; character.add(lLeg); character.userData.leftLeg=lLeg;
                const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.7,0.2), new THREE.MeshStandardMaterial({color:0x2c3e50,roughness:0.7,metalness:0.3}));
                rLeg.position.set(0.15,0.35,0); rLeg.castShadow=true; character.add(rLeg); character.userData.rightLeg=rLeg;
                character.userData.animTime = 0; character.userData.vY = 0;
            }
            character.castShadow = true; character.receiveShadow = true;
            return character;
        }

        const player = createHumanoid(0x2196f3);
        scene.add(player);
        
        // Held weapons setup (same as original)
        const heldKnife = new THREE.Group();
        const heldBlade = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.3,0.015), new THREE.MeshStandardMaterial({color:0xc0c0c0,metalness:0.8,roughness:0.2}));
        heldBlade.position.y = 0.12; heldKnife.add(heldBlade);
        const heldHandle = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.025), new THREE.MeshStandardMaterial({color:0x3d2817,roughness:0.7,metalness:0.1}));
        heldHandle.position.y = -0.06; heldKnife.add(heldHandle);
        heldKnife.position.set(0,-0.35,0); heldKnife.rotation.x = -Math.PI/2; heldKnife.scale.setScalar(0.8);
        player.userData.rightArm.add(heldKnife); player.userData.heldKnife = heldKnife;
        
        const heldBow = new THREE.Group();
        const bowMat = new THREE.MeshStandardMaterial({color:0x5d4037,roughness:0.8,metalness:0.1});
        heldBow.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.05), bowMat)));
        const bl1 = new THREE.Mesh(new THREE.BoxGeometry(0.03,0.35,0.04), bowMat);
        bl1.position.set(0,0.3,0); bl1.rotation.z=-0.4; heldBow.add(bl1);
        const bl2 = new THREE.Mesh(new THREE.BoxGeometry(0.03,0.35,0.04), bowMat);
        bl2.position.set(0,-0.3,0); bl2.rotation.z=0.4; heldBow.add(bl2);
        const bs = new THREE.Mesh(new THREE.BoxGeometry(0.008,0.55,0.002), new THREE.MeshStandardMaterial({color:0x888888,roughness:0.5}));
        bs.position.set(0,0,0.025); heldBow.add(bs);
        heldBow.position.set(0,-0.35,0); heldBow.rotation.x=Math.PI/3; heldBow.rotation.z=-Math.PI/8;
        heldBow.visible=false; player.userData.rightArm.add(heldBow); player.userData.heldBow=heldBow;
        
        const heldSpear = new THREE.Group();
        const spearShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.022,0.85,8), new THREE.MeshStandardMaterial({color:0x6b4423,roughness:0.7,metalness:0.1}));
        spearShaft.position.y=0.35; heldSpear.add(spearShaft);
        const spearHead = new THREE.Mesh(new THREE.ConeGeometry(0.025,0.25,8), new THREE.MeshStandardMaterial({color:0x909090,metalness:0.7,roughness:0.25}));
        spearHead.position.y=0.78; heldSpear.add(spearHead);
        const spearCollar = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.06,6), new THREE.MeshStandardMaterial({color:0x706050,metalness:0.5,roughness:0.4}));
        spearCollar.position.y=0.66; heldSpear.add(spearCollar);
        heldSpear.position.set(0,-0.35,0); heldSpear.rotation.x=-Math.PI/2; heldSpear.rotation.z=Math.PI/12; heldSpear.scale.setScalar(0.9);
        heldSpear.visible=false; player.userData.rightArm.add(heldSpear); player.userData.heldSpear=heldSpear;
        
        const heldAxe = new THREE.Group();
        const axeHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.03,0.6,6), new THREE.MeshStandardMaterial({color:0x4a3728,roughness:0.8,metalness:0.1}));
        axeHandle.position.y=0.15; heldAxe.add(axeHandle);
        const axeHeadBody = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.12,0.05), new THREE.MeshStandardMaterial({color:0x606060,metalness:0.6,roughness:0.35}));
        axeHeadBody.position.set(0,0.55,0); heldAxe.add(axeHeadBody);
        const axeBlade = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.18,0.03), new THREE.MeshStandardMaterial({color:0x808080,metalness:0.7,roughness:0.25}));
        axeBlade.position.set(0.08,0.55,0); axeBlade.rotation.z=-0.2; heldAxe.add(axeBlade);
        heldAxe.position.set(0,-0.35,0); heldAxe.rotation.x=-Math.PI/2.5; heldAxe.rotation.z=Math.PI/6;
        heldAxe.visible=false; player.userData.rightArm.add(heldAxe); player.userData.heldAxe=heldAxe;
        
        const camPivot = new THREE.Group();
        camPivot.position.y = 1.6;
        player.add(camPivot);
        camPivot.add(camera);
        camera.position.set(0, 0.5, 4);

        let wood = 30;
        let health = 100;
        let activeSlot = 1;
        let lastDamageTime = 0;
        let gameStarted = false;
        let currentAmmo = 30;
        let reserveAmmo = 90;
        let maxMagSize = 30;
        let isReloading = false;
        let currentArrows = 20;
        let maxArrows = 50;
        let currentSpears = 5;
        let maxSpears = 10;
        let lastAxeSwing = 0;
        let lastSpearThrow = 0;
        const axeCooldown = 300;
        let killCount = 0;
        let currentWave = 1;
        let enemiesInWave = 5;
        let enemiesKilledThisWave = 0;
        let lastShotTime = 0;
        const fireRate = 142;
        let isMouseDown = false;
        let bowChargeStart = 0;
        let bowCharging = false;
        const BOW_CHARGE_MAX_MS = 1000;
        const BOW_RAPID_DAMAGE = 22;
        const BOW_MAX_DAMAGE = 85;
        
        // Apply persistent skill tree bonuses from previous runs
        applyAllSkillBonuses();
        updateTerrain();

        function applyDifficultyToEnemy(e) {
            const dm = getDifficultyMult();
            e.userData.health    = Math.floor(e.userData.health    * dm.enemyHPMult);
            e.userData.maxHealth = Math.floor(e.userData.maxHealth * dm.enemyHPMult);
            e.userData.speed    *= dm.enemySpeedMult;
            if(activeMode === 'challenge' && activeChallenge === 'speed') e.userData.speed *= 2.0;
            if(e.userData.attackDamage) e.userData.attackDamage = Math.ceil(e.userData.attackDamage * dm.enemyDmgMult);
        }

        function spawnEnemy(forceSwarm) {
            const e = createEnemyForWave(forceSwarm);
            e.position.set(Math.random()*60-30, 0, Math.random()*60-30);
            scene.add(e);
            const hBar = createHealthBar(false);
            e.userData.healthBarElement = hBar.container;
            e.userData.healthBarFill = hBar.fill;
            const wm = 1 + (currentWave - 1) * 0.15;
            e.userData.health = Math.floor(e.userData.health * wm);
            e.userData.maxHealth = Math.floor(e.userData.maxHealth * wm);
            e.userData.speed = e.userData.speed + (currentWave - 1) * 0.002;
            applyDifficultyToEnemy(e);
            enemies.push(e);
        }
        
        function spawnEnemyNearPlayer() {
            const e = createEnemyForWave();
            const angle = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 70;
            e.position.set(player.position.x + Math.cos(angle)*dist, 0, player.position.z + Math.sin(angle)*dist);
            scene.add(e);
            const hBar = createHealthBar(false);
            e.userData.healthBarElement = hBar.container;
            e.userData.healthBarFill = hBar.fill;
            const wm = 1 + (currentWave - 1) * 0.15;
            e.userData.health = Math.floor(e.userData.health * wm);
            e.userData.maxHealth = Math.floor(e.userData.maxHealth * wm);
            e.userData.speed = e.userData.speed + (currentWave - 1) * 0.002;
            applyDifficultyToEnemy(e);
            enemies.push(e);
        }
        
        for(let i=0; i<enemiesInWave; i++) spawnEnemy();
        // Music starts when gameplay begins (called from launchGame)

        function useWeapon() {
            if(isMeleeOnly() && (activeSlot === 2 || activeSlot === 3)) {
                // Flash a message
                let el = document.getElementById('challenge-block-msg');
                if(!el) { el = document.createElement('div'); el.id='challenge-block-msg'; el.style.cssText='position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ffa500;font-size:20px;font-weight:900;text-shadow:2px 2px 6px #000;pointer-events:none;z-index:200;'; document.body.appendChild(el); }
                el.innerText = 'ü™ì MELEE ONLY!'; clearTimeout(el._t);
                el._t = setTimeout(() => { el.innerText=''; }, 900);
                return;
            }
            if (activeSlot === 1) shootKnife();
            else if (activeSlot === 3) throwSpear();
            else if (activeSlot === 4) swingAxe();
        }
        
        function shootKnife() {
            const now = Date.now();
            const effectiveFireRate = getEffectiveFireRate();
            if(currentAmmo === 0 || isReloading || (now - lastShotTime < effectiveFireRate)) return;
            lastShotTime = now;
            currentAmmo--;
            updateAmmoDisplay();
            shootSound();
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'knife';
            const knifeGroup = new THREE.Group();
            const ws = player.userData.activeWepSkin || { bladeColor:0xc0c0c0, handleColor:0x3d2817, emissive:0x000000, glow:false };
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.4,0.02), new THREE.MeshStandardMaterial({color:ws.bladeColor,metalness:0.8,roughness:0.2,emissive:new THREE.Color(ws.emissive),emissiveIntensity:ws.glow?0.5:0}));
            blade.position.y = 0.15; knifeGroup.add(blade);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.15,0.03), new THREE.MeshStandardMaterial({color:ws.handleColor,roughness:0.7,metalness:0.1}));
            handle.position.y = -0.1; knifeGroup.add(handle);
            knifeGroup.position.copy(player.position).add(new THREE.Vector3(0,1.5,0));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            knifeGroup.lookAt(knifeGroup.position.clone().add(dir));
            knifeGroup.userData.velocity = dir.multiplyScalar(1.2);
            knifeGroup.userData.life = 100 + getRangeBonus();
            knifeGroup.userData.rotationSpeed = 0.3;
            knifeGroup.userData.damage = getDamage(34, 'knife');
            knifeGroup.userData.gravity = 0;
            scene.add(knifeGroup);
            bullets.push(knifeGroup);
            if(currentAmmo === 0 && reserveAmmo > 0) setTimeout(() => reload(), 500);
        }
        
        function startBowCharge() {
            if(isMeleeOnly()) return; // blocked in melee challenge
            if (currentArrows <= 0 || bowCharging) return;
            bowCharging = true;
            bowChargeStart = Date.now();
        }
        
        function releaseBow() {
            if (!bowCharging || currentArrows <= 0) return;
            const now = Date.now();
            const holdTime = now - bowChargeStart;
            bowCharging = false;
            const effectiveChargeMax = getEffectiveBowChargeMax();
            const rapidThreshold = 200;
            const baseDmg = getDamage(BOW_RAPID_DAMAGE, 'bow');
            const maxDmg = getDamage(BOW_MAX_DAMAGE, 'bow');
            const damage = (holdTime < rapidThreshold)
                ? baseDmg
                : baseDmg + (Math.min(holdTime, effectiveChargeMax) / effectiveChargeMax) * (maxDmg - baseDmg);
            lastShotTime = now;
            currentArrows--;
            updateAmmoDisplay();
            playSound(250, holdTime < rapidThreshold ? 0.08 : 0.15, 'sine', 0.1);
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'bow';
            const arrowGroup = new THREE.Group();
            const arrowShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.02,0.55,8), new THREE.MeshStandardMaterial({color:0x5d4037,roughness:0.6,metalness:0.1}));
            arrowShaft.position.y = 0.18; arrowShaft.castShadow=true; arrowGroup.add(arrowShaft);
            const arrowHead = new THREE.Mesh(new THREE.ConeGeometry(0.025,0.15,8), new THREE.MeshStandardMaterial({color:0x909090,metalness:0.6,roughness:0.25}));
            arrowHead.position.y = 0.48; arrowHead.castShadow=true; arrowGroup.add(arrowHead);
            const arrowFletching = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.08,0.01), new THREE.MeshStandardMaterial({color:0xc62828,roughness:0.5}));
            arrowFletching.position.y = -0.1; arrowFletching.rotation.z = Math.PI/4; arrowGroup.add(arrowFletching);
            arrowGroup.position.copy(player.position).add(new THREE.Vector3(0,1.5,0));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion())).normalize();
            arrowGroup.lookAt(arrowGroup.position.clone().add(dir.clone()));
            arrowGroup.rotation.x += Math.PI/2;
            const speed = (holdTime < rapidThreshold) ? 0.7 : 0.7 + (Math.min(holdTime, effectiveChargeMax) / effectiveChargeMax) * 0.4;
            arrowGroup.userData.velocity = dir.clone().multiplyScalar(speed);
            arrowGroup.userData.life = 120 + getRangeBonus();
            arrowGroup.userData.rotationSpeed = 0;
            arrowGroup.userData.damage = Math.round(damage);
            arrowGroup.userData.gravity = -0.015;
            scene.add(arrowGroup);
            bullets.push(arrowGroup);
        }
        
        function throwSpear() {
            const now = Date.now();
            const spearFireRate = 600;
            if(currentSpears <= 0 || (now - lastSpearThrow < spearFireRate)) return;
            lastSpearThrow = now;
            currentSpears--;
            updateAmmoDisplay();
            playSound(180, 0.12, 'square', 0.1);
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'spear';
            const spearGroup = new THREE.Group();
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.025,0.7,8), new THREE.MeshStandardMaterial({color:0x6b4423,roughness:0.7}));
            shaft.position.y = 0.2; spearGroup.add(shaft);
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.035,0.25,8), new THREE.MeshStandardMaterial({color:0x909090,metalness:0.6,roughness:0.3}));
            head.position.y = 0.58; spearGroup.add(head);
            spearGroup.position.copy(player.position).add(new THREE.Vector3(0,1.5,0));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            spearGroup.lookAt(spearGroup.position.clone().add(dir));
            spearGroup.userData.velocity = dir.multiplyScalar(1.1);
            spearGroup.userData.life = 100 + getRangeBonus();
            spearGroup.userData.rotationSpeed = 0.2;
            spearGroup.userData.damage = getDamage(70, 'spear');
            spearGroup.userData.gravity = 0;
            scene.add(spearGroup);
            bullets.push(spearGroup);
        }
        
        function swingAxe() {
            const now = Date.now();
            const effectiveCooldown = axeCooldown * (1 - playerUpgrades.fireRateBonus);
            if (now - lastAxeSwing < effectiveCooldown) return;
            lastAxeSwing = now;
            player.userData.isThrowing = true;
            player.userData.throwStartTime = now;
            player.userData.attackType = 'axe';
            playSound(120, 0.15, 'sawtooth', 0.12);
            setTimeout(() => {
                const range = 3.5;
                const lookDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
                const playerPos = new THREE.Vector3().setFromMatrixPosition(player.matrixWorld);
                playerPos.y += 1;
                let closest = null, closestDist = range;
                enemies.forEach(en => {
                    const enPos = new THREE.Vector3().setFromMatrixPosition(en.matrixWorld);
                    const toEn = new THREE.Vector3().subVectors(enPos, playerPos).normalize();
                    const dist = playerPos.distanceTo(enPos);
                    if (dist < closestDist && lookDir.dot(toEn) > 0.5) { closestDist=dist; closest=en; }
                });
                if (closest) {
                    const dmg = getDamage(95, 'axe');
                    closest.userData.health -= dmg;
                    closest.userData.healthBarFill.style.width = (closest.userData.health / closest.userData.maxHealth * 100) + '%';
                    hitSound();
                    if (closest.userData.health <= 0) killEnemy(closest);
                }
                harvest();
            }, 90);
        }

        function killEnemy(en) {
            const enPos = en.position.clone();

            // Ragdoll ‚Äî keep mesh in scene briefly, animate tumble
            const eIdx = enemies.indexOf(en);
            if (eIdx > -1) enemies.splice(eIdx, 1);
            en.userData.healthBarElement.remove();
            spawnRagdoll(en);

            // Particles + shake
            spawnExplosionParticles(enPos.clone().add(new THREE.Vector3(0, 0.5, 0)));
            triggerScreenShake(en.userData.isBoss ? 12 : 2.5);

            // Sound
            if (en.userData.isBoss) capybaraBossRoar();
            else capybaraDeathSound();

            // Boss tracking
            if (en.userData.isBoss) window._bossesKilled = (window._bossesKilled || 0) + 1;

            killCount++;
            enemiesKilledThisWave++;
            document.getElementById('kill-counter').innerText = `ELIMINATIONS: ${killCount}`;
            document.getElementById('enemies-remaining').innerText = `ENEMIES: ${enemiesInWave - enemiesKilledThisWave}`;
            reserveAmmo = Math.min(reserveAmmo + 15 + skillTree.ammoPerKill, 300);
            currentArrows = Math.min(currentArrows + 5, maxArrows);
            currentSpears = Math.min(currentSpears + 2, maxSpears);

            // Skill-tree-scaled rewards
            wood += skillTree.woodPerKill;
            const healAmt = skillTree.healPerKill;
            health = Math.min(health + healAmt, maxPlayerHealth);
            updateAmmoDisplay();
            document.getElementById('mats').innerText = `ü™µ ${wood}`;
            document.getElementById('health-bar').style.width = (health / maxPlayerHealth * 100) + '%';

            // Coin reward ‚Äî boss worth more
            const coinReward = (en.userData.isBoss ? 25 : en.userData.enemyType === 'tank' ? 8 : 3) + skillTree.coinsPerKill;
            addCoins(coinReward);

            // Heal indicator
            const healEl = document.createElement('div');
            healEl.className = 'indicator indicator--heal';
            healEl.innerText = `+${healAmt} HP`;
            document.body.appendChild(healEl);
            setTimeout(() => {
                healEl.classList.add('indicator--fade-out','is-exiting');
                healEl.style.transform = 'translateY(-30px)';
                setTimeout(() => healEl.remove(), 500);
            }, 100);

            // Random power-up drop
            tryDropPowerUp(enPos);

            // Shockwave skill: slow nearby enemies on kill
            if(skillTree.wallHPBonus > 0) {
                const slowRadius = 4 + skillTree.wallHPBonus * 2;
                enemies.forEach(ally => {
                    if(ally.position.distanceTo(enPos) < slowRadius) {
                        const origSpeed = ally.userData._origSpeed || ally.userData.speed;
                        ally.userData._origSpeed = origSpeed;
                        ally.userData.speed = origSpeed * 0.4;
                        clearTimeout(ally.userData._slowTimer);
                        ally.userData._slowTimer = setTimeout(() => {
                            ally.userData.speed = origSpeed;
                        }, 1000 + skillTree.wallHPBonus * 500);
                        spawnParticles(ally.position.clone().add(new THREE.Vector3(0,0.8,0)), 5,
                            { color: 0x4488ff, size: 0.1, speed: 0.04, life: 18, explode: false });
                    }
                });
            }

            // Check achievements
            checkAchievements();

            if (enemiesKilledThisWave >= enemiesInWave) waveComplete();
        }

        function waveComplete() {
            const completedWave = currentWave;
            currentWave++;
            enemiesKilledThisWave = 0;
            // Enemy count scaled by difficulty
            const dm = getDifficultyMult();
            enemiesInWave = Math.max(3, Math.round((5 + (currentWave - 1) * 2) * dm.enemyCountMult));
            document.getElementById('wave-counter').innerText = `WAVE: ${currentWave}`;
            document.getElementById('enemies-remaining').innerText = `ENEMIES: ${enemiesInWave}`;

            // Auto-save removed
            setMusicForState('calm'); // calm music during upgrade break

            // Track damage-free waves for Untouchable achievement
            if (!window._damageThisWave) window._wavesWithoutDamage = (window._wavesWithoutDamage || 0) + 1;
            window._damageThisWave = false;
            checkAchievements();

            // Check biome change (every 10 waves)
            const newBiome = getBiomeForWave(currentWave);
            const biomeChanged = newBiome !== currentBiome;
            if(biomeChanged) {
                applyBiome(newBiome);
                const keys = [...terrainChunks.keys()];
                keys.forEach(k => removeTerrainChunk(k));
                lastPlayerChunkPos = { x: Infinity, z: Infinity };
            }

            const newWeather = pickWeather();
            applyWeather(newWeather);

            const isBossWave  = (currentWave % 5 === 0);
            const isSwarmWave = !isBossWave && (currentWave % 7 === 0);
            if(isSwarmWave) {
                enemiesInWave = Math.min(enemiesInWave * 3, 60);
                document.getElementById('enemies-remaining').innerText = `ENEMIES: ${enemiesInWave}`;
            }
            window._isSwarmWave = isSwarmWave;

            let bannerText = isBossWave  ? `‚ö†Ô∏è WAVE ${completedWave} COMPLETE! BOSS INCOMING!`
                           : isSwarmWave ? `üêÄ WAVE ${completedWave} COMPLETE! SWARM INCOMING!`
                           : `WAVE ${completedWave} COMPLETE!`;
            const waveMsg = document.createElement('div');
            waveMsg.className = 'indicator indicator--center indicator--wave-complete';
            waveMsg.innerText = bannerText;
            waveMsg.style.color = isBossWave ? '#ff4400' : isSwarmWave ? '#ff9900' : '';
            document.body.appendChild(waveMsg);

            pendingWaveSpawn = true;
            pendingWaveSize = enemiesInWave;
            window._bossSpawnedThisWave = false;
            setTimeout(() => {
                waveMsg.remove();
                if(biomeChanged || newWeather !== 'clear') showBiomeWeatherBanner(biomeChanged, currentBiome, newBiome, newWeather);
                showUpgradeScreen(completedWave);
            }, 1800);
        }
        
        function showFlashMessage(text, color='#ffffff') {
            const el = document.createElement('div');
            el.style.cssText = `position:absolute;top:38%;left:50%;transform:translate(-50%,-50%);color:${color};font-size:32px;font-weight:900;text-shadow:2px 2px 10px rgba(0,0,0,0.9);pointer-events:none;z-index:300;font-family:Arial Black,sans-serif;`;
            el.textContent = text;
            document.body.appendChild(el);
            setTimeout(() => { el.style.transition='opacity 0.5s'; el.style.opacity='0'; setTimeout(()=>el.remove(),500); }, 1500);
        }

        function takeDamage(amount) {
            const reduced = Math.max(1, Math.round(amount * (1 - skillTree.damageReduction)));
            health -= reduced;
            document.getElementById('health-bar').style.width = Math.max(0, health / maxPlayerHealth * 100) + '%';
            if(health <= 0) {
                if(skillTree.lastStandRanks > 0 && !skillTree.lastStandUsed) {
                    skillTree.lastStandUsed = true;
                    health = Math.ceil(maxPlayerHealth * 0.05);
                    document.getElementById('health-bar').style.width = (health / maxPlayerHealth * 100) + '%';
                    showFlashMessage('‚ö∞Ô∏è LAST STAND!', '#ff0066');
                    triggerScreenShake(10);
                } else {
                    showGameOver(currentWave - 1, killCount);
                }
            }
            return reduced;
        }

        function tryAutoFire() {
            if(!isMouseDown || !gameStarted) return;
            if (activeSlot === 1) shootKnife();
        }

        function harvest() {
            trees.forEach(tree => {
                if(player.position.distanceTo(tree.position) < 4) {
                    wood += 10;
                    document.getElementById('mats').innerText = `ü™µ ${wood}`;
                    tree.scale.set(1.2,1.2,1.2);
                    hitSound();
                    setTimeout(() => tree.scale.set(1,1,1), 100);
                }
            });
        }
        
        function updateAmmoDisplay() {
            const reloadPrompt = document.getElementById('reload-prompt');
            if (activeSlot === 1) {
                document.getElementById('ammo-display').innerText = `KNIFE: ${currentAmmo}/${reserveAmmo}`;
                reloadPrompt.classList.toggle('u-hidden', !(currentAmmo === 0 && reserveAmmo > 0));
            } else if (activeSlot === 2) {
                document.getElementById('ammo-display').innerText = `ARROWS: ${currentArrows}/${maxArrows}`;
                reloadPrompt.classList.add('u-hidden');
            } else if (activeSlot === 3) {
                document.getElementById('ammo-display').innerText = `SPEARS: ${currentSpears}/${maxSpears}`;
                reloadPrompt.classList.add('u-hidden');
            } else {
                document.getElementById('ammo-display').innerText = `AXE: READY`;
                reloadPrompt.classList.add('u-hidden');
            }
        }
        
        function reload() {
            if(isReloading || reserveAmmo === 0 || currentAmmo === maxMagSize) return;
            isReloading = true;
            reloadSound();
            document.getElementById('reload-prompt').innerText = 'Reloading...';
            document.getElementById('reload-prompt').classList.remove('u-hidden');
            setTimeout(() => {
                const needed = maxMagSize - currentAmmo;
                const toReload = Math.min(needed, reserveAmmo);
                currentAmmo += toReload; reserveAmmo -= toReload;
                isReloading = false;
                updateAmmoDisplay();
            }, getEffectiveReloadTime());
        }

        function animateCharacter(character, isMoving, isAttacking = false) {
            if (isMoving || isAttacking) character.userData.animTime += 0.1;
            const isCapybara = character.userData.frontLegLeft !== undefined;
            if(isCapybara) {
                let fLX=0, fRX=0, bLX=0, bRX=0;
                if(isMoving || isAttacking) {
                    const s = Math.sin(character.userData.animTime) * 0.3;
                    fLX=s; fRX=-s; bLX=-s; bRX=s;
                }
                const lf = 0.15;
                if(character.userData.frontLegLeft) character.userData.frontLegLeft.rotation.x += (fLX - character.userData.frontLegLeft.rotation.x) * lf;
                if(character.userData.frontLegRight) character.userData.frontLegRight.rotation.x += (fRX - character.userData.frontLegRight.rotation.x) * lf;
                if(character.userData.backLegLeft) character.userData.backLegLeft.rotation.x += (bLX - character.userData.backLegLeft.rotation.x) * lf;
                if(character.userData.backLegRight) character.userData.backLegRight.rotation.x += (bRX - character.userData.backLegRight.rotation.x) * lf;
            } else {
                let tLA=0, tRA=0, tLL=0, tRL=0;
                const at = character.userData.attackType || 'knife';
                const throwing = character.userData.isThrowing;
                const throwDur = (at==='axe') ? 220 : (at==='bow') ? 380 : 300;
                const tElapsed = Date.now() - (character.userData.throwStartTime || 0);
                if (throwing && character.userData.heldKnife) {
                    character.userData.heldKnife.visible = false;
                    if(character.userData.heldBow) character.userData.heldBow.visible = false;
                    if(character.userData.heldSpear) character.userData.heldSpear.visible = false;
                    if(character.userData.heldAxe) character.userData.heldAxe.visible = false;
                    if(tElapsed >= throwDur) { character.userData.isThrowing = false; updateHeldWeapon(); }
                } else if(character.userData.heldKnife && !throwing) { updateHeldWeapon(); }
                if(throwing && tElapsed < throwDur) {
                    const t = tElapsed / throwDur;
                    if(at==='bow') {
                        if(t<0.5) { tRA=(t/0.5)*1.6; tLA=-0.5; }
                        else { const rp=(t-0.5)/0.5; tRA=1.6-rp*2.4; tLA=-0.5+rp*0.3; }
                    } else if(at==='spear') {
                        if(t<0.2) { tRA=(t/0.2)*-2.2; tLA=-0.4; }
                        else if(t<0.48) { tRA=-2.2+((t-0.2)/0.28)*2.6; tLA=-0.4; }
                        else { tRA=0.4-((t-0.48)/0.52)*0.4; tLA=-0.4+((t-0.48)/0.52)*0.4; }
                    } else if(at==='axe') {
                        if(t<0.12) { tRA=(t/0.12)*1.3; tLA=0.15; }
                        else { const cp=(t-0.12)/0.88; tRA=1.3-cp*2.5; tLA=0.15-cp*0.2; }
                    } else {
                        if(t<0.2) { tRA=(t/0.2)*-2.1; tLA=-0.2; }
                        else if(t<0.48) { tRA=-2.1+((t-0.2)/0.28)*2.4; tLA=-0.2; }
                        else { tRA=0.3-((t-0.48)/0.52)*0.3; tLA=-0.2; }
                    }
                } else if(isMoving || isAttacking) {
                    const sw = Math.sin(character.userData.animTime) * (isAttacking ? 0.6 : 0.25);
                    tLA=sw; tRA=-sw;
                    if(isMoving) { const ls=Math.sin(character.userData.animTime)*0.35; tLL=ls; tRL=-ls; }
                }
                const lf = (throwing && tElapsed < throwDur) ? 0.35 : 0.15;
                const tRAZ = ((at==='spear'||at==='knife') && throwing && tElapsed < throwDur) ? 0.5 : 0;
                if(character.userData.leftArm) character.userData.leftArm.rotation.x += (tLA - character.userData.leftArm.rotation.x) * lf;
                if(character.userData.rightArm) { character.userData.rightArm.rotation.x += (tRA - character.userData.rightArm.rotation.x) * lf; character.userData.rightArm.rotation.z += (tRAZ - character.userData.rightArm.rotation.z) * lf; }
                if(character.userData.leftLeg) character.userData.leftLeg.rotation.x += (tLL - character.userData.leftLeg.rotation.x) * lf;
                if(character.userData.rightLeg) character.userData.rightLeg.rotation.x += (tRL - character.userData.rightLeg.rotation.x) * lf;
                if(isMoving) {
                    const tb = Math.abs(Math.sin(character.userData.animTime*2))*0.03;
                    if(!character.userData.currentBob) character.userData.currentBob=0;
                    character.userData.currentBob += (tb - character.userData.currentBob) * 0.2;
                    character.position.y += character.userData.currentBob - (character.userData.lastBob||0);
                    character.userData.lastBob = character.userData.currentBob;
                } else if(character.userData.currentBob) {
                    character.userData.currentBob *= 0.9;
                    character.position.y += character.userData.currentBob - (character.userData.lastBob||0);
                    character.userData.lastBob = character.userData.currentBob;
                }
            }
        }

        let keys = {}, playerVY = 0, playerGrounded = true, pitch = 0;
        let playerVelocity = new THREE.Vector3(0, 0, 0);
        window.onkeydown = (e) => {
            if(!gameStarted) return;
            keys[e.code] = true;
            if(e.code==='Digit1') { activeSlot=1; bowCharging=false; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='Digit2') { activeSlot=2; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='Digit3') { activeSlot=3; bowCharging=false; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='Digit4') { activeSlot=4; bowCharging=false; updateInventoryUI(); updateHeldWeapon(); updateAmmoDisplay(); }
            if(e.code==='KeyR') reload();
        };
        window.onkeyup = (e) => keys[e.code] = false;

        function updateInventoryUI() {
            [1,2,3,4].forEach(n => document.getElementById('slot'+n).classList.toggle('slot--active', activeSlot===n));
        }
        
        function updateHeldWeapon() {
            player.userData.heldKnife.visible = (activeSlot===1);
            player.userData.heldBow.visible = (activeSlot===2);
            player.userData.heldSpear.visible = (activeSlot===3);
            player.userData.heldAxe.visible = (activeSlot===4);
        }

        // ‚îÄ‚îÄ Input: works with OR without pointer lock ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let pointerLocked = false;
        let isDragging    = false;  // fallback: right-click drag to look

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === document.body;
        });

        document.addEventListener('mousedown', (e) => {
            if(!gameStarted) return;
            if(upgradeScreenOpen || shopScreenOpen) return;

            // Try to acquire pointer lock on any click (silently ignore failure)
            if(!pointerLocked) {
                try { document.body.requestPointerLock(); } catch(_) {}
            }

            if(e.button === 2) { isDragging = true; return; } // right-drag to look

            isMouseDown = true;
            if(activeSlot===2) startBowCharge();
            else if(activeSlot>=1 && activeSlot<=4) useWeapon();
        });

        document.addEventListener('mouseup', (e) => {
            if(activeSlot===2 && bowCharging) releaseBow();
            isMouseDown = false; bowCharging = false;
            if(e.button === 2) isDragging = false;
        });

        document.addEventListener('contextmenu', e => e.preventDefault());

        document.addEventListener('mousemove', (e) => {
            if(!gameStarted) return;
            const sens = 0.002;
            // Use movement from pointer lock OR from drag delta
            const dx = (pointerLocked || isDragging) ? e.movementX : 0;
            const dy = (pointerLocked || isDragging) ? e.movementY : 0;
            if(dx !== 0 || dy !== 0) {
                player.rotation.y -= dx * sens;
                pitch = Math.max(-0.8, Math.min(0.8, pitch - dy * sens));
                camPivot.rotation.x += (pitch - camPivot.rotation.x) * 0.3;
            }
        });
        
        function launchGame() {
            document.getElementById('start-screen').classList.add('u-hidden');
            document.getElementById('hud-root').style.display = 'block';
            gameStarted = true;
            audioCtx.resume();
            // Request pointer lock ‚Äî if it fails controls still work via right-drag
            try { document.body.requestPointerLock(); } catch(_) {}
            updateHeldWeapon();
            activeDifficulty = selectedDifficulty;
            activeMode       = selectedMode;
            activeChallenge  = selectedChallenge;
            runStartTime     = Date.now();
            applyDifficultyToGame(activeDifficulty);
            applyModeToGame(activeMode, activeChallenge);
            updateAmmoDisplay();
            startAmbientSounds();
            setMusicForState('intense');
            applySkinToPlayer();
            applyWeaponSkin();

            // Show control hint if pointer lock isn't available
            setTimeout(() => {
                if(!pointerLocked) {
                    const hint = document.createElement('div');
                    hint.id = 'control-hint';
                    hint.style.cssText = 'position:absolute;bottom:100px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.75);color:#fff;padding:10px 20px;border-radius:10px;font-size:14px;z-index:200;pointer-events:none;text-align:center;border:1px solid rgba(255,255,255,0.2);';
                    hint.innerHTML = 'üñ±Ô∏è <b>Left-click</b> to shoot &nbsp;|&nbsp; <b>Right-click drag</b> to look around &nbsp;|&nbsp; <b>WASD</b> to move';
                    document.body.appendChild(hint);
                    setTimeout(() => { if(hint.parentNode) hint.remove(); }, 5000);
                }
            }, 800);
        }

        function applyDifficultyToGame(diff) {
            const d = DIFFICULTIES[diff];
            if(!d) return;
            // Modify maxPlayerHealth
            maxPlayerHealth = Math.max(25, maxPlayerHealth + d.playerHPBonus);
            health = Math.min(health, maxPlayerHealth);
            document.getElementById('health-bar').style.width = (health / maxPlayerHealth * 100) + '%';
            // Enemy scaling is applied via getDifficultyMult() at spawn time
        }

        function applyModeToGame(mode, challenge) {
            if(mode === 'challenge') {
                if(challenge === 'glass') {
                    maxPlayerHealth = 1;
                    health = 1;
                    document.getElementById('health-bar').style.width = '100%';
                }
                // melee and speedrun: constraints enforced via isMeleeOnly() / isGlassCannon() at runtime
                // Show challenge reminder in HUD
                const badge = document.createElement('div');
                badge.id = 'challenge-hud-badge';
                badge.style.cssText = 'position:absolute;top:155px;left:50%;transform:translateX(-50%);color:#ffa500;font-size:14px;font-weight:900;text-shadow:2px 2px 6px rgba(0,0,0,0.9);pointer-events:none;z-index:50;';
                const c = CHALLENGES.find(ch=>ch.id===challenge);
                badge.innerText = c ? `${c.label} ACTIVE` : '';
                document.body.appendChild(badge);
            }
        }

        function getDifficultyMult() { return DIFFICULTIES[activeDifficulty] || DIFFICULTIES.normal; }

        document.getElementById('start-button').addEventListener('click', () => launchGame());

        function updateUIHealthBar(mesh, offsetY = 2.2) {
            if(!mesh.userData.healthBarElement) return;
            const pos = new THREE.Vector3();
            mesh.getWorldPosition(pos);
            pos.y += offsetY;
            pos.project(camera);
            mesh.userData.healthBarElement.style.left = (pos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            mesh.userData.healthBarElement.style.top = (-pos.y * 0.5 + 0.5) * window.innerHeight + 'px';
            mesh.userData.healthBarElement.style.display = (pos.z > 1 || (mesh.userData.health >= mesh.userData.maxHealth && mesh.userData.type==='wall')) ? 'none' : 'block';
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!gameStarted) { renderer.render(scene, camera); return; }
            
            updateDayNightCycle();
            animateClouds();
            updateRain();
            updateStormLightning();
            updateWater();
            updatePowerUps();
            updateParticles();
            updateRagdolls();
            updateMinimap();
            updateScreenShake();
            if (Date.now() % 30 < 2) checkAchievements(); // periodic poll
            tryAutoFire();
            
            // Bow charge bar
            const chargeBar = document.getElementById('bow-charge-bar');
            const chargeFill = document.getElementById('bow-charge-fill');
            chargeBar.classList.toggle('u-hidden', !(activeSlot===2 && bowCharging));
            if(activeSlot===2 && bowCharging) {
                const pct = Math.min((Date.now() - bowChargeStart) / getEffectiveBowChargeMax(), 1) * 100;
                chargeFill.style.width = pct + '%';
            }
            
            const baseSpeed = getEffectiveMoveSpeed() * (isPowerUpActive('speed') ? 1.6 : 1.0);
            const sprintMult = 1.6;
            let moveDir = new THREE.Vector3();
            let isMoving = false;
            if(keys['KeyW']) { moveDir.z -= 1; isMoving = true; }
            if(keys['KeyS']) { moveDir.z += 1; isMoving = true; }
            if(keys['KeyA']) { moveDir.x -= 1; isMoving = true; }
            if(keys['KeyD']) { moveDir.x += 1; isMoving = true; }

            // Check if player is on water or ice
            let waterMult = 1.0, iceDecel = false;
            for(const zone of waterZonesList) {
                const dx = player.position.x - zone.x, dz = player.position.z - zone.z;
                if(dx*dx + dz*dz < zone.r * zone.r) {
                    if(zone.ice) { iceDecel = true; }
                    else { waterMult = 0.45; }
                    break;
                }
            }

            const isSprinting = (keys['ShiftLeft'] || keys['ShiftRight']) && isMoving;
            const berserkerMult = (skillTree.berserkerRanks > 0 && health / maxPlayerHealth < 0.3) ? 1 + skillTree.berserkerRanks * 0.25 : 1;
            const effectiveSprint = sprintMult * (1 + skillTree.sprintBonus);
            const speed = (isSprinting ? baseSpeed * effectiveSprint : baseSpeed) * waterMult * berserkerMult;
            moveDir.normalize().applyQuaternion(player.quaternion);
            if(isMoving) { playerVelocity.lerp(moveDir.multiplyScalar(speed), 0.03); }
            else { playerVelocity.multiplyScalar(iceDecel ? 0.995 : 0.85); } // ice is slippery
            document.getElementById('sprint-indicator').classList.toggle('u-hidden', !isSprinting);
            
            if(playerVelocity.length() > 0.001) {
                const ray = new THREE.Raycaster(new THREE.Vector3(player.position.x,0.5,player.position.z), playerVelocity.clone().normalize());
                const hits = ray.intersectObjects(collidables);
                const blocked = hits.length > 0 && hits[0].distance < 0.8;
                const nx = player.position.x + playerVelocity.x;
                const nz = player.position.z + playerVelocity.z;
                let blockedTree = false;
                for(let t = 0; t < trees.length; t++) {
                    const dx = nx - trees[t].position.x, dz = nz - trees[t].position.z;
                    if(dx*dx + dz*dz < TREE_COLLISION_RADIUS * TREE_COLLISION_RADIUS) { blockedTree=true; break; }
                }
                if(!blocked && !blockedTree) player.position.add(playerVelocity);
            }
            
            if(isMoving && playerGrounded) {
                footstepSound(isSprinting);
                if(isSprinting && Math.random() < 0.25) spawnDustParticles(player.position.clone());
            }
            animateCharacter(player, isMoving);
            updateTerrain();
            
            player.position.y += playerVY; playerVY -= 0.01;
            const activeFloors = [];
            terrainChunks.forEach(c => { if(c.floor) activeFloors.push(c.floor); });
            const pDownRay = new THREE.Raycaster(new THREE.Vector3(player.position.x, player.position.y+1.2, player.position.z), new THREE.Vector3(0,-1,0));
            const pHit = pDownRay.intersectObjects([...collidables, ...activeFloors]);
            if(pHit.length > 0 && pHit[0].distance <= 1.25) { player.position.y = (player.position.y+1.2) - pHit[0].distance; playerVY=0; playerGrounded=true; }
            else playerGrounded = false;
            if(keys['Space'] && playerGrounded) { playerVY = 0.2 + skillTree.jumpHeightBonus; playerGrounded=false; }

            // Enemy AI
            enemies.forEach((en, idx) => {
                const dist = player.position.distanceTo(en.position);
                if(dist > renderDistance + 20) {
                    scene.remove(en);
                    if(en.userData.healthBarElement) en.userData.healthBarElement.remove();
                    enemies.splice(idx, 1);
                    spawnEnemyNearPlayer();
                    return;
                }

                const type = en.userData.enemyType || 'normal';
                const dirToPlayer = new THREE.Vector3().subVectors(player.position, en.position).normalize();
                const now = Date.now();

                // --- BOSS PHASE TRANSITION ---
                if(type === 'boss' && en.userData.phase === 1 && en.userData.health < en.userData.maxHealth * 0.5) {
                    en.userData.phase = 2;
                    en.userData.speed       = en.userData._baseSpeed * 1.7;
                    en.userData.attackDamage= 60;
                    en.userData.spitCooldown= 900;
                    en.userData.attackCooldown = 550;
                    // Flash all body parts red
                    en.traverse(c => { if(c.isMesh && c.material) { c.material = c.material.clone(); c.material.emissive = new THREE.Color(0x880000); c.material.emissiveIntensity = 0.5; } });
                    const phaseEl = document.createElement('div');
                    phaseEl.style.cssText = 'position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);color:#ff0000;font-size:40px;font-weight:900;text-shadow:0 0 20px #ff0000;pointer-events:none;z-index:300;font-family:Arial Black,sans-serif;';
                    phaseEl.textContent = 'üíÄ BOSS ENRAGED!';
                    document.body.appendChild(phaseEl);
                    triggerScreenShake(14);
                    playSound(80, 0.5, 'sawtooth', 0.2);
                    setTimeout(() => phaseEl.remove(), 2200);
                }

                // --- HEALER: pulse glow and heal nearby allies ---
                if(type === 'healer') {
                    const pulse = 0.4 + Math.sin(now * 0.004) * 0.4;
                    if(en.userData.crossH) en.userData.crossH.material.emissiveIntensity = pulse;
                    if(en.userData.crossV) en.userData.crossV.material.emissiveIntensity = pulse;
                    if(now - en.userData.lastHeal > en.userData.healCooldown) {
                        en.userData.lastHeal = now;
                        enemies.forEach(ally => {
                            if(ally === en) return;
                            const healDist = en.position.distanceTo(ally.position);
                            if(healDist < en.userData.healRange) {
                                ally.userData.health = Math.min(ally.userData.health + en.userData.healAmount, ally.userData.maxHealth);
                                if(ally.userData.healthBarFill) ally.userData.healthBarFill.style.width = (ally.userData.health / ally.userData.maxHealth * 100) + '%';
                                // Green heal particle
                                spawnParticles(ally.position.clone().add(new THREE.Vector3(0,1,0)), 4,
                                    { color: 0x00ff88, size: 0.09, speed: 0.05, life: 22, explode: false });
                            }
                        });
                    }
                }

                // --- RANGED: throw mud, keep distance ---
                if(type === 'ranged') {
                    if(dist < en.userData.throwRange && now - en.userData.lastThrow > en.userData.throwCooldown) {
                        en.userData.lastThrow = now;
                        fireRangedThrow(en);
                    }
                }

                // --- EXPLODER: pulse belly glow and explode on contact ---
                if(type === 'exploder') {
                    if(en.userData.belly) {
                        en.userData.belly.material.emissiveIntensity = 0.5 + Math.sin(now * 0.008) * 0.45;
                    }
                    if(dist < en.userData.attackRange * en.scale.x && !en.userData.exploded) {
                        triggerExplosion(en);
                        killEnemy(en);
                        return;
                    }
                }

                // --- SPITTER / BOSS: ranged spit attack ---
                if(type === 'spitter' || type === 'boss') {
                    if(dist < en.userData.spitRange && now - en.userData.lastSpit > en.userData.spitCooldown) {
                        en.userData.lastSpit = now;
                        fireEnemySpit(en);
                    }
                }

                const eRay = new THREE.Raycaster(new THREE.Vector3(en.position.x,0.5,en.position.z), dirToPlayer);
                const eHits = eRay.intersectObjects(collidables);
                let isBlocked = (eHits.length > 0 && eHits[0].distance < 0.8);

                // Spitters / healers / ranged try to maintain preferred distance
                if((type === 'spitter' || type === 'healer' || type === 'ranged') && dist < (en.userData.preferredDistance * 0.7)) {
                    const backDir = dirToPlayer.clone().negate();
                    en.position.add(new THREE.Vector3(backDir.x,0,backDir.z).multiplyScalar(en.userData.speed));
                } else if(!isBlocked && dist > en.userData.attackRange) {
                    en.position.add(new THREE.Vector3(dirToPlayer.x,0,dirToPlayer.z).multiplyScalar(en.userData.speed));
                } else if(isBlocked) {
                    const rDir = new THREE.Vector3(-dirToPlayer.z,0,dirToPlayer.x).normalize();
                    const lDir = new THREE.Vector3(dirToPlayer.z,0,-dirToPlayer.x).normalize();
                    const rRay = new THREE.Raycaster(new THREE.Vector3(en.position.x,0.5,en.position.z), rDir);
                    const lRay = new THREE.Raycaster(new THREE.Vector3(en.position.x,0.5,en.position.z), lDir);
                    const rH = rRay.intersectObjects(collidables);
                    const lH = lRay.intersectObjects(collidables);
                    if(!(rH.length > 0 && rH[0].distance < 0.8)) en.position.add(rDir.multiplyScalar(en.userData.speed * 0.7));
                    else if(!(lH.length > 0 && lH[0].distance < 0.8)) en.position.add(lDir.multiplyScalar(en.userData.speed * 0.7));
                }

                animateCharacter(en, !isBlocked && dist > en.userData.attackRange, false);
                en.rotation.y = Math.atan2(dirToPlayer.x, dirToPlayer.z);
                en.position.y += en.userData.vY; en.userData.vY -= 0.01;
                const eDown = new THREE.Raycaster(new THREE.Vector3(en.position.x,en.position.y+1.2,en.position.z), new THREE.Vector3(0,-1,0));
                const eHit2 = eDown.intersectObjects([...collidables, ...activeFloors]);
                if(eHit2.length > 0 && eHit2[0].distance <= 1.25) { en.position.y=(en.position.y+1.2)-eHit2[0].distance; en.userData.vY=0; }

                updateUIHealthBar(en, 2.2 * en.scale.y);

                // Melee damage to player
                const meleeDist = en.userData.attackRange * en.scale.x;
                if(dist < meleeDist && now - lastDamageTime > 1000 && type !== 'exploder' && !isPowerUpActive('invincible')) {
                    const rawDmg = en.userData.attackDamage || 20;
                    const dmg = takeDamage(rawDmg);
                    lastDamageTime = now; damageSound();
                    window._damageThisWave = true;
                    triggerScreenShake(en.userData.isBoss ? 9 : 5);
                    spawnDamageNumber(player.position.clone().add(new THREE.Vector3(0,2,0)), dmg, false);
                }
            });

            // Enemy projectile (spit) physics
            for(let i = enemyProjectiles.length-1; i >= 0; i--) {
                const proj = enemyProjectiles[i];
                proj.position.add(proj.userData.velocity);
                proj.userData.velocity.y += proj.userData.gravity;
                proj.userData.life--;
                if(proj.position.y < 0.2 || proj.userData.life <= 0) { scene.remove(proj); enemyProjectiles.splice(i,1); continue; }
                if(proj.position.distanceTo(player.position) < 1.0) {
                    if(!isPowerUpActive('invincible')) {
                        takeDamage(proj.userData.damage);
                        damageSound();
                    }
                    scene.remove(proj); enemyProjectiles.splice(i,1);
                }
            }

            collidables.forEach(c => { if(c.userData.type==='wall') updateUIHealthBar(c, 1.8); });
            // (wall health bars kept for safety, walls no longer buildable)

            // Bullet physics
            for(let i=bullets.length-1; i>=0; i--) {
                if(!bullets[i]) continue;
                bullets[i].position.add(bullets[i].userData.velocity);
                if(bullets[i].userData.gravity) bullets[i].userData.velocity.y += bullets[i].userData.gravity;
                if(bullets[i].userData.rotationSpeed) bullets[i].rotation.x += bullets[i].userData.rotationSpeed;
                
                const bRay = new THREE.Raycaster(
                    bullets[i].userData.lastPos || bullets[i].position.clone().sub(bullets[i].userData.velocity),
                    bullets[i].userData.velocity.clone().normalize(), 0, bullets[i].userData.velocity.length()
                );
                const obsHits = bRay.intersectObjects(collidables);
                if(obsHits.length > 0) {
                    scene.remove(bullets[i]); bullets.splice(i, 1); continue;
                }
                bullets[i].userData.lastPos = bullets[i].position.clone();
                
                enemies.forEach((en, eIdx) => {
                    if(!bullets[i]) return;
                    const bp = bullets[i].position;
                    const ewp = new THREE.Vector3();
                    en.getWorldPosition(ewp);
                    // Scale hitbox dimensions by the enemy's uniform scale
                    const s = en.scale.x;
                    const bMinX=ewp.x-0.6*s, bMaxX=ewp.x+0.6*s, bMinY=ewp.y+0.15*s, bMaxY=ewp.y+0.85*s, bMinZ=ewp.z-0.9*s, bMaxZ=ewp.z+0.9*s;
                    const hcz = ewp.z + Math.cos(en.rotation.y)*1.0*s, hcx = ewp.x + Math.sin(en.rotation.y)*1.0*s;
                    const hMinX=hcx-0.4*s, hMaxX=hcx+0.4*s, hMinY=ewp.y+0.35*s, hMaxY=ewp.y+0.95*s, hMinZ=hcz-0.35*s, hMaxZ=hcz+0.35*s;
                    const isHead = bp.x>=hMinX && bp.x<=hMaxX && bp.y>=hMinY && bp.y<=hMaxY && bp.z>=hMinZ && bp.z<=hMaxZ;
                    const isBody = bp.x>=bMinX && bp.x<=bMaxX && bp.y>=bMinY && bp.y<=bMaxY && bp.z>=bMinZ && bp.z<=bMaxZ;
                    if(isHead || isBody) {
                        const base = bullets[i].userData.damage || 34;
                        let dmg = isHead ? base * skillTree.headshotMult : base;

                        // ‚îÄ‚îÄ ARMORED: 85% damage reduction from the front ‚îÄ‚îÄ
                        if(en.userData.enemyType === 'armored') {
                            const enFwd  = new THREE.Vector3(Math.sin(en.rotation.y), 0, Math.cos(en.rotation.y));
                            const bDir   = bullets[i].userData.velocity.clone().normalize();
                            const isFrontal = bDir.dot(enFwd) < -0.35; // bullet heading into the front face
                            if(isFrontal) {
                                dmg = Math.max(1, Math.round(dmg * 0.15));
                                // Show "ARMORED!" hint once per hit
                                const alreadyShowing = document.getElementById('armor-hint');
                                if(!alreadyShowing) {
                                    const ah = document.createElement('div');
                                    ah.id = 'armor-hint';
                                    ah.style.cssText = 'position:absolute;top:42%;left:50%;transform:translate(-50%,-50%);color:#aaaaff;font-size:22px;font-weight:900;text-shadow:1px 1px 6px #000;pointer-events:none;z-index:300;';
                                    ah.textContent = 'üõ°Ô∏è ARMORED! Flank it!';
                                    document.body.appendChild(ah);
                                    setTimeout(() => ah.remove(), 1400);
                                }
                            }
                        }

                        en.userData.health -= dmg;
                        en.userData.healthBarFill.style.width = (en.userData.health / en.userData.maxHealth * 100) + '%';
                        hitSound();
                        // Floating damage number
                        const hitWorldPos = en.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                        spawnDamageNumber(hitWorldPos, dmg, isHead);
                        // Dust/blood particle burst on hit
                        const hitPos = bullets[i].position.clone();
                        spawnParticles(hitPos, 8, { color: isHead ? 0xcc2200 : 0x884422, size: 0.1, speed: 0.08, life: 22, explode: true });
                        if(isHead) {
                            window._headshotsThisRun = (window._headshotsThisRun || 0) + 1;
                            triggerScreenShake(4);
                            const hs = document.createElement('div');
                            hs.className = 'indicator indicator--center indicator--headshot';
                            hs.innerText = 'HEADSHOT!';
                            document.body.appendChild(hs);
                            setTimeout(() => { hs.classList.add('indicator--fade-out','is-exiting'); hs.style.transform='translate(-50%,-100%)'; setTimeout(()=>hs.remove(),500); }, 100);
                            playSound(800, 0.2, 'sine', 0.15);
                        }
                        scene.remove(bullets[i]); bullets.splice(i, 1);
                        if(en.userData.health <= 0) killEnemy(en);
                    }
                });
                if(bullets[i] && bullets[i].userData.life-- <= 0) { scene.remove(bullets[i]); bullets.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }
        animate();
        updateAmmoDisplay();

        // Add CSS for upgrade screen out animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes upgradeScreenOut { from { opacity:1; transform:scale(1); } to { opacity:0; transform:scale(1.05); } }
            @keyframes hintFadeIn { from { opacity:0; transform:translate(-50%,-60%); } to { opacity:1; transform:translate(-50%,-50%); } }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>